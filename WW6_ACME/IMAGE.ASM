;
!zone IMAGE
;
;
!SOURCE "WWSETUP.ASM"
!SOURCE "VARIABLS.ASM"
;
;
;
;
OFF_OFFWID =  25
OFF_ROWWRD =  23
OFF_LEADING =  22
OFF_DESCENT =  21
OFF_ASCENT =  20
OFF_POINTS =  19
OFF_KERNMAX =  18
OFF_LASTC =  17
OFF_FIRSTC =  16
;
INDEX:
!byte 0
S_INDEX:
!byte 0
PIXELS:
!word 0;WIDTH OF CHARACTER
LINE_BIT:
!byte 0
S_LINE_BIT:
!byte 0
ROWS:
!byte 0
;DOT_COLUMN:
; DW 0
FIRST_CHAR_IN_LINE:
!byte 0
CHAR_CODE:
!byte 0
KERN_WIDTH:
!word 0
BIGGEST_FONT:
!byte 0
BIGGEST_DESCEND:
!byte 0
BIGGEST_UND_DESCEND:
!byte 0
CURRENT_DESCEND:
!byte 0
ITEMP:
!byte 0
BASE_LINE:
!byte 0
SPACE_J_ADJUST:
!word 0
SPACE_R_ADJUST:
!byte 0
JUST_ADJUSTMENT:
!byte 0
ADJUST_THIS_CHAR:
!byte 0
LINE_LEADING:
!byte 0
LAST_LINE_LEADING:
!byte 0
FIRST_LINE:
!byte 0
SUBSCRIPTS_PRESENT:
!byte 0
RASTER_MAP_TABLE:
!word 0
KERN_WIDTH_TABLE:
!word 0
ALL_FONT_OR_HEADER:
!byte 1
FONT_IN_FAKE_FONT:
!byte $FF
THIS_LINE_LM:
!word 0
;
;
CLEAR_LINE:
 JSR W_INTO_P1
!word LINE_BUFFER
;
 JSR W_INTO_PT
!word LINE_SIZE;LINE_BUFFER_E-LINE_BUFFER
;
CLEAR_LINE_1:
 LDA #0
 JMP FILL_PT_P1_A     ;CLEAR LINE
;
CLEAR_BOTTOM:
 JSR PUSH_P1
 JSR W_INTO_P1
!word LINE_BUFFER_E
 JSR W_INTO_PT
!word BOT_SIZE
 JSR CLEAR_LINE_1
 JMP POP_P1
;
; IMAGE LINE STARTING HERE
;
IMAGE_LINE:
;
;FOR 1ST CALL ON A PAGE, SET FIRST_LINE = 0,
;AND SET LINE_LEADING = 0
;
 JSR PUSH_AX
 JSR CLEAR_LINE
;
 LDA FIRST_LINE       
 BEQ .NOT_FIRST_LINE
;
 LDA SUBSCRIPTS_PRESENT
 BEQ .NOT_FIRST_LINE        ;NOTHING TO DO IF NO SUBSCRIPTS
;
;FIND START
 JSR W_INTO_PT
!word LINE_BUFFER;SET PT AT START OF LINEBUFFER
;
 SEC
 LDA #L_BUFFER_DEPTH        ;EX. 38 RASTERS
 SBC BIGGEST_FONT           ;   -24 PT = 14
; SBC FONT_LEADING           ;   -10 LD =  4
 SBC USER_DEFINED_LEAD
;
 LDX #PLINE_WIDTH           ;LENGTH OF LINE
 JSR MUL_AX_PT              ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
 JSR PT_INTO_AX
 STA MOVELO
 STX MOVELO+1               ;SET DESTINATION ADDRESS
;
 LDA #<LINE_BUFFER_E     
 LDX #>LINE_BUFFER_E        ;START OF "BOTTOM LEADING"
 JSR AX_INTO_PT             ;TO FIND END ADDRESS
 STA MOVEHI
 STX MOVEHI+1
;
 JSR PUSH_EOT
;
; LDA FONT_LEADING           ;LAST LINE OR FONT LEADING, THE
 LDA USER_DEFINED_LEAD
 CMP LAST_LINE_LEADING      ;LESSER
 BCC .SKP 
 LDA LAST_LINE_LEADING
.SKP:
 LDX #PLINE_WIDTH           ;LENGTH OF LINE
 JSR MUL_AX_PT              ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
 JSR PT_INTO_AX
 JSR AX_INTO_EOT            ;EOT = END ADDRESS
; START ADDRESS = MOVEHI
; SOURCE = MOVELO
 JSR COPYDN
;
 JSR POP_EOT
;
 JSR CLEAR_BOTTOM
;
.NOT_FIRST_LINE:
;
 JSR POP_AX
;
;
IMAGE_LINE_AGAIN:
;
 INC FIRST_LINE          ;FIRST LINE ON PAGE NO BOT LEAD
 LDY EXPAND_ON           ;IS EXPANSION IN EFFECT?
 BEQ .NO_EXPAND 
 JSR LSR_AX              ;DIVIDE MARGIN BY 2 TO KEEP SAME AS UNEXPANDED
.NO_EXPAND: 
 STA DOT_COLUMN          ;.AX IS LM, INTO DOT_COLUMN
 STA THIS_LINE_LM
 STX DOT_COLUMN+1 
 STX THIS_LINE_LM+1
 LDA #0
 STA SUBSCRIPTS_PRESENT  ;FLAG IF A SUBSCRIPT PROCESSED
 STA LINE_BIT
 STA FIRST_CHAR_IN_LINE
;
 SEC                     ;SET BASE LINE
 LDA #L_BUFFER_DEPTH     ;EX. 38 RASTERS
 SBC BIGGEST_DESCEND     ;     6 PT DESCENT
 STA BASE_LINE           ;    32 (BIGGEST DESENT OFF BOTTOM)
;
 JSR LAST_PRINTABLE_CHR
 CPY #$FF
 BNE .REAL_LINE
 JMP .OUT                ;NULL LINE
;
.REAL_LINE:
 INY
 STY LAST_LINE_CHAR
;
 LDA #0
 STA PL_JUSTIFICATION    ;FORCE TO  "LEFT/CENTER/RIGHT
;
 LDA JUSTIFY_FORMAT
 BEQ .JJ_LEFT_ALIGN_TEXT  ;BIF LEFT ALIGN
 CMP #3                  ;ARE WE JUSTIFYING?
 BNE .FIND_START         ;IF NOT, GO FIND START
;
 LDY END_LINE_TYPE       ;IF HRET OR EOT DO NOT JUSTIFY
 CPY #SRETRN             ;JUST TREAT AS LEFT
; BNE ?B_LEFT_ALIGN_TEXT  ;JUSTIFY WILL
 BEQ .JUST 
.JJ_LEFT_ALIGN_TEXT:
 JMP .LEFT_ALIGN_TEXT
;
.JUST:
 INC PL_JUSTIFICATION    ;SET TO JUSTIFY
;
.FIND_START:
 LDY #$FF
.BEG_SPC:
 INY
 LDA (TEXT),Y
 CMP #' '
 BEQ .BEG_SPC
;
.ALLOW_SPC: 
 STY PRINT_STATUS        ;SAVE OFF INDEX
;
 LDA EXPAND_ON
 PHA
 LDA #0
 STA EXPAND_ON 
 LDA CURRENT_FONT
 PHA 
 LDA ATTRIBUTES
 PHA 
 LDA CURRENT_POINTSIZE
 PHA 
 JSR PART_LINE_LENGTH    ;LINE LENGTH FROM .Y TO LAST_LINE_CHAR
 PLA
 STA CURRENT_POINTSIZE 
 PLA
 STA ATTRIBUTES 
 PLA
 STA CURRENT_FONT 
 PLA
 STA EXPAND_ON
;
 LDY PRINT_STATUS
.FND_FIRST:
 JSR TEXCFE              ;FIND FIRST ACTUAL CHARACTER
 BEQ .B_LEFT_ALIGN_TEXT  ;NOTHING BUT CODES
;
 CMP #$80
 BCC .REG_CHAR
 INY
 BNE .FND_FIRST
;
.REG_CHAR:
 PHA			 ;SAVE ACTUAL CHARACTER
;
 LDY JUSTIFY_FORMAT
 CPY #3
 BNE .NOT_JUSTIFIED
;
 LDX PRINT_STATUS
 BEQ .NOT_JUSTIFIED
;
 LDY #' '                ;TRY FULL JUSTIFICATION
 LDA (FONT_BASE),Y 
 JSR MUL_AX_0_PT         ;Return POINTER = .A*.X
 JSR PT_INTO_AX
 JSR DOT_COLUMN_PLUS_AX
;
 CLC
 LDA LINE_LENGTH
 ADC POINTER
 STA LINE_LENGTH
 LDA LINE_LENGTH+1
 ADC POINTER+1
 STA LINE_LENGTH+1
;
.NOT_JUSTIFIED:
;
 LDA FIRST_CHARACTER_FONT
 JSR CHANGE_TO_FONT
;
 JSR KERN_WIDTH_INTO_P2
 PLA
 JSR MAKE_CHAR_CODE
 TAY
 LDA (POINTER2),Y
 JSR LL_MINUS_A
;
 LDY LAST_LINE_CHAR
.PREV_CHAR:
 DEY
.LAST_REAL:
 JSR TEXCFE                 ;FIND LAST PRINTABLE CHARACTER
 BNE .PRINTABLE_CHAR
;
.B_LEFT_ALIGN_TEXT:
 JMP .LEFT_ALIGN_TEXT       ;NO VALID CHARS
.PRINTABLE_CHAR:
 CMP #$80
 BCS .PREV_CHAR
;
.LAST_CHAR:
;
;FORCE HEADER READ IF NEEDED, USE HEADER IF NEEDED
;SET P2 AT KERN_WIDTH
 LDY LAST_CHARACTER_FONT    ;FONT FOR LAST CHARACTER IN LINE
 CPY CURRENT_FONT           ;IS IT SAME AS FULL FONT IN MEM?
 BEQ .USE_MAIN_FONT         ;IF SO, USE MAIN FONT
;
 PHA                        ;SAVE CURRENT CHARACTER
;
 CPY FONT_IN_FAKE_FONT      ;IS IT ALREADY THERE?
 BEQ .USE_FAKE_FONT
;
 LDA #<FAKE_FONT_HEADER
 LDX #>FAKE_FONT_HEADER
 JSR AX_INTO_LDFONT         ;SET TO READ ONLY FONT_HEADER
 LDA #0
 STA ALL_FONT_OR_HEADER     ;DO JUST HEADER
 LDA LAST_CHARACTER_FONT    ;LOAD FONT HEADER FOR LAST CHARACTER
 JSR LOAD_FONT
;
.USE_FAKE_FONT:
;
 LDA LAST_CHARACTER_FONT
 JSR POINT_AXPT_UPDATE_FBASE
;
 LDA #0
 STA ALL_FONT_OR_HEADER     ;DO JUST HEADER
 JSR SET_FONT_DATA
 JSR KERN_WIDTH_INTO_P2
;
 PLA                        ;RESTORE CURRENT CHARACTER
;
.USE_MAIN_FONT:
 JSR MAKE_CHAR_CODE
 STA CHAR_CODE              ;SAVE FOR BIT-IMAGE
 TAY
 INY
 LDA (POINTER2),Y
 JSR LL_MINUS_A             ;REMOVE "WIDTH"
;
 JSR BITWIDTH_CHARCODE      ;PROCESS CHAR_CODE
 JSR LL_PLUS_A
;
 LDA #1
 STA ALL_FONT_OR_HEADER     ;USE WHOLE FONT
 JSR SET_FONT_DATA
 JSR KERN_WIDTH_INTO_P2
 LDA CURRENT_FONT
 JSR POINT_AXPT_UPDATE_FBASE
;
 LDA EXPAND_ON
 BEQ .NO_DIV
 LDA MARGIN
 LDX MARGIN+1 
 JSR PUSH_AX 
 JSR LSR_AX
 JSR AX_INTO_MARGIN
;
.NO_DIV:
 SEC
 LDA MARGIN
 SBC LINE_LENGTH
 STA ITEMP
 LDA MARGIN+1
 SBC LINE_LENGTH+1
 TAX  
 LDA ITEMP                ;AX = VALUE TO LEFT ALIGN
 LDY JUSTIFY_FORMAT
 CPY #3
 BNE .CEN_TXT
;
 LDY INTER_WORD_GAPS
 JSR DIV_AX_BY_Y
 STA SPACE_R_ADJUST      ;REMAINDER TO DISTRIBUTE
 LDA INTER_WORD_GAPS     ;1/2 OF GAPS
 LSR
 STA JUST_ADJUSTMENT     ;TO ADJUSTMENT BYTE
;
 JSR PT_INTO_AX          ;TOTAL ADJUST
 STA SPACE_J_ADJUST
 STX SPACE_J_ADJUST+1
 JMP .REST_MARG
;
.CEN_TXT:
 CPY #2                  ;RIGHT ALIGN?
 BEQ .RA_TEXT
 JSR LSR_AX              ;AX/2 FOR CENTERING
;
.RA_TEXT:
;
 JSR DOT_COLUMN_PLUS_AX
;
.REST_MARG:
 LDA EXPAND_ON
 BEQ .FULL_J
 JSR POP_AX
 JSR AX_INTO_MARGIN
;
.FULL_J:
 LDY PRINT_STATUS
!byte $2C;SKIP LDY #0
;
.LEFT_ALIGN_TEXT:
;
 LDY #0
.LOOP:
;
 LDA (TEXT),Y           ;GET CHAR
 BPL .NORMAL_CHAR 
;
 CMP #TABCHAR		;IS THIS A TAB?
 BNE .CHK_STYLE		;IF NOT, TRY STYLE/FONT
 LDA JUSTIFY_FORMAT	;ARE WE LEFT JUSTIFYING?
 BNE .CON_LOOP		;IF NOT, IGNORE
;
 JSR PUSH_AXY
;
 LDA DOT_COLUMN
 LDX DOT_COLUMN+1	;.AX = DOT_COLUMN
 SEC
 SBC THIS_LINE_LM
 PHA
 TXA
 SBC THIS_LINE_LM+1
 TAX
 PLA			;.AX - LINE'S LEFT MARGIN
;
 STA TAB_LINE_LEN
 STX TAB_LINE_LEN+1	;SET TO TAB_LINE_LEN
 LDY #0
 JSR FIND_TAB_GT_TLL
 BCC .TAB_NOT_USED
 CLC
 ADC THIS_LINE_LM
 STA DOT_COLUMN
 TXA
 ADC THIS_LINE_LM+1
 STA DOT_COLUMN+1 
;
 LDA #0
 STA FIRST_CHAR_IN_LINE
;
.TAB_NOT_USED:
 JSR POP_AXY
 JMP .CON_LOOP
;
.CHK_STYLE:
 JSR IS_STYLE_CODE
 BCS .CHECK_FONT
 JSR SET_STYLE           ;DOES NOT HARM .Y
 JMP .CON_LOOP
.CHECK_FONT:
 JSR IS_FONT_CODE
 BCC .CON_LOOP
;
 JSR CHANGE_FONT        ;LOAD DIFFERENT FONT IN MEMORY?
;
.CON_LOOP:
 JMP .AT_END_LINE
;
.NORMAL_CHAR:
 STY PRINT_STATUS        ;ITEMP
;
 LDY #0
 STY ADJUST_THIS_CHAR
;
 CMP #' '                ;IS THIS A SPACE?
 BNE .NOT_SPACE
;
 JSR JUSTIFY_ADJUST  
 STA ADJUST_THIS_CHAR
 LDA #' '                ;RESTORE SPC
;
.NOT_SPACE:
;
 JSR TOASCI 
 STA ITEMP
;
 LDX ATTRIBUTES          ;TEST FOR BOLD
 BPL .BOLD_OFF
;
 LDA DOT_COLUMN          ;DO BOLD
 LDX DOT_COLUMN+1
 JSR INC_AX_BY_1
 JSR PUSH_AX
; LDA ITEMP
 LDA FIRST_CHAR_IN_LINE
 PHA
 LDA ITEMP
 JSR IMAGE_CHARACTER
 PLA
 STA FIRST_CHAR_IN_LINE
 JSR POP_AX
 STA DOT_COLUMN
 STX DOT_COLUMN+1
 LDA ITEMP
;
.BOLD_OFF:
 JSR IMAGE_CHARACTER     ;PLACE CHAR IN BAND
.END_LINE_LOOP:
 LDY PRINT_STATUS        ;ITEMP
;
.AT_END_LINE:
 INY
 CPY LAST_LINE_CHAR
; BNE ?LOOP
 BEQ .OUT
 JMP .LOOP
;
.OUT:
 JSR Y_TO_END_LINE1
;
 STA PRINT_STATUS
;
 LDA USER_DEFINED_LEAD
 STA LAST_LINE_LEADING
 RTS
;
;
IMAGE_CHARACTER:
;# SHOULD THERE BE SPECIAL STUFF FOR REPEAT OF LAST CHR?
 SEC
 SBC FONT_START+OFF_FIRSTC  ;DETERMINE THIS CHAR - FIRST CHAR DIFF
 ASL                      ;DOUBLE (TWO BYTE TABLES)
SUBSTITUTE_CHAR:
 STA CHAR_CODE              ;INDEX TO THIS CHARACTER
;
 JSR W_INTO_PT
!word LINE_BUFFER
;
;# SUPER/SUBSCRIPT ADJUST HERE
 LDX #0
 STX LINE_LEADING           ;CLEAR LAST AND SET SUPER FLAG
;
 LDA ATTRIBUTES
 AND #4                     ;IS SUPERSCRIPT ON?
 BNE .SUPER_S
;
 LDA ATTRIBUTES
 AND #2
 BEQ .NORMAL_VERT           ;SUBSCRIPTING!
;
 DEX                        ;[FF]
 STX SUBSCRIPTS_PRESENT     ;GOT AT LEAST 1 SUBSCRIPT ON LINE
;
.SUPER_S:
;
 SEC
 LDA BIGGEST_FONT           ;GET BIGGEST FONT THIS LINE
 SBC BIGGEST_DESCEND        ;
 SBC FONT_START+OFF_ASCENT  ;ADD
 CLC
; ADC FONT_LEADING
 ADC USER_DEFINED_LEAD
 STA LINE_LEADING
;
 LDA FONT_START+OFF_ASCENT
 LSR                      ;OF 1/2 ASCENT
 CMP LINE_LEADING           ;OR FONT_LEADING + FREE SPACE
 BCS .SKP0676 
 STA LINE_LEADING           ;SUPERSCRIPT DISTANCE
.SKP0676:
 TXA                        ;CONV TO SUBSCRIPT?
 BPL .NORMAL_VERT           ;COMPLIMENT ONLY IF SUBSCRIPTING
 EOR LINE_LEADING           ;$FF EOR DISTANCE
 STA LINE_LEADING           ;1'S COMP
 INC LINE_LEADING           ;2'S COMP
;
.NORMAL_VERT:
;
 SEC  
 LDA BASE_LINE
 SBC FONT_START+OFF_ASCENT
 SEC
 SBC LINE_LEADING
;
 LDX #PLINE_WIDTH           ;LENGTH OF LINE
;
 JSR MUL_AX_PT              ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
 JSR PT_INTO_AX
 JSR AX_INTO_P3             ;P3 POINTS TO "BASE" OF TOP RASTER
;
 JSR W_INTO_P1
!word FONT_START+OFF_OFFWID
;
 LDY CHAR_CODE
 INY
 LDA (POINTER1),Y
;
 STA POINTER2+1
 DEY
 LDA (POINTER1),Y           ;AX HAS BIT POSITION
 STA POINTER2               ;P2 = BIT OFFSET THIS CHAR
 AND #7
 STA INDEX                  ;LOW BYTE
 STA S_INDEX                ;FOR NEXT RASTER
;
 INY
 INY
 INY
 LDA (POINTER1),Y           ;NEXT CHAR START
 TAX
 DEY
 LDA (POINTER1),Y           ;LOW BYTE
 JSR DEC_AX_BY_P2           ;AX =CHARACTER LENGTH
 STA PIXELS                 ;KEEP ONLY LOW BYTE
;
 JSR P2_INTO_AX
 JSR LSR_AX_3               ;DIVIDE BY 8
 JSR AX_INTO_P1             ;P1 = BYTE OFFSET
;
 LDA RASTER_MAP_TABLE
 LDX RASTER_MAP_TABLE+1
 JSR INC_P1_BY_AX 
;
 LDA FONT_START+OFF_POINTS
 STA ROWS
;
 JSR KERN_WIDTH_INTO_P2
;
 LDY CHAR_CODE
 INY
 LDA (POINTER2),Y
 CMP #$FF                   ;IS THIS "SUBSTITUTION CHAR"?
 BNE .NORMAL_CH
;
 SEC
 LDA FONT_START+OFF_LASTC   ;DETERMINE THIS CHAR - FIRST CHAR DIFF
 SBC FONT_START+OFF_FIRSTC
 ASL
 JMP SUBSTITUTE_CHAR
;
.NORMAL_CH:
 STA KERN_WIDTH+1           ;WIDTH OF THIS CHAR
 DEY
 LDA (POINTER2),Y
 STA KERN_WIDTH             ;RIGHT/LEFT ADJUST BEFORE START
;
 LDA #0
 STA T82		    ;SET CHAR WID TO ZERO FOR 1ST PASS
 SEC
 LDA KERN_WIDTH+1
 SBC #2                     ;FUDGE FOR JUSTIFY
;
.OK: 
 CLC
 ADC DOT_COLUMN
 STA POINTER                ;POINTER = DOT_COLUMN+CHAR_WID+1
 LDA DOT_COLUMN+1 
 ADC #0 
 STA POINTER+1
;
 LDA POINTER+1
 CMP RIGHT_DOT_MARGIN+1
 BNE .IS_RDM_GREATER
 LDA POINTER
 CMP RIGHT_DOT_MARGIN
.IS_RDM_GREATER:
 BCC .RIGHT_MARGIN_OK
 BEQ .RIGHT_MARGIN_OK
;
 LDA T82		   ;PASS W/FUDGE VALUE?
 BNE .NO_GOOD
;
 JSR PUSH_P1
 JSR BITWIDTH_CHARCODE
 STA T82		   ;"REAL CHARACTER WIDTH"
 BNE .FORCE_VAL            ;IF ZERO (SPACE) THEN
 INC T82                   ;PROHIBIT INFINTE LOOP
.FORCE_VAL: 
 JSR POP_P1
 JMP .OK		   ;TRY W/ACTUAL VALUE (-KW1)
.NO_GOOD:
 RTS
;
.RIGHT_MARGIN_OK:
 LDA ATTRIBUTES             ;TEST FOR UNDERLINING CHARACTER
 AND #1
 BEQ .NO_UNDERLINE          ;IF LB CLEAR, SKIP
;
;DO UNDERLINING
;
 JSR PUSH_P1
 LDA DOT_COLUMN
 AND #$7
 STA LINE_BIT               ;INITILIZE LINE BIT
;
 JSR W_INTO_PT
!word LINE_BUFFER
;
 JSR DC_BY8_INTO_AX         ;AX = DOT_COLUMN / 8
 JSR INC_PT_BY_AX           ;P3 POINTS TO CORRECT BYTE
;
 LDA BIGGEST_UND_DESCEND
 LSR
 CLC
 ADC BASE_LINE
;
 TAX                        ;SAVE BASELINE LOCATION
 LDA ATTRIBUTES             ;IF SUBSCRIPT ON
 AND #2
 BEQ .NOT_SUBS
;
 SEC                        ;DROP UNDERSCORE
 TXA
 SBC LINE_LEADING
 TAX
;
.NOT_SUBS:
 TXA
;
 LDX #PLINE_WIDTH           ;LENGTH OF LINE
 JSR MUL_AX_PT              ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
;
 CLC
 LDA KERN_WIDTH
 ADC KERN_WIDTH+1
 ADC ADJUST_THIS_CHAR
 TAX
.LOOPU:
 JSR FC_SET_LINE_DOT        ;THIS IS UNDERLINING
 DEX
 BNE .LOOPU
;
 JSR POP_P1
;
.NO_UNDERLINE:
;
 LDA KERN_WIDTH
 BEQ .NO_ADJUST    
;
;BEFORE CHAR DRAW WIDTH CHANGES
;
 LDX FIRST_CHAR_IN_LINE
 BEQ .NO_ADJUST
;
.ALWAYS_ADJUST:             ;THIS IS A SPACE!
 JSR ADJUST_DOTC            ;ADD(SUB) .A FROM DOT_COLUMN
;
.NO_ADJUST:
;
 INC FIRST_CHAR_IN_LINE     ;ALSO COUNTS CHARS IN LINE
 JSR P1_INTO_P2             ;P2 = P1 (STABLE FOR MOVE-DOWN)
;
 LDA DOT_COLUMN
 AND #$7
 STA S_LINE_BIT             ;INITILIZE STABLE POSITION
;
 JSR DC_BY8_INTO_AX         ;AX = DOT_COLUMN / 8
 JSR INC_P3_BY_AX           ;P3 POINTS TO CORRECT BYTE
 JSR P1_INTO_P2             ;P2 = P1 (STABLE FOR MOVE-DOWN)
;
;BEGIN VERTICAL LOOP
;
.VLOOP:
 LDA S_LINE_BIT             ;RESET THE LINE BIT
 STA LINE_BIT
;
 JSR P3_INTO_AX
 JSR AX_INTO_PT             ;POINT PT TO NEW LINEB RASTER
;
 JSR P2_INTO_P1             ;POINT P1 TO NEW CHARACTER RASTER
;
; TRY ITALICS
;
 LDA ATTRIBUTES             ;TEST FOR ITALIC CHARACTER
 AND #$40
 BEQ .BACKSLANT             ;THIS IS NOT ITALIC CHAR
;
 LDA ROWS
 BNE .ITALICS_NORM 
;
.BACKSLANT:
 LDA ATTRIBUTES
 AND #$20
 BEQ .NO_SHIFT
;
 SEC
 LDA FONT_START+OFF_POINTS
 SBC ROWS
;
.ITALICS_NORM:
 CLC
 ADC #1
 LSR
 TAX
 BEQ .NO_SHIFT
.ILOOP:
 JSR INC_LINE_BIT
 DEX
 BNE .ILOOP
.NO_SHIFT:
;
 LDX PIXELS        ;.X COUNTS DOWN
 BEQ .NO_WIDTH
;
;HORIZONTAL LOOP
;
.LOOP0915:
 JSR GET_RASTER_DOT   ;ALSO SETS
 DEX
 BNE .LOOP0915	;SIZE?
;
 LDA S_INDEX
 STA INDEX         ;MOVE BIT POSITION OF FONT BACK
;
 LDA FONT_START+OFF_ROWWRD
 LDX FONT_START+OFF_ROWWRD+1
; JSR ASL_AX           ;*2 (WORDS)
 JSR INC_P2_BY_AX     ;POINT AT NEXT RASTER IN FONT
;
 JSR W_INTO_AX
!word PLINE_WIDTH
 JSR INC_P3_BY_AX
 DEC ROWS
 BNE .VLOOP
;
.NO_WIDTH:
; SEC
 CLC
 LDA KERN_WIDTH+1
 ADC ADJUST_THIS_CHAR
; SEC
; SBC KERN_WIDTH       ;DISTANCE TO BUMP
 JMP ADJUST_DOTC 
;
;
JUSTIFY_ADJUST:
;
 LDA PL_JUSTIFICATION    ;SET TO JUSTIFY?
 BEQ .OUT0947                ;NO.
;
;LDX SPACE_J_ADJUST
 SEC
 LDA JUST_ADJUSTMENT
 SBC SPACE_R_ADJUST
 BCC .ADD
;
 STA JUST_ADJUSTMENT     ;POSITIVE, NO ADJ HERE
 LDA SPACE_J_ADJUST
.OUT0947:
 RTS
;
.ADD:
 ADC INTER_WORD_GAPS     ;NEG, ADD GAPS
 STA JUST_ADJUSTMENT
;
 CLC
 LDA SPACE_J_ADJUST
 ADC #1
 RTS
;
GET_RASTER_DOT:
;
; POINTER1 = BYTE
; INDEX++ = BIT
;
 LDY #0
 LDA (POINTER1),Y
 LDY INDEX
 AND BIT_ON,Y
 PHP                  ;EQ = NOT SET NE = SET
 INY
 CPY #8
 BNE .NO_BUMP
;
 JSR INC_P1_BY_1      ;POINT TO NEXT BYTE
 LDY #0 
;
.NO_BUMP:
 STY INDEX 
 PLP
; RTS
;
SET_LINE_DOT:
;
 BEQ INC_LINE_BIT        ;PLOT IF NE, BUMP IF NOT
FC_SET_LINE_DOT:
 LDY #0
 LDA (POINTER),Y
 LDY LINE_BIT
 ORA BIT_ON,Y
 LDY #0
 STA (POINTER),Y
;
INC_LINE_BIT:
;
 LDY LINE_BIT
 INY
 CPY #8
 BNE .NO_BUMP1007
;
 JSR INC_PT_BY_1      ;.X UNHARMED
 LDY #0
;
.NO_BUMP1007:
 STY LINE_BIT
 RTS
;
DEC_LINE_BIT:
 LDY LINE_BIT
 DEY
;# HOW ABOUT BMI
 CPY #$FF
 BNE .NO_BUMP1021
;
 JSR DEC_PT_BY_1
 LDY #7
;
.NO_BUMP1021:
 STY LINE_BIT
 RTS
;
FILL_PT_P1_A:
;
; 	Fill POINTER bytes starting at POINTER1 with value in .A.
;
; ENTRY:
;	A	= Fill value
;	POINTER	= Byte count to fill (0-65535)
;	POINTER1= Starting address
;
; RETURN:
;	A	= Unchanged
;	X	= Used
;	POINTER	= Modified
;	POINTER1= Modified
;
	SEC			   ;FOR BRANCH AT BOTTOM
	LDX POINTER+1	;SIZE MSB
.NUM0:
	BEQ .NUM1		   ;SIZE < 256 BYTES
	LDY #0		   ;ELSE FILL ENTIRE PAGE
	BEQ .NUM2
.NUM1:
	LDY POINTER		;ODD BYTES TO FILL
	BEQ .NUM4		   ;BIF NO ODD BYTES
.NUM2:
	DEY			   ;NEXT BYTE
	STA (POINTER1),Y	;FILL A BYTE
	CPY #0		   ;DONE WITH PAGE?
; BNE ?2
;# MENTION TO NED!
 BEQ .NUM3		   ;DONE WITH THIS PAGE
 BCS .NUM2		   ;REPEAT
.NUM3:
	INC POINTER1+1	;INCREMENT BASE BY 256
	DEC POINTER+1
	BPL .NUM0
.NUM4:
	RTS
;
ADJUST_DOTC:
 CLC
 ADC DOT_COLUMN
 STA DOT_COLUMN
 BCC ADJ_EXIT
 INC DOT_COLUMN+1
ADJ_EXIT:
 RTS
;
CHANGE_FONT:
;
 SEC
 SBC #'1'+$80
 BPL CHANGE_TO_FONT
 LDA #9 
CHANGE_TO_FONT:
 CMP CURRENT_FONT     ;DID HE REQUEST FONT ALREADY IN USE?
 BEQ ADJ_EXIT         ;DIP!
;
LOAD_FONT:
;
 STY LD_FONT_SAVE_Y   ;SAVE .Y (CHARACTER INDEX)
.RE_FONT:
 STA REGLOAD          ;SAVE POSSIBLE CURRENT_FONT
 JSR POINT_AXPT_UPDATE_FBASE
;
 LDY #98              ;LOOK AT 1ST CHAR OF FILENAME
 LDA (POINTER),Y
 CMP #6               ;IS THIS A VALID FONT?
 BEQ .NEW_FONT        ;IF SO, GO GET NEW
 LDA #0
 BEQ .RE_FONT         ;FORCE DEFAULT
;
.NEW_FONT:
 LDA REGLOAD             ;REQUESTED FONT
 LDX ALL_FONT_OR_HEADER  ;DO WHOLE THING, OR JUST HEADER?
 BNE .STORE_CUR_FONT
 STA FONT_IN_FAKE_FONT   ;IS IT ALREADY THERE?
 BEQ .JOIN               ;BRA
;
.STORE_CUR_FONT: 
 STA CURRENT_FONT
.JOIN:
 JSR INC_PT_BY_Y
;
 LDX #USE_FONT_DISK
 STX REGLOAD             ;USE THS/SPL/FNT DEVICE
;
 LDA #13
 LDX POINTER
 LDY POINTER+1
 JSR SETNAM
;
 LDA #3
 JSR OPEN_FILE_A         ;OPEN 3,DEV1,3,"FONTNAME"
;
 LDX #3
 JSR CHKIN
;
 LDX $90
 BNE END_FONT_FILE
;
 LDY #0
LD_FONT_LOOP1:
 JSR CHRIN
 LDX $90
 BNE END_FONT_FILE 
;
!byte $99;STA $0000,Y
LDFONT_SM1:
;
!word FONT_BUFFER
 INY
 BNE LD_FONT_LOOP1
;
 INC LDFONT_SM1+1
 LDA LDFONT_SM1+1
 CMP #>FAKE_FONT_HEADER+$200;STOP AFTER 2 PAGES
 BNE LD_FONT_LOOP1          ;WHEN ONLY READING HEADER
;
END_FONT_FILE:
;
 LDA #3
 JSR CLOSE
 JSR CLRCHN
;
SET_FONT_DATA:
 LDA ALL_FONT_OR_HEADER     ;DO WHOLE THING, OR JUST HEADER?
 BNE .WHOLE_FONT            ;0=HEADER NZ = WHOLE FONT
;
 JSR W_INTO_PT 
!word FAKE_FONT_HEADER+OFF_OFFWID
 SEC
 LDA FAKE_FONT_HEADER+OFF_LASTC
 SBC FAKE_FONT_HEADER+OFF_FIRSTC 
 JMP .JOIN1164
;
.WHOLE_FONT:
 JSR W_INTO_PT
!word FONT_START+OFF_OFFWID
 SEC
 LDA FONT_START+OFF_LASTC
 SBC FONT_START+OFF_FIRSTC
;
.JOIN1164: 
 ADC #2
 PHA
 ASL
 CLC
 ADC POINTER
 STA KERN_WIDTH_TABLE
 LDA #0
 ADC POINTER+1
 STA KERN_WIDTH_TABLE+1     ;SET POINTER TO KERN_WIDTH
;
 PLA
 LDX #0
 JSR ASL_AX
 JSR ASL_AX
 LDY #2
 JSR DEC_AX_BY_Y            ;USES TEMP
 JSR INC_PT_BY_AX
 STA RASTER_MAP_TABLE+1
 LDA POINTER
 STA RASTER_MAP_TABLE       ;SET POINTER TO RASTER_MAP
;
!byte $A0;LDY #00
LD_FONT_SAVE_Y:
!byte 00
;
 LDA #<FONT_BUFFER
 LDX #>FONT_BUFFER
;
AX_INTO_LDFONT: 
 STA LDFONT_SM1
 STX LDFONT_SM1+1
;
 RTS
;
KERN_WIDTH_INTO_P2:
;
 LDA KERN_WIDTH_TABLE
 STA POINTER2
 LDA KERN_WIDTH_TABLE+1
 STA POINTER2+1
 RTS
;
;
FIND_BIGGEST_FONT:
 LDA ATTRIBUTES             ;SAVE OFF TEXT ATTRIBUTES
 PHA
;
 JSR TEXCF0                 ;DOES LINE START W/FONT CHANGE?
 JSR IS_FONT_CODE
 BCC .USE_CURRENT_FONT
;
 SBC #'1'+$80
 BPL .FNT10
 LDA #9 
.FNT10: 
 BPL .USE_NEW_FONT
;
;# ASCENT IS CORRECT DETERMINER OF HEIGHT, NOT POINTSIZE
;
;
.USE_CURRENT_FONT:
 LDA CURRENT_FONT
.USE_NEW_FONT:
 JSR PTS_AND_DESCEND        ;FIRST FONTS SIZE & DEPTH IS LARGEST
 STA BIGGEST_FONT
 STX BIGGEST_DESCEND
 STX CURRENT_DESCEND
 LDA ATTRIBUTES             ;TEST FOR UNDERLINING CHARACTER
 AND #1                     ;IF A LINE BEGINS UNDERLINED, ASSUME 1 CHR IS
 STA BIGGEST_UND_DESCEND    ;ASSUME ZERO
 BEQ .NOT_UNDERLINE
 STX BIGGEST_UND_DESCEND    ;SET TO LARGEST IF PRESENT
.NOT_UNDERLINE:
;
 LDY #$FF                   ;START ON 2ND CHAR
.LOOP1249:
 INY
 LDA (TEXT),Y
 BPL .LOOP1249 
 CMP #ENDT
 BCS .FOUND_END
;
 CMP #'U'+$80
 BNE .UND_OFF
;
 LDA CURRENT_DESCEND
 CMP BIGGEST_UND_DESCEND    ;BUGGEST UNDERLINED DESCENT?
 BCC .SET_UND_ON            ;NO, BRANCH
;
 STA BIGGEST_UND_DESCEND
;
.SET_UND_ON:
 LDA ATTRIBUTES
 ORA #1
 BNE .STR_LOOP
;
.UND_OFF:
 CMP #'U'-'@'+$80
 BNE .FONTS
 LDA ATTRIBUTES
 AND #$FE
.STR_LOOP:
 STA ATTRIBUTES
 JMP .LOOP1249
;
.FONTS: 
 JSR IS_FONT_CODE
 BCC .LOOP1249
;
 STY TEMP
;# FONT 10
 SBC #'1'+$80
 BPL .FNT10A
 LDA #9 
.FNT10A: 
 JSR PTS_AND_DESCEND
 STX CURRENT_DESCEND
 CMP BIGGEST_FONT
 BCC .TRY_DESC
 STA BIGGEST_FONT 
;
.TRY_DESC:
 CPX BIGGEST_DESCEND        ;IS THIS THE BIGGEST DESCENT SO FAR?
 BCC .TO_LOOP               ;NO, BRANCH
 STX BIGGEST_DESCEND        ;UPDATE LARGEST...
;
 LDA ATTRIBUTES             ;DID A FONT CHANGE WHILE UNDERLINING ON?
 AND #1 
 BEQ .TO_LOOP               ;NO, UND OFF
;
 CPX BIGGEST_UND_DESCEND    ;IS THIS THE BIGGEST SUCH FONT?
 BCC .TO_LOOP               ;BIF NO
 STX BIGGEST_UND_DESCEND    ;UPDATE
;
.TO_LOOP:
 LDY TEMP
 JMP .LOOP1249
;
.FOUND_END:
 PLA
 STA ATTRIBUTES
 RTS 
;
;
BITWIDTH_CHARCODE:
;
 LDA ALL_FONT_OR_HEADER     ;DO WHOLE THING, OR JUST HEADER?
 BNE .FULL_FONT
;
 JSR W_INTO_P1
!word FAKE_FONT_HEADER+OFF_OFFWID
 JMP .JOIN1325
;
.FULL_FONT: 
 JSR W_INTO_P1
!word FONT_START+OFF_OFFWID
;
.JOIN1325:
 LDY CHAR_CODE
 INY
 LDA (POINTER1),Y
;
 STA POINTER2+1
 DEY
 LDA (POINTER1),Y           ;AX HAS BIT POSITION
 STA POINTER2               ;P2 = BIT OFFSET THIS CHAR
 AND #7
 STA INDEX                  ;LOW BYTE
 STA S_INDEX                ;FOR NEXT RASTER
;
 INY
 INY
 INY
 LDA (POINTER1),Y           ;NEXT CHAR START
 TAX
 DEY
 LDA (POINTER1),Y           ;LOW BYTE
 JSR DEC_AX_BY_P2           ;AX =CHARACTER LENGTH, SET LB N&Z
 STA PIXELS                 ;KEEP ONLY LOW BYTE
 RTS
;
;
MAKE_CHAR_CODE:
;
 JSR TOASCI
 SEC
 SBC FONT_START+OFF_FIRSTC  ;DETERMINE THIS CHAR - FIRST CHAR DIFF
 ASL                      ;DOUBLE (TWO BYTE TABLES)
 RTS
;
;
DOT_COLUMN_PLUS_AX:
 CLC
 ADC DOT_COLUMN
 STA DOT_COLUMN
 TXA
 ADC DOT_COLUMN+1
 STA DOT_COLUMN+1
 RTS
;
;
!eof
;
; PUBLIC ADJUST_DOTC
; PUBLIC BIGGEST_FONT
; PUBLIC BIGGEST_DESCEND
; PUBLIC CHANGE_TO_FONT
; PUBLIC CLEAR_BOTTOM
; PUBLIC CLEAR_LINE
; PUBLIC FILL_PT_P1_A
; PUBLIC FIND_BIGGEST_FONT
; PUBLIC FIRST_LINE
; PUBLIC FONT_IN_FAKE_FONT
; PUBLIC IMAGE_LINE
; PUBLIC IMAGE_LINE_AGAIN
; PUBLIC KERN_WIDTH_INTO_P2
; PUBLIC LOAD_FONT
; PUBLIC SUBSCRIPTS_PRESENT
; EXTERN ASL_AX
; EXTERN AX_INTO_EOT
; EXTERN AX_INTO_MARGIN
; EXTERN AX_INTO_PT
; EXTERN AX_INTO_P1
; EXTERN AX_INTO_P2
; EXTERN AX_INTO_P3
; EXTERN BIT_ON
; EXTERN BOT_SIZE
; EXTERN CHKIN
; EXTERN CHRIN
; EXTERN CLRCHN
; EXTERN CLOSE
; EXTERN COPYDN
; EXTERN DC_BY8_INTO_AX
; EXTERN DEC_AX_BY_P2
; EXTERN DEC_AX_BY_Y
; EXTERN DEC_PT_BY_1
; EXTERN DEC_P1_BY_A
; EXTERN DELETE_FROM_LINE
; EXTERN DIV_AX_BY_Y
; EXTERN DOCHKM
; EXTERN END_LINE_TYPE
; EXTERN FAKE_FONT_HEADER
; EXTERN FIND_TAB_GT_TLL
; EXTERN FIRST_CHARACTER_FONT
; EXTERN FONT_BUFFER
; EXTERN FONT_LEADING
; EXTERN FONT_START
; EXTERN FONT_TABLE_X_INTO_PT
; EXTERN INC_AX_BY_1
; EXTERN INC_PT_BY_AX
; EXTERN INC_PT_BY_Y
; EXTERN INC_PT_BY_1
; EXTERN INC_P1_BY_AX
; EXTERN INC_P1_BY_1
; EXTERN INC_P2_BY_AX
; EXTERN INC_P3_BY_AX
; EXTERN INTER_WORD_GAPS
; EXTERN IS_FONT_CODE
; EXTERN IS_STYLE_CODE
; EXTERN IW_INTO_AX
; EXTERN JUSTIFY_FORMAT
; EXTERN L_BUFFER_DEPTH
; EXTERN LAST_CHARACTER_FONT
; EXTERN LAST_LINE_CHAR
; EXTERN LAST_PRINTABLE_CHR
; EXTERN LINE_BUFFER
; EXTERN LINE_BUFFER_E
; EXTERN LINE_SIZE
; EXTERN LKFDP1
; EXTERN LL_MINUS_A
; EXTERN LL_PLUS_A
; EXTERN LSR_AX
; EXTERN LSR_AX_3
; EXTERN MUL_AX_PT
; EXTERN MUL_AX_0_PT
; EXTERN OPEN_FILE_A
; EXTERN PART_LINE_LENGTH
; EXTERN PL_JUSTIFICATION
; EXTERN PTS_AND_DESCEND
; EXTERN P1_INTO_P2
; EXTERN P2_INTO_AX
; EXTERN P2_INTO_P1
; EXTERN P3_INTO_AX
; EXTERN PLINE_WIDTH
; EXTERN PUSH_AX
; EXTERN PUSH_AXY
; EXTERN PUSH_EOT
; EXTERN PUSH_P1
; EXTERN PUSH_P3
; EXTERN PUSH_Y
; EXTERN POP_AX
; EXTERN POP_AXY
; EXTERN POP_EOT
; EXTERN POP_P1
; EXTERN POP_P3
; EXTERN POP_Y
; EXTERN POINT_AXPT_UPDATE_FBASE
; EXTERN PT_INTO_AX
; EXTERN RIGHT_DOT_MARGIN
; EXTERN REGLOAD
; EXTERN SETLFS
; EXTERN SETNAM
; EXTERN SET_STYLE
; EXTERN TAB_LINE_LEN
; EXTERN TEXCFE
; EXTERN TEXCF0
; EXTERN TOASCI
; EXTERN USER_DEFINED_LEAD
; EXTERN W_INTO_AX
; EXTERN W_INTO_PT
; EXTERN W_INTO_P1
; EXTERN W_INTO_P2
; EXTERN W_INTO_P3
; EXTERN XDEVICEN
; EXTERN Y_TO_END_LINE1
