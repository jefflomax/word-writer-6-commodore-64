;
!zone POINTERM;POINTER MANIPULATIONS 4/29 
;
!SOURCE "WWSETUP.ASM"
!SOURCE "VARIABLS.ASM"
;
;AX_INTO_START_BLOCK (EDITLN)
; PUBLIC INC_P1_INC          ;Increment POINTER1 by PTINC
; PUBLIC INCREMENT_P1
; PUBLIC IPT_INTO_AX         ;A,.X = two bytes at (POINTER)
; PUBLIC LSR_AX_Y            ;Logical shift right .A,.X(LSB,MSB), .Y times
; PUBLIC OP1_INTO_P2
;? P2_INTO_P4
; PUBLIC STOREY
;
; EXTERN BIGGEST_POINTSIZE
; EXTERN CHARS_IN_LINE
; EXTERN CUR_PAGE_LENGTH
; EXTERN DOT_COLUMN
; EXTERN P1INC
;
;
MH_EQ_MV_A:
 STA MH_EQ_SM1
 CLC
 LDA MOVELO
MH_EQ_SM1 =  *+1
 ADC #$00
 STA MOVEHI
 LDA MOVELO+1
 ADC #0
 STA MOVEHI+1
 RTS
;
REMOVE_A_BYTES:
;
 PHA         ;SAVE DELETE LENGTH
 PHA         ;SAVE DELETE LENGTH AGAIN
 JSR MVTEMV  ;COPY TEXT POINTER TO MOVELO
 PLA         ;RETORE DELETE LENGTH
 JSR MH_EQ_MV_A ; MH = MV+.A
 JSR COPYDN
;
 PLA         ;RESTORE LAST DELETE LENGTH
 JMP DEC_EOT_BY_A
;
;
START_OF_TEXT:
;
 LDA TEXT+1     ;ARE WE ON THE FIRST LINE
 CMP STTEXT+1
 BNE .SKP
 LDA TEXT
 CMP STTEXT
.SKP:
 RTS            ;BEQ START_OF_TEXT BNE NO
;
;
HARD_RETURN:
 LDY CHARS_IN_LINE
 LDA EDIT_LINE,Y
 CMP #RETURN
 RTS
;
;
;INCREMENT_P1:
; INC P1
; BCC ?SKP
; INC P1+1
;?SKP:
; RTS
;
TEXT_TO_CURSORP:
 JSR TEXT_TO_AX
 STA CURSOR_TEXTP
 STX CURSOR_TEXTP+1      ;SAVE OFF ACTUAL TEXTP
 RTS
;
CURSORP_TO_TEXT:
 LDA CURSOR_TEXTP
 LDX CURSOR_TEXTP+1
;
AX_TO_TEXT:
AX_INTO_TEXT:
 STA TEXT
 STX TEXT+1
 RTS
;
TEXT_INTO_AX:
TEXT_TO_AX:
 LDA TEXT
 LDX TEXT+1
 RTS
;
EOT_EQ_TEXT_PLS_Y:
 TYA
EOT_EQ_TEXT_PLS_A:
 CLC
 ADC TEXT
 STA EOT
 LDA TEXT+1
 ADC #0
 STA EOT+1
 RTS
;
TEXT_MINUS_A:
 EOR #$FF       ;Reverse bits to complement
 SEC		;Adding one for 2's complement
 ADC TEXT	;Old LSB TEXT
 STA TEXT 	;New LSB
 BCS .SKP0232	;MSB ok
 DEC TEXT+1	;Decrement MSB
.SKP0232:
 RTS		   
;
; STA ?TM_SM1
; SEC
; LDA TEXT
;?TM_SM1: EQU $+1
; SBC #$FF
; STA TEXT
; BCS ?SKP
; DEC TEXT+1
;?SKP:
; RTS
;
TEXT_TO_PREV_LINE:
;.X UNHARMED
 DEC TEXT+1
 LDY #$FF
.LOOP:
 DEY
 LDA (TEXT),Y
 BPL .LOOP
 CMP #ENDT
 BCC .LOOP
 INY
 JMP ADDYTX
;
;------------------------------------------------------------------------
;
;POINTER ROUTINES
;
PT_INTO_AX:
 LDA POINTER
 LDX POINTER+1
 RTS
;
W_INTO_PT:
 JSR GETWOR
AX_INTO_PT:
 STA POINTER
 STX POINTER+1
 RTS
;
ZERO_PT:	;Set POINTER = 0
 PHA		;Save .A
 LDA #0 
 STA POINTER 	;LSB of addend
 STA POINTER+1 	;MSB of addend
 PLA		;Retrieve .A
 RTS
;
;
INC_PT_BY_1:	;POINTER = 1 + POINTER
; .X UNHARMED
 INC POINTER
 BNE .SKP0289
 INC POINTER+1
.SKP0289:
 RTS
;
;
INC_PT_BY_Y:
 TYA
INC_PT_BY_A:	;Increment POINTER1 (LSB,MSB) by .A
;
 CLC		      ;Clear carry for add
INC_PT_BY_A_C:
 ADC POINTER	   ;Old LSB
 STA POINTER	   ;New LSB
 BCC .NUM6		   ;MSB ok
 INC POINTER+1	;Increment MSB
.NUM6:
 RTS
;
INC_PT_BY_AX:	;Increment POINTER by .A,.X
 CLC		;Set for add
 ADC POINTER	;Add old LSB POINTER
 STA POINTER	;Save new LSB POINTER
 TXA		;MSB increment
 ADC POINTER+1	;Add old MSB POINTER
 STA POINTER+1	;Save new MSB POINTER
 RTS
;
INC_PT_BY_P1:	;Add POINTER+POINTER1 and return sum in POINTER
 PHA		      ;Save AC
 CLC		      ;Clear carry for add
 LDA POINTER1	;LSB augend
 ADC POINTER	   ;LSB addend
 STA POINTER	   ;New LSB sum
 LDA POINTER1+1	;MSB augend
 ADC POINTER+1	;MSB addend
 STA POINTER+1	;New MSB sum
 PLA		      ;Restore
 RTS
;
DEC_PT_BY_1: ;Decrement POINTER (LSB,MSB) by 1
 LDA #1		;MUST PRESERVE .X
DEC_PT_BY_A: ;Decrement POINTER (LSB,MSB) by .A
 EOR #$FF	   ;Reverse bits to complement
 SEC		   ;Adding one for 2's complement
 ADC POINTER	;Old LSB POINTER
 STA POINTER	;New LSB
 BCS .NUM8		;MSB ok
 DEC POINTER+1	;Decrement MSB
.NUM8:
 RTS		   
;
PT_INTO_P1:
 PHA
 LDA POINTER
 STA POINTER1
 LDA POINTER+1
 STA POINTER1+1
 PLA
 RTS
;
PT_INTO_P2:
 PHA
 LDA POINTER
 STA POINTER2
 LDA POINTER+1
 STA POINTER2+1
 PLA
 RTS
;
PT_EQ_ZERO:
 LDA POINTER
 ORA POINTER+1
 RTS
;
;POINTER 1 ROUTINES
;
;INC_P1_INC:	;Increment POINTER1 by PTINC
;	LDA P1INC		;LSB increment for POINTER1
;	LDX P1INC+1		;MSB increment for POINTER1
INC_P1_BY_AX:	;Increment POINTER1 by .A,.X
 CLC		;Set for add
 ADC POINTER1	;Add old LSB POINTER1
 STA POINTER1	;Save new LSB POINTER1
 TXA		;MSB increment
 ADC POINTER1+1	;Add old MSB POINTER1
 STA POINTER1+1	;Save new MSB POINTER1
 RTS
;
INC_P1_BY_1:	;POINTER1 = 1 + POINTER1
 INC POINTER1
 BNE .SKP0380
 INC POINTER1+1
.SKP0380:
 RTS
;
INC_P1_BY_A:	;Increment POINTER1 (LSB,MSB) by .A
;
 CLC		;Clear carry for add
 ADC POINTER1	;Old LSB
 STA POINTER1	;New LSB
 BCC .NUM60390		;MSB ok
 INC POINTER1+1	;Increment MSB
.NUM60390:
 RTS
;
P1_INTO_P2:	;SET POINTER2 = POINTER1
;
 PHA	         ;Save through routine
 LDA POINTER1   ;LSB
 STA POINTER2   ;Transfer LSB
 LDA POINTER1+1	;LSB
 STA POINTER2+1 ;Transfer LSB
 PLA		      ;Restore call .A value
 RTS
;
W_INTO_P1:
 JSR GETWOR
AX_INTO_P1:
 STA POINTER1
 STX POINTER1+1
 RTS
;
P1_INTO_AX:
 LDA POINTER1
 LDX POINTER1+1
 RTS
;
DEC_P1_BY_A: ;Decrement POINTER1 (LSB,MSB) by .A
 EOR #$FF	   ;Reverse bits to complement
 SEC		   ;Adding one for 2's complement
 ADC POINTER1;Old LSB POINTER
 STA POINTER1;New LSB
 BCS .SKP0422		;MSB ok
 DEC POINTER1+1	;Decrement MSB
.SKP0422:
 RTS		   
;
;
;POINTER 2 ROUTINES
;
W_INTO_P2:
 JSR GETWOR
AX_INTO_P2:
 STA POINTER2
 STX POINTER2+1
 RTS
;
P2_INTO_AX:
 LDA POINTER2
 LDX POINTER2+1
 RTS
;
P2_INTO_PT:              ;P2 INTO AX AND PT
 JSR P2_INTO_AX
 JMP AX_INTO_PT
;
P2_INTO_P1:	   ;SET POINTER2 = POINTER1
;
 PHA	         ;SAVE THROUGH ROUTINE
 LDA POINTER2   ;LSB
 STA POINTER1   ;TRANSFER LSB
 LDA POINTER2+1	;LSB
 STA POINTER1+1 ;TRANSFER LSB
 PLA		      ;RESTORE CALL .A VALUE
 RTS
;
INC_P2_INC:     ;INCREMENT POINTER2 BY P2INC
 LDA P2INC		;LSB INCREMENT FOR POINTER2
 LDX P2INC+1		;MSB INCREMENT FOR POINTER2
;
INC_P2_BY_AX:	;INCREMENT POINTER1 BY .A,.X
 CLC		      ;SET FOR ADD
 ADC POINTER2	;ADD OLD LSB POINTER2
 STA POINTER2	;SAVE NEW LSB POINTER2
 TXA		      ;MSB INCREMENT
 ADC POINTER2+1	;ADD OLD MSB POINTER2
 STA POINTER2+1	;SAVE NEW MSB POINTER2
 RTS
;
INC_P2_BY_1:	;POINTER2 = 1 + POINTER2
 LDA #1  
INC_P2_BY_A:	;Increment POINTER1 (LSB,MSB) by .A
;
 CLC		;Clear carry for add
 ADC POINTER2	;Old LSB
 STA POINTER2	;New LSB
 BCC .NUM60476		;MSB ok
 INC POINTER2+1	;Increment MSB
.NUM60476:
 RTS
;
DEC_P2_BY_1:	;Decrement POINTER2 by 1
 LDA #1		
DEC_P2_BY_A:	;Decrement POINTER2 by .A
;PHA		;Save ACCUMULATOR for restore
DEC_P2_AA:
 EOR #$FF	;Reverse bits to complement
 SEC		;Adding one for 2's complement
 ADC POINTER2	;Adjust LSB
 STA POINTER2	;New LSB
 BCS .NUM3		;MSB is OK
 DEC POINTER2+1	;New MSB
.NUM3:
;PLA		;Restore ACCUMULATOR
 RTS
;
;POINTER 3 ROUTINES
;
INC_P3_BY_1: ;POINTER3 + 1
 LDA #1
INC_P3_BY_A:	;POINTER3 = POINTER3+.A
 CLC		      ;Set for add
 ADC POINTER3	;LSB
 STA POINTER3	;New LSB
 BCC LABEL3	   ;No MSB adjustment for Carry clear
 INC POINTER3+1	;MSB adjustment
LABEL3:
 RTS
;
W_INTO_P3:
 JSR GETWOR
AX_INTO_P3:
 STA POINTER3
 STX POINTER3+1
 RTS
;
P3_INTO_AX:
 LDA POINTER3
 LDX POINTER3+1
 RTS
;
INC_P3_BY_AX:	;Increment POINTER1 by .A,.X
 CLC		      ;Set for add
 ADC POINTER3	;Add old LSB POINTER2
 STA POINTER3	;Save new LSB POINTER2
 TXA		      ;MSB increment
 ADC POINTER3+1	;Add old MSB POINTER2
 STA POINTER3+1	;Save new MSB POINTER2
 RTS
;
;P4 ROUTINES
;
W_INTO_P4:
 JSR GETWOR
AX_INTO_P4:
 STA POINTER4
 STX POINTER4+1
 RTS
;
P4_INTO_AX:
 LDA POINTER4
 LDX POINTER4+1
 RTS
;
;AX ROUTINES
;
INC_AX_BY_1:    ;Z	= SET IF RESULT = 0, ELSE CLEAR
;
 CLC				;INIT FOR ADDITION
 ADC #1			;INCREMENT LSB
 BCS .NUM1			;BIF CARRY TO MSB
 DEX				;ELSE ADJUST FOR INX
.NUM1:
 INX				;MSB NOW CORRECT, Z CORRECT FOR MSB
 BNE .NUM2			;BIF NON-ZERO RESULT
 CMP #0			;MSB IS ZERO, SET Z ACCORDING TO LSB
.NUM2:
 RTS
;
INC_AX_BY_Y     ;.A,.X(LSB,MSB) = .A,.X(LSB,MSB) + Y (USES TEMP)
;
 STY TEMP
INC_AX_BY_TEMP:	;.A,.X(LSB,MSB) = .A,.X(LSB,MSB) + TEMP
 CLC
 ADC TEMP	;Increment
 BCC .NUM15		;Finished
 INX		;Increment MSB
.NUM15:
 RTS	
;
DEC_AX_BY_Y:	   ;.A,.X(LSB,MSB) = .A,.X(LSB,MSB) - .Y (USES TEMP)
 STY TEMP	;Hold decrement
DEC_AX_BY_TEMP:	;.A,.X(LSB,MSB) = .A,.X(LSB,MSB) - TEMP
 SEC
 SBC TEMP	;Decrement
 BCS .NUM14		;Finished
 DEX		;Decrement MSB
.NUM14:
 RTS	
;
DEC_AX_BY_1:
 CMP #0
 BNE .SKP0582       ;THIS CMP WILL ALWAYS SEC
 DEX            ;DEX (HB) DOES NOT HARM CARRY
.SKP0582:
 SBC #1         ;CS, SUBTRACT 1 FROM LB
 RTS
;
W_INTO_AX:
 JSR GETWOR	;THIS IS *NOT* SUPERFLOUS, NEEDED TO CALL FUNC & RET
 RTS
;
INC_AX_BY_P2:	;.A,.X (LSB,MSB) = .A,.X (LSB,MSB) + POINTER2
 CLC
 ADC POINTER2	;LSB increment
 PHA		      ;SAVE
 TXA		      ;MSB
 ADC POINTER2+1	;MSB increment
 TAX		      ;New MSB
 PLA		      ;Restore LSB
 RTS
;
DEC_AX_BY_PT:	;A,.X = A,.X - POINTER
;
 SEC		;Prepare for subtract
 SBC POINTER	;LSB adjust
 PHA		;Save new LSB
 TXA		;Old MSB
 SBC POINTER+1	;MSB adjust
 TAX		;New MSB
 PLA		;Restore LSB
 RTS
;
DEC_AX_BY_P2:	;A,.X = A,.X - POINTER2
;
 SEC		;Prepare for subtract
 SBC POINTER2	;LSB adjust
 PHA		;Save new LSB
 TXA		;Old MSB
 SBC POINTER2+1	;MSB adjust
 TAX		;New MSB
 PLA		;Restore LSB AND SET FLAGS N&Z
 RTS
;
ASL_AX_Y:	;Arithmetic shift left .A,.X(LSB,MSB), .Y times
 CPY #0		;Finished?
 BEQ .NUM0
.C:
 JSR ASL_AX	;Logical shift left .A,.X(LSB,MSB)
 DEY
 BNE .C		;Logical shift left .A,.X(LSB,MSB), .Y times
.NUM0:
 RTS
;
ASL_AX:		;Logical shift left .A,.X(LSB,MSB)
;
 CLC		;Clear carry to give ASL
ROL_AX:		;Rotate left A,.X(LSB,MSB) shifting original carry in
;
 ROL		;Multiply LSB by 2 & add carry
 PHA		;Save LSB
 TXA		;MSB into .A
 ROL		;Multiply MSB by 2 & add carry
 TAX		;Restore processed .X
 PLA		;Restore LSB
 RTS
;
DC_BY8_INTO_AX:
 LDA DOT_COLUMN
 LDX DOT_COLUMN+1
;
LSR_AX_3:
 STA SAVEYG
 TXA
 LSR
 ROR SAVEYG
 LSR
 ROR SAVEYG
 LSR
 ROR SAVEYG
 TAX
 LDA SAVEYG
 RTS
;
;LSR_AX_Y:	   ;Logical shift right .A,.X(LSB,MSB), .Y times
;	CPY #0		;Finished?
;	BEQ ?0
;?C:
; JSR LSR_AX	;Logical shift right .A,.X(LSB,MSB)
;	DEY
;	BNE ?C
;?0:
; RTS
;
LSR_AX:	;Logical shift right .A,.X(LSB,MSB)
;
 PHA		;Save LSB
 TXA		;MSB into .A
 LSR		;Divide MSB by 2 shifting in ZERO as top bit
 TAX		;Restore processed .X
 PLA		;Restore LSB
 ROR		;Divide LSB by 2 shifting in carry from MSB
 RTS		;carry = old bit 0 of input .A
;
AX_INTO_MARGIN:
 STA MARGIN
 STX MARGIN+1
 RTS
;
AX_INTO_LEFPRT:
 STA LEFPRT
 STX LEFPRT+1
 RTS 
;
AX_INTO_PAGE_LENGTH:
 STA PAGE_LENGTH
 STX PAGE_LENGTH+1
 RTS
;
AX_INTO_PG_LENGTH:
 STA PG_LENGTH
 STX PG_LENGTH+1   ;IN PRINT DROP
 RTS
;
ZERO_INTO_CUR_PAGE_LENGTH:
 LDA #0
 TAX
;(FT)
AX_INTO_CUR_PAGE_LENGTH:
 STA CUR_PAGE_LENGTH
 STX CUR_PAGE_LENGTH+1
 RTS
;
AX_INTO_TOP_MARGIN:
 STA TOP_MARGIN
 STX TOP_MARGIN+1
 RTS
;
AX_INTO_BOTTOM_MARGIN:
 STA BOTTOM_MARGIN
 STX BOTTOM_MARGIN+1
 RTS
;
W_INTO_MSGOUT:
 JSR GETWOR
;
AX_INTO_MSGOUT:
 STA MSGOUT
 STX MSGOUT+1
 RTS
;
EOT_INTO_AX:
 LDA EOT
 LDX EOT+1
 RTS 
;
AX_INTO_EOT: 
 STA EOT 
 STX EOT+1 
 RTS 
;
;
; BLOCK ROUTINES
;
EB_MIN_SB_INTO_P2:
 SEC
 LDA END_BLOCK
 SBC START_BLOCK
 STA POINTER2
 LDA END_BLOCK+1
 SBC START_BLOCK+1
 STA POINTER2+1
 RTS
;
;
; A ROUTINES
;
;BP + LEADING + LEADING
;IF OK, - LEADING
;
;
BP_PLS_CUR_PAGE_LENGTH:
 LDA BIGGEST_POINTSIZE
 BIT EXPAND_ON
 BPL .NOEXP 
 ASL 
.NOEXP: 
 CLC
 ADC FONT_LEADING
 ADC FONT_LEADING
;
A_PLS_CUR_PAGE_LENGTH:
;*NOTE* IF X CAN BE HARMED, SAVE RE-LOAD OF A
;*NEW*
 CLC
 ADC CUR_PAGE_LENGTH
 STA CUR_PAGE_LENGTH
 BCC .SKP0777
 INC CUR_PAGE_LENGTH+1
;
.SKP0777:
;
; LDA CUR_PAGE_LENGTH+1
; CMP PAGE_LENGTH+1
 LDX CUR_PAGE_LENGTH+1
 CPX PAGE_LENGTH+1
 BNE .SKP1
; LDA CUR_PAGE_LENGTH
 CMP PAGE_LENGTH
 BEQ .ON_PAGE
.SKP1:
 BCC .ON_PAGE
;
 RTS                    ;CS RETURN NOT ON PAGE!
;
.ON_PAGE:
;
 LDA CURRENT_FONT               ;IN TEXT MODE LEAVE.
 BMI SCC_RTS                    ;FONT MODE OK
 LDA FONT_LEADING
 JMP A_MIN_CUR_PAGE_LENGTH
;
;
BP_MIN_CUR_PAGE_LENGTH:
 LDA BIGGEST_POINTSIZE
 BIT EXPAND_ON
 BPL A_AND_LEAD_MIN_CUR_PAGE
 ASL
;
A_AND_LEAD_MIN_CUR_PAGE:
 CLC
 ADC FONT_LEADING
;
A_MIN_CUR_PAGE_LENGTH:
;
 EOR #$FF	        ;REVERSE BITS TO COMPLEMENT
 SEC		        ;ADDING ONE FOR 2'S COMPLEMENT
 ADC CUR_PAGE_LENGTH	;OLD LSB CUR_PAGE_LENGTH
 STA CUR_PAGE_LENGTH	;NEW LSB
 BCS SCC_RTS 	        ;MSB OK
 DEC CUR_PAGE_LENGTH+1	;DECREMENT MSB
SCC_RTS:
 CLC
 RTS		   
;
BP_AND_LEAD_INTO_A:
 LDA BIGGEST_POINTSIZE
 BIT EXPAND_ON
 BPL .NOEXP0828 
 ASL 
.NOEXP0828:
 CLC
 ADC FONT_LEADING
 RTS
;
BP_AND_2LEAD_INTO_A: 
; LDA BIGGEST_POINTSIZE
; BIT EXPAND_ON
; BPL ?NOEXP
; ASL A
;?NOEXP:
; CLC
; ADC FONT_LEADING
; ADC FONT_LEADING
; RTS
 JSR BP_AND_LEAD_INTO_A
 ADC FONT_LEADING
 RTS
;*NEW*
;
;-------------------------------------------------------------
;
;
IW_INTO_AX:	;.A,.X = two bytes at (.WORD)
	JSR GETWOR		;Get value from .WORD
IP4_INTO_AX:	;A,.X = two bytes at (P4)
	LDY #0
IPTY_INTO_AX:	;A,.X = two bytes at (P4),Y
 STA P4
 STX P4+1
	INY			;Offset to MSB (2nd byte)
	LDA (P4),Y		;2nd byte
	TAX			;Save 2nd byte
	DEY
	LDA (P4),Y		;1st byte
 LDY SAVEYG
	RTS
;
;
MUL_AX_0_PT: ;Return POINTER = .A*.X
;
 JSR ZERO_PT	;Set POINTER = 0
;
MUL_AX_PT: ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
;
 STX POINTER1	;LSB multiplier field
 STA STOREY 	;Save multiplicand
 LDX #0
 STX POINTER1+1 ;Clear MSB multiplier field
 BEQ MULLOOP	;Forced jump
;
;
MUL_ADEM:
;
 PHA		;Save AC
 CLC		;Clear carry for add
 LDA POINTER1	;LSB augend
 ADC POINTER	;LSB addend
 STA POINTER	;New LSB sum
 LDA POINTER1+1	;MSB augend
 ADC POINTER+1	;MSB addend
 STA POINTER+1	;New MSB sum
 PLA		;Restore
;
MULLEFT:
 ASL POINTER1 	;Left shift LSB multiplier field
 ROL POINTER1+1 	;Left shift MSB multiplier field
MULLOOP:
 LSR STOREY	;Get next multiplicand bit
 BCS MUL_ADEM	;Bit set=add multiplier to product & shift
 BNE MULLEFT	;Shift & test for more bits if not finished
 RTS
;
MUL_AX_BY_Y:	      ;.A,.X (LSB,MSB) = .A,.X (LSB,MSB)* .Y
 STY STOREY	      ;MULTIPLIER
MUL_AX_BY_S:	      ;.A,.X (LSB,MSB) = .A,.X (LSB,MSB)* STOREY
 JSR AX_INTO_P1	      ;MULTIPLICAND
 JSR MULP1_BY_STOREY  ;POINTER = POINTER1*STOREY
 JMP PT_INTO_AX	      ;.A,.X (LSB,MSB) = result
;
MULP1_BY_STOREY:      ;POINTER = POINTER1*STOREY
 JSR ZERO_PT	      ;POINTER = 0
 JMP MULLOOP	      ;POINTER = POINTER1*STOREY+POINTER
;
DIV_AX_BY_Y:	;DIVIDE .A,.X BY .Y, QUOTIENT POINTER, REMAINDER IN .A
 JSR AX_INTO_PT	;Move .A,.X (LSB, MSB) into POINTER
DIV_PT_BY_Y:    ;Divide POINTER by .Y & get POINTER= quotient, .A=remainder
 STY STOREY	;Divisor
DIV_PT_BY_S:    ;Divide POINTER/STOREY & get POINTER=quotient, .A=remainder
;
 LDX #16	;Bits in dividend/quotient
 LDA #0		;Clear remainder
DIVLOOP:
 ASL POINTER	;Left shift LSB dividend/quotient
 ROL POINTER+1	;Continue left shift MSB dividend/quotient
 ROL		;Shift bit into remainder
 BCS DIVLOOP1	;Definite overflow
 CMP STOREY	;Is remainder as big as the divisor?
 BCC DIVLOOP2	;No
DIVLOOP1:
 SBC STOREY	;Subtract divisor from remainder (carry was already set)
 INC POINTER	;Replace cleared quotient bit with set
DIVLOOP2:
 DEX		;More bits to shift?
 BNE DIVLOOP	;Yes
 RTS
;
;GENERALIZED DEC .X
DEC_ZPPT_X:
 LDA $00,X
 BNE DEC_ZPPT_1
 DEC $01,X
DEC_ZPPT_1:
 DEC $00,X
 RTS
;
;GENERALIZED INC .X
INC_ZPPT_X:
 INC $00,X
 BNE INC_ZPPT_1
 INC $01,X
INC_ZPPT_1:
 RTS
;
DEC_SCREEN_28:
 LDA #$D7       ;28 XOR FF
 SEC	        ;Adding one for 2's complement
 ADC SCREEN	;Old LSB SCREEN
 STA SCREEN 	;New LSB
 BCS .SKP0959	;MSB ok
 DEC SCREEN+1	;Decrement MSB
.SKP0959:
 RTS		   
;
DEC_EOT_BY_A:;Decrement EOT (LSB,MSB) by .A
 EOR #$FF       ;Reverse bits to complement
 SEC		;Adding one for 2's complement
 ADC EOT        ;Old LSB POINTER
 STA EOT  	;New LSB
 BCS .SKP0969	;MSB ok
 DEC EOT+1  	;Decrement MSB
.SKP0969:
 RTS		   
;
BIT_ON:
!byte $80,$40,$20,$10,$08,$04,$02,$01
;
;
!eof
;
; PUBLIC A_AND_LEAD_MIN_CUR_PAGE
; PUBLIC A_MIN_CUR_PAGE_LENGTH
; PUBLIC A_PLS_CUR_PAGE_LENGTH
; PUBLIC ASL_AX
; PUBLIC ASL_AX_Y
; PUBLIC AX_INTO_BOTTOM_MARGIN
; PUBLIC AX_INTO_CUR_PAGE_LENGTH
; PUBLIC AX_INTO_EOT
; PUBLIC AX_INTO_LEFPRT
; PUBLIC AX_INTO_MARGIN
; PUBLIC AX_INTO_MSGOUT
; PUBLIC AX_INTO_PAGE_LENGTH
; PUBLIC AX_INTO_PG_LENGTH
; PUBLIC AX_INTO_PT
; PUBLIC AX_INTO_P1
; PUBLIC AX_INTO_P2
; PUBLIC AX_INTO_P3
; PUBLIC AX_INTO_P4
; PUBLIC AX_INTO_TEXT
; PUBLIC AX_TO_TEXT
; PUBLIC AX_INTO_TOP_MARGIN
; PUBLIC BIT_ON
; PUBLIC BP_AND_LEAD_INTO_A
; PUBLIC BP_AND_2LEAD_INTO_A
; PUBLIC BP_MIN_CUR_PAGE_LENGTH
; PUBLIC BP_PLS_CUR_PAGE_LENGTH
; PUBLIC CURSORP_TO_TEXT
; PUBLIC DC_BY8_INTO_AX
; PUBLIC DEC_AX_BY_PT
; PUBLIC DEC_AX_BY_P2
; PUBLIC DEC_AX_BY_1
; PUBLIC DEC_AX_BY_Y
; PUBLIC DEC_EOT_BY_A
; PUBLIC DEC_PT_BY_A
; PUBLIC DEC_PT_BY_1
; PUBLIC DEC_P1_BY_A
; PUBLIC DEC_P2_BY_A
; PUBLIC DEC_P2_BY_1
; PUBLIC DEC_SCREEN_28
; PUBLIC DEC_ZPPT_X
; PUBLIC DIV_AX_BY_Y
; PUBLIC DIV_PT_BY_S
; PUBLIC DIV_PT_BY_Y
; PUBLIC EB_MIN_SB_INTO_P2
; PUBLIC EOT_INTO_AX
; PUBLIC EOT_EQ_TEXT_PLS_Y
; PUBLIC EOT_EQ_TEXT_PLS_A
; PUBLIC HARD_RETURN
; PUBLIC INC_AX_BY_1
; PUBLIC INC_AX_BY_P2
; PUBLIC INC_AX_BY_TEMP
; PUBLIC INC_AX_BY_Y
; PUBLIC INC_PT_BY_A
; PUBLIC INC_PT_BY_AX
; PUBLIC INC_PT_BY_Y
; PUBLIC INC_PT_BY_P1
; PUBLIC INC_PT_BY_1
; PUBLIC INC_P1_BY_AX
; PUBLIC INC_P1_BY_A
; PUBLIC INC_P1_BY_1
; PUBLIC INC_P2_BY_AX
; PUBLIC INC_P2_BY_A
; PUBLIC INC_P2_BY_1
; PUBLIC INC_P2_INC
; PUBLIC INC_P3_BY_A
; PUBLIC INC_P3_BY_AX
; PUBLIC INC_P3_BY_1
; PUBLIC INC_ZPPT_X
; PUBLIC IPTY_INTO_AX
; PUBLIC IW_INTO_AX
; PUBLIC LSR_AX
; PUBLIC LSR_AX_3
; PUBLIC MH_EQ_MV_A
; PUBLIC MUL_AX_BY_Y
; PUBLIC MUL_AX_PT
; PUBLIC MUL_AX_0_PT
; PUBLIC P1_INTO_AX
; PUBLIC P1_INTO_P2
; PUBLIC P2_INTO_AX
; PUBLIC P2_INTO_PT
; PUBLIC P2_INTO_P1
; PUBLIC P3_INTO_AX
; PUBLIC P4_INTO_AX
; PUBLIC PT_EQ_ZERO
; PUBLIC PT_INTO_AX
; PUBLIC PT_INTO_P1
; PUBLIC PT_INTO_P2
; PUBLIC REMOVE_A_BYTES
; PUBLIC START_OF_TEXT
; PUBLIC TEXT_MINUS_A
; PUBLIC TEXT_TO_AX
; PUBLIC TEXT_INTO_AX
; PUBLIC TEXT_TO_CURSORP
; PUBLIC TEXT_TO_PREV_LINE
; PUBLIC W_INTO_AX
; PUBLIC W_INTO_MSGOUT
; PUBLIC W_INTO_PT
; PUBLIC W_INTO_P1
; PUBLIC W_INTO_P2
; PUBLIC W_INTO_P3
; PUBLIC W_INTO_P4
; PUBLIC ZERO_INTO_CUR_PAGE_LENGTH
; PUBLIC ZERO_PT
; EXTERN ADDYTX
; EXTERN AXP1
; EXTERN BOTTOM_MARGIN
; EXTERN COPYDN
; EXTERN CURSOR_TEXTP
; EXTERN EDIT_LINE
; EXTERN END_BLOCK
; EXTERN FONT_LEADING
; EXTERN GETWOR
; EXTERN HEADAT
; EXTERN LEFPRT
; EXTERN MVTEMV
; EXTERN PAGE_LENGTH
; EXTERN P2INC
; EXTERN PG_LENGTH
; EXTERN START_BLOCK
; EXTERN TOP_MARGIN
