;
!zone THS
;
!zone THS;THESAURUS REX 
;
;BE SURE CLSNUM IS ZERO
;CALL ROUTINE WITH APPROPRIATE POINTER TO WORD
;IF (CS) THEN THE WORD WAS NOT FOUND
;IF (CC) THEN
;   PROGRAM WILL RETURN WITH WORD IN WORD BUFFER .X = CLUSTER NUMBER
;
;MAKE REPEATED CALLS UNTIL (CS) INDICATING LAST WORD XMITTED.
;WATCH .X CAREFULLY FOR CLUSTER NUMBER CHANGES
;  DURING CALLS, NEVER HARM:
;      MAXWOR   LINDEX   DEVICE   NUMLET
;      TEMPOR+1 LEN
;
;NEEDS:
;* CHECK ERROR FLAG (CS) AFTER ALL INBITS/INLETT
;* CHECK IF DISKETTE IS T-DISK, AFTER OPENS
;* COMPRESS WORD LENGTH S/B 1 LESS
;
;
; THESAURUS EQUATES/VARIABLES
;
CSIZE =  12 ;NUMBER OF BITS IN A CLUSTER NUMBER
WPLEN =  17 ;NUMBER OF BITS IN A POINTER TO CLUSTER
BC =  17 ;LARGEST POSSIBLE CLUSTER SIZE
;
;VARIABLES
;
WORD =  $30 ;POINTER TO WORD TO LOOK UP
P1 =  $32
P2 =  $34
P3 =  $36
P4 =  $38
T1 =  $3A ;TEMPOROARY USED FNDLT1,INBITS,
NUMLET =  $3B ;LENGTH OF WORD, NUMBER OF CLUSTERS
DEVICE =  $3C ;DEVICE NUMBER TO USE FOR THSDATA
LEN =  $3D ;
SO =  $3E ;{ SECTOR OFFSET
PO =  $40 ;} POSITION IN SECTOR
TRACK =  $41 ;ACTUAL TRACK OF DRIVE
SECTOR =  $42 ;ACTUAL SECTOR OF DRIVE
MAXWOR =  $43 ;NUMBER OF WORDS/CLUSTER THIS REGION
MP1 =  $44 ;THREE BYTE VALUE FOR MATH #1 (2 SIG)
;
MP2 =  $47 ;ONE BYTE POINTER FOR MATH #2
;
;FREE  EQU $48 ;
LINDEX =  $49 ;POINTS TO NEXT LETTER'S SO,PO IN LETTER
;
TEMPOR =  $4A ;THREE BYTE TEMPORARY FOR MATH
BIIIT =  $4D ;BIT OFFSET IN SECTOR
T2 =  $4F ;TEMPORARY USED INBITS,
RESULT =  $51 ;MORE THREE BYTE MATH STUFF
WSO =  $54 ;{ SO OF CURRENT WORD POINTING TO
WPO =  $56 ;} PO OF CURRENT WORD POINTING TO
T3 =  $57 ;TEMPORARY USED SENDASC,
T4 =  $58 ;TEMPORARY USED SENDASC,
T5 =  $59 ;TEMPORARY USED SENDASC,
;
;SYSTEM EQUATES/VARIABLES
;
CHKIN =  $FFC6
CHKOUT =  $FFC9
GETIN =  $FFE4
CHROUT =  $FFD2
CLALL =  $FFE7
CLOSE =  $FFC3
CLRCHN =  $FFCC 
OPEN =  $FFC0
PRIMM =  $FF7D
SETLFS =  $FFBA
SETNAM =  $FFBD 
STATUS =  $90
;
VIDEO =  $400  
VIDEO1 =  VIDEO+40  
VIDEO2 =  VIDEO1+40   
VIDEO3 =  VIDEO2+40
VIDEO4 =  VIDEO3+40     
VIDEO5 =  VIDEO4+40
VIDEO6 =  VIDEO5+40
VIDEO7 =  VIDEO6+40
;
 CODE
!initmem $FF
 * = $2000
;
XWORD:
!text "FAMOUS",0
EWORD:
;
!fill $2100-$    , $FF
;
;EXAMPLE CALL MODULE
;
 LDX #0
 STX $1300
GETWW: 
 JSR GETIN
 BEQ GETWW
 LDX $1300
 STA XWORD,X
 CMP #$5F
 BEQ FFF   
 JSR CHROUT
 INC $1300
 JMP GETWW
FFF:
 LDA #0
 STA XWORD,X
;
 LDA #0
 STA CLSNUM ;START OFF ON 1ST CLUSTER
;
NWD:
 JSR START
 BCS DONE  
 STX VIDEO1-1
 LDA TRACK
 STA VIDEO1
 LDA SECTOR
 STA VIDEO1+1
 LDX #9
FDYY:
 JSR DELAY
 DEX
 BPL FDYY
;
;DEBUG
 LDA #'-' 
 LDY #$10  
FDXX:
 STA $400,Y
 DEY
 BPL FDXX
 LDA #0
 STA WNDX ;CLEAR POINTER
;
 JMP NWD
DONE:
 JSR CLEARF
 RTS ;RETURN TO BASIC
;
;
START:
 LDA #00
 STA $FF00
;
 LDA #14    
 JSR CHROUT
 LDA #0   
 STA WORD
 JSR FLUSH ;CLEAR BITBIN
 LDA #$07
 STA $D506 ;PUT FILENAMES IN COMMON RAM
 LDA #$04
 STA WORD+1   
;
; GO OFF TO PRESENT WORD IF ALREADY IN LOOKUP MODE
 LDA CLSNUM
 BEQ LOOKUP ;LOOK UP THE WORD OR
 JMP PRESENT ;PRESENT WORDS
;
LOOKUP: 
 LDY #0
DRAWTW:
 LDA XWORD,Y
 STA (WORD),Y      
 BEQ DRAWT1  
 INY
 BNE DRAWTW
DRAWT1:      
 STY LEN   
;
;
 JSR WSTARTT ;SET START OF TRACK FOR WORD FILE
;
 LDA #$8
 STA DEVICE ;SET DEVICE NUMBER BEFORE CALLING
;
 LDY LEN
SMALLIT:
 LDA (WORD),Y ;PUT DOWN IN CASE
 AND #191     ;DOWN SHE GOES
 STA (WORD),Y ;AND STORE IT
 DEY 
 BPL SMALLIT
;
 JSR CLALL    
 LDA #$F              
 LDX DEVICE
 TAY
 JSR SETLFS
 LDA #2
 LDX #<IODRIVE
 LDY #>IODRIVE
 JSR SETNAM
 JSR OPEN ; OPEN 15,8,15,"I0"
;
 LDA #2
 LDX DEVICE
 TAY
 JSR SETLFS
 LDA #1
 LDX #<CHANNEL
 LDY #>CHANNEL
 JSR SETNAM
 JSR OPEN ;OPEN 2,8,2,"#"
;
 LDY #0
 LDA (WORD),Y ;RETRIEVE FIRST CHARACTER 1..26 (ASSUME "PERFECT" WORD)
 SEC
 SBC #1 ;IF 1..26 -> 0..25
 STA T1  
 ASL ;.A * 2
 ADC T1
;
 TAX ;X CONTAINS INDEX TO LETTER TABLE (SO,PO)
;
;LOOK UP EITHER BY 1ST LETTER IF ?..?N OR FROM ?O..?Z
;
 INY ;[1]
 LDA (WORD),Y
 BNE SECNDOK
 JMP WNF ;IF SECOND LETTER IS END, WE QUIT!
SECNDOK:
 CMP #'O'-64 
 BCC USEFRS ;USE FIRST LETTER, ?A..?N
;THIS IS ?O..?Z WE WILL USE LETTEO TABLE
 LDA LETTEO,X 
 STA SO
 INX 
;
 LDA LETTEO,X
 STA SO+1
 INX 
;
 LDA LETTEO,X ;LOCATE SO, PO AT START OF LETTER
 STA PO
 JMP USEDSEC
;
USEFRS:
;USE ?A..?N TO FIND WORD (LETTER)
 LDA LETTER,X 
 STA SO
 INX 
;
 LDA LETTER,X
 STA SO+1
 INX 
;
 LDA LETTER,X ;LOCATE SO, PO AT START OF LETTER
 STA PO
;
USEDSEC:
 INX
 STX LINDEX
;
 JSR READSEC ;USE U1 TO READ SECTOR
 JSR POSITON ;SET BUFFER POINTER FOR WORD
;
SEARCHW:
 LDA SO
 STA WSO 
 LDA SO+1
 STA WSO+1
 LDA PO
 STA WPO ;HOLD POSITION OF CURRENT WORD
;
 LDX LINDEX ;GET LETTER INDEX
 LDA SO   
 CMP LETTER,X 
 BNE SEARCH1 ;OK, DO SEARCH
 LDA SO+1
 CMP LETTER+1,X 
 BNE SEARCH1 ;SO'S DIFFERENT, DO SEARCH
 LDA PO ;CHECK PO
 CMP LETTER+2,X ;DIFFERENT?
 BNE SEARCH1 ;YES, GO DO SEARCH!
;
;DEBUG
 LDA #$C1   
 JMP TEXIT
;
;BEQ WNF ;NO! THE WORD IS NOT FOUND
;
;DEBUG
SEARCH1:
 LDX #$7
 LDA #' '   
XX:  
 STA VIDEO1+5,X 
 DEX
 BPL XX
;
 LDA #4 ;SIZE OF [WORDLEN]
 JSR INBITS ;READ 4 BITS FROM INPUT CHANNEL
 TAX
; .X = NUMBER OF CHARACTERS -1 IN WORD
; 0 = 1 CHAR, WITH 1ST LETTER OMITTED, TOTALS 2.
; INX ;0=1 TO READ
; S/B COMPRESSED FOR 1 LESS ON LENGTH
;
 STX NUMLET ;NUMBER OF LETTERS
 LDY #1 ;SET UP TO 2ND CHAR AND THRU WORD
;
NXTCHR:
;DEBUG
!byte 234,234,234
; JSR DELAY
;
 JSR INLETT ;READ 2ND LETTER
;
 STA VIDEO1+5,Y
;
; HANDLE DOUBLETS/SPACE/QU
;
 BNE NXTCHR1 ;IF THIS IS ZERO, SUBSTITUTE
 LDA #' ' ;A SPACE AND CHECK
 CMP (WORD),Y
 BEQ SAMECR
 BNE WLESS
;
NXTCHR1: 
 CMP #'Q'-64 ;IS THE Q (QU)?
 BNE NXTCHR2
;
 LDA #5 ;QU FLAG
 BNE NXTCHR3 ;TREAT AS DOUBLET
;
NXTCHR2:
 CMP #27 ;IS THIS 1..26
 BCC NXTCHR4 ;TREAT AS NORMAL LETTER
 SBC #27 ;MAKE # 0..4 FOR DOUBLETS
NXTCHR3: 
 JMP TLETVER ;VERIFY APPROPRIATE TWO LETTER
;
NXTCHR4:
;DEBUG
 STA $1FFE
 PHA
 LDA (WORD),Y
 STA $1FFF
 PLA
;
 CMP (WORD),Y
 BEQ SAMECR
 BCC WLESS ;TARGET WORD < DISK DATA
;TARGET WORD > DISK DATA
;
; WORD NOT FOUND
;
WNF: 
 INC $D020
 LDA #2
 JMP TEXIT
;SHOULD BE JSR CLOSEAL
 SEC ;EXIT WITH CARRY SET.
 RTS
;
SAMECR:
 DEC NUMLET
 LDA NUMLET
 BEQ DSKOUT ;THE DISK IS OUT OF CHARACTERS
 INY        ;MOVE TO NEXT MEMORY CHAR
 LDA (WORD),Y
 BEQ MEMOUT ;THE MEMORY IS OUT OF CHARACTERS
 BNE NXTCHR ;GO TRY THE NEXT CHARACTER
; RE-ORDER BRANCH
MEMOUT:
; THE MEMORY IS OUT OF CHARACTERS, THE DISK IS NOT.
; THIS MEANS THE WORDS DO NOT MATCH HERE.  WE CAN ASK
; THE USER IF THIS WORD IS OK, OR WE CAN TRY SOME SUFFIX
; ANALYSIS/DELETION.
;
 LDA #3
 JMP TEXIT 
 JMP WNF ;FOR NOW, WORD NOT FOUND
;
DSKOUT:
; THE DISK DRIVE HAS RUN OUT OF CHARACTERS IN THIS WORD.
; IS THE MEMORY ALSO OUT?
 INY
 LDA (WORD),Y
 BNE MEMCHR ;NO THE MEMORY STILL HAS CHARACTERS.
;
; THE DISK AND THE MEMORY ARE BOTH OUT OF CHARACTERS
; WE HAVE A WINNER!!!
;
 JMP EVALCL ;WORD IS FOUND!!!
;
MEMCHR:
; THE DRIVE IS OUT OF WORD AND THE MEMORY IS NOT
; GO TO NEXT WORD.
 JMP NXTWORD                
;
WLESS:
; THE TARGET WORD IS GREATER THAN THE DISK WORD
; GO TO THE NEXT WORD.
 JMP NXTWORD
;
NXTWORD:
;
NXTWORD1:
;MAY EMPLOY FAST NEXT WORD ROUTINE TO ALLOW FOR BYTE
;READ (AFTER CURRENT BIT-BUFFER IS DEPLETED)
;FOR NOW, SIMPLE INBITS.
;
 DEC NUMLET 
 LDA NUMLET
 BMI NXTW2 ;JUST BE SAFE, DO NOT PULL MILLIONS
 BEQ NXTW2 ;THERE ARE NO MORE DISK LETTERS
;DEBUG
 LDA #0   
 STA DEB1 ;VARIABLE FOR DEBUG ONLY
 BEQ NXTW1
DEB1
!byte 0
NXTW1:  
;
 JSR INLETT ;READ A LETTER
;
;DEBUG
 LDX DEB1 ;MORE DEBUG
 INC DEB1
 STA VIDEO5+7,X
;
 DEC NUMLET         
 BNE NXTW1    
;
NXTW2:
 LDA #4
 JSR INBITS
 STA VIDEO5
;
 STA NUMLET ;NUMBER OF CLUSTERS.
 INC NUMLET ;0..15 -> 1..16
NXTW3:
 LDA #CSIZE  
 JSR INBITS
 DEC NUMLET
 BNE NXTW3  
;
 LDA BIIT ;THESE ARE EXACTLY THE
 BEQ NXTW4         
;NUMBER OF BITS IN THE BUFFER.
 JSR INBITS
NXTW4:
;
;IT WOULD BE FASTER HERE TO SIMPLY ZERO
;BIIT AND CALL THE APPROPRIATE ROUTINES TO
;BUMP UP PO
;
 JMP SEARCHW ;GO LOOK AT THE NEXT WORD THEN
;
CPFIL1:
 LDA #4
 JMP TEXIT
;
EVALCL:
;WORD FOUND, FILL TABLE OF CLUSTER POINTERS
;DEBUG
 LDX #$5
WEWON:
 JSR DELAY
 INC $D020
 DEX
 BNE WEWON
;
;EVALUATE THE CLUSTER INFORMATION
;
;
 LDA #4
 JSR INBITS ;RETRIEVE # OF CLUSTERS
;
 TAX
 INX ;0..15 -> 1..16 (MIN 1 S/B 2..17)
 STX NUMLET ;NUMLET = NUMBER OF CLUSTERS
 STX LEN ;SAVE #CLUSTERS IN PO
;
 LDA #0 ;CLEAR TEMPOR FOR
 STA TEMPOR ;INDEX TO POINTER TABLE
;
CPFILL:
 LDA #CSIZE ;SIZE IS 13 (S/B 12) BITS
 JSR INBITS
 BCS CPFIL1 ;ERROR ON READ
;
 LDX TEMPOR           
 STA CDATA,X
 STA VIDEO3,X
 LDA RETRNA+1
 INX
 STA CDATA,X
 STA VIDEO3,X
 INX
 STX TEMPOR 
;
 DEC LEN ;LEN = NUMLET DEC TO FILL TABLE
 BNE CPFILL ;FILL UP CDATA TABLE
;
;LDA #$33
;JMP TEXIT
;
;
;BEGIN LOOP TO:
;1) CALCULATE POINTER POSITIONS
;2) FILL POINTER TABLES AND
;3) PRESENT WORDS
;   (NUMLET COUNTS DOWN)
;
 LDA #0 
 STA LEN ;SET INDEX TO START OF CDATA TABLE
;
 LDA #'-' 
 LDY #$10                    
GDXX:
 STA $400,Y
 DEY
 BPL GDXX
;
MAINCL: 
;MAIN CLUSTER/WORD PRESENTATION LOOP
;
 LDX CLSNUM
 CPX NUMLET
;BEQ MAINCL1
 BCC MAINCL1 ;NOT DONE
;[CS]
 LDX #0
 RTS ;ALL DONE !!!!
;
;
MAINCL1:
 LDX LEN  
 LDA CDATA,X 
 STA P1    
 STA VIDEO7
 INX
 LDA CDATA,X
 STA P1+1
 STA VIDEO7+1
 INX
 STX LEN ;WHICH CLUSTER # TO LOOP ON
;
 INC CLSNUM ;CLUSTER # [1..N] BEING PRESENTED
;
 JSR FINDLOC ;RETURN SEEK CLUSTER, MAXWOR = #CHARS
;
;
 LDX #0 
 STX TEMPOR ;BUMP UP BY TWO'S THRU SO TABLE
;
WPFILL:
;FILL UP SO,PO TABLES OF WORDS FOR THIS CLUSTER
 LDA #9
 JSR INBITS ;.X IS SAFE THRU
 LDY TEMPOR  
 STA PSODATA,Y ;SO OF XTH WORD
 INY
 LDA RETRNA+1
 STA PSODATA,Y ;SO (HI) OF XTH WORD
 INY
 STY TEMPOR ;SET TO NEXT POSITION
;
 LDA #8
 JSR INBITS
;
 STA PPODATA,X ;PO OF XTH WORD
 INX ;0..(MAXWOR-1)
 CPX MAXWOR
 BCC WPFILL ;FILL WORD POINTER TABLE
;
;SEND 1ST WORD TO WORD,Y
;
 LDY #0   
 STY TEMPOR ;INIT 1ST PASS
;
PRESENT: 
;WORD-LOOP FROM JUMP
;
 LDA TEMPOR
 PHA
 TAX
 LDA PSODATA,X
 STA SO 
 INX                                          
 LDA PSODATA,X 
 STA SO+1
 INX
 STX TEMPOR
 PLA
 LSR ;INDEX FOR OTHER TABLE
 TAX
 LDA PPODATA,X
 STA PO ;GET WORD POSITION F/TABLE
;
;
 CPX MAXWOR       
;BEQ WPFILE0
 BCC WPFILE0
;
 JMP MAINCL ;PRESENT THE REST OF THE CLUSTERS
;
;
;SET SO, PO
WPFILE0:
;
 JSR FND1LT ;WHAT IS 1ST LETTER?
 JSR PUTCHAR ;PLACE CHAR IN WORD BUFFER
;
 JSR FLUSH ;CLEAN OUT BITBIN FOR NEXT READ
;
 JSR WSTARTT ;SET TRACK, SECTOR ON START OF WORD FILE
;
 JSR READSEC ;READ SECTOR SO TO FIND WORD
;
 JSR POSITON ;POSITION AT WORD (LENGTH,FIELD...)
;
 LDA #4
 JSR INBITS
 STA TEMPOR+1 ;TEMPOR+1 IS LENGTH
;
WPFILE1:
 JSR INLETT ;GET A LETTER FROM DISK
 BNE WPFILE2 ;
 LDA #' ' ;WE HAVE A SPACE!
 BNE WPFILE4 ;DO NOT FALL THRU, WILL BE "DOUBLET"
;
WPFILE2: 
 CMP #'Q'-64 ;IS THIS Q CODE?
 BNE WPFILE3
 JSR PUTCHAR ;PUT OUT THE Q
 LDA #'U'-64
;
WPFILE3:
 CMP #27   
 BCC WPFILE4 ;NORMAL LETTER
 SBC #27 
 ASL ;MAKE INDEX TO DOUBLET TABLE
 TAX        
 LDA DOUBLETS,X
 JSR PUTCHAR 
 LDA DOUBLETS+1,X
;
WPFILE4: 
 JSR PUTCHAR
;
 DEC TEMPOR+1
 BNE WPFILE1
;
 LDX CLSNUM
 CLC
 RTS
;
;
FINDLOC: 
;GIVEN CLUSTER NUMBER 0..8192 RETURN SO, PO, BIT
; CREATE #POINTERS DISTANCE INTO FILE IN MP1
; MULTIPLY BY WPLEN FOR NUMBER OF BITS IN FILE
; #BITS / 2048 = SECTOR OFFSET
; #BITS - (SO * 2048) = BITSINSECTOR
; BITSINSECTOR / 8 = POSITION
; BITSINSECTOR AND 111 = BIT OFFSET
; MAXWOR = # WORDS IN CLUSTER
;
;INDEX :     CTOTALS   CNUMPTRS
; 16   :        0         00
; 15   :        X        16*NC
; 14   :       X+Y    16*NC+15*NC
; ...  :       ...        ...
;  1   :        N
;
;ASSUME P1 = CLUSTER NUMBER
;
 LDA #BC ;SILLY SPECIAL CASE FOR 1 17 ENTRY CLUSTER
 STA MAXWOR
;
 JSR CLRMP1 ;MP1 = 000
;
 LDA P1
 ORA P1+1
 CMP #0
 BEQ ABSSTR ;ABSOLUTE BEGINNING,
;
 LDX #BC+2 ;MAXIMUM WORDS/CLUSTER (BC) S/B LARGER 3..N
 STX MAXWOR ;COUNT DOWN
 LDX #$FE ;-2
FLOOP: 
 INX
 INX ;0..2..4..6..
 DEC MAXWOR ;18..1
;
 LDA P1+1
 CMP CTOTALS+1,X
 BEQ FLOO1 ;TEST LO BYTES
 BCS FLOOP ;P1 > #TOTALS ENTRY, NEXT REGION!
 BCC FIRSTR ;P1 < #TOTALS, THIS REGION!
;
FLOO1:
 LDA P1
 CMP CTOTALS,X
 BEQ FLOFIR ;1ST CLUSTER IN REGION, FORCE ZERO
;THEN WE ARE DONE
 BCS FLOOP ;P1 > #TOTALS ENTRY, TRY NEXT REGION
 BCC FIRSTR ;IN PREVIOUS REGION
;
;IF THIS WERE 1ST ELEMENT OF 1ST REGION, PROCESS SEPERATELY
FLOFIR:
;ONLY FOR 1ST ELEMENT IN A REGION
 DEC MAXWOR ;ONE MORE DOWN BECAUSE ON SAME REGION,NOT PAST
 JMP MP1ISF ;AND COMPUTE
;
FIRSTR:
;
;ADJUST .X (2..4..6..8) TO POINT TO PREVIOUS
;REGION.  NOTE THAT 0 IS NOT POSSIBLE DUE TO PREVIOUS
;CHECK FOR P1=0, AND ANY OTHER NUMBER IS OBVIOUSLY
;GREATER.
 DEX
 DEX
 STX VIDEO6+2 
;
;CALCULATE NUMBER OF POINTERS THIS REGION
;ACTUAL CLUSTER NUMBER(P1) - TOTAL ENTRIES TO HERE CTOTALS
 SEC 
 LDA P1
 SBC CTOTALS,X 
 STA MP1
 LDA P1+1
 SBC CTOTALS+1,X
 STA MP1+1 ;MP1 = NUMBER OF ENTRIES FROM START OF REGION
;
 LDA MP1
 ORA MP1+1
 CMP #0
 BNE MP1ISF ;(DEBUG) MP1 IS NEVER TO BE ZERO!
 LDA #$8  
 JMP TEXIT ;EXIT FLAGGING MP1=1
;
MP1ISF:
;JSR DEC1MP1 ;MP1 = MP1-1 (COUNT TOTALS FROM 0) NO,CLUSTERS
;COUNT FROM 0..N
;
 LDA MAXWOR
 STA MP2
 JSR MP1XMP2 ;MP1 = MP1 * MP2 (16*8)-> (24)
;
;MP1 NOW HOLDS NUMBER OF POINTERS FROM START OF REGION
;
;NOW ADD NUMPTRS TOTAL FROM PREVIOUS REGIONS
 CLC
 LDA CNUMPTRS,X
 ADC MP1
 STA MP1
 LDA CNUMPTRS+1,X    
 ADC MP1+1
 STA MP1+1
 LDA CNUMPTRS+2,X
 ADC MP1+2
 STA MP1+2
;
;NOW MP1 CONTAINS TOTAL NUMBER OF POINTERS FROM START OF FILE
;
 LDA #WPLEN      
 STA MP2 ;MP2 = # BITS IN EACH POINTER
;
 JSR MP1XMP2 ;MP1 = MP1 * MP2
;MP1 NOW HOLDS TOTAL NUMBER OF BITS FROM START OF FILE
;
ABSSTR:
;GOOD PLACE FOR ABSOLUTE START (1ST WORD) ENTRY
;
 JSR MP1TTMP ;MOVE MP1 TO TEMPOR
;
 LDA #11
 JSR MP1ROL ; MP1 = MP1 / 2048 BY SHIFTING
 LDA MP1 ;S/B UNNECCESSARY
 STA SO ;HERE IS THE BLOODY SECTOR OFFSET!
 LDA #0  
 STA SO+1 ;ASSUME POINTER FILE < 256 SECTORS
;
 LDA #11  
 JSR MP1ASL ;MP1 = MP1 * 2048 BY SHIFTING
; NOW MP1 CONTAINS NUMBER BITS IN ALL SECTORS UP TO ACTUAL
; SUBTRACT THIS FROM TEMPOR TO CREATE BITS IN SECTOR
 SEC
 LDA TEMPOR
 SBC MP1
 STA MP1
 AND #$7 ;CHECK THIS
 STA BIIIT ;TO CREATE ACTUAL BIT POSITION
 LDA TEMPOR+1
 SBC MP1+1
 STA MP1+1
 LDA #0
 STA MP1+2 ;MP1 = BITS IN SECTOR
;
 LDA #3
 JSR MP1ROL ;MP1 = MP1 / 8 BY SHIFTING
 LDA MP1
 STA PO ;POSITION IN SECTOR
 STA VIDEO6+8
;
; CONVERT SO,PO,BIIT INTO TRACK,SECTOR,POS
 LDA #0
 STA SO   
 STA SO+1
 STA PO
 STA BIIIT
 INC DEBUG
;DEBUG
;
 JSR FLUSH ;CLEAR OUT BITBIN FOR FRESH DATA
;
 JSR PSTARTT ;SET TRACK, SECTOR START FOR PFILE
;
 JSR READSEC ;READ SECTOR WITH SO OF CLUSTER INFORMATION
;
 LDA PO
 STA $1300
;
 JSR POSITON ;SET POINTER TO BYTE CONTAINING POINTER
;
 LDA BIIIT
 BEQ FIRST1 
 JSR INBITS ;STRIP AWAY THE "GARBAGE" BITS
;
FIRST1:
;DEC MAXWOR ;MAKE MAXWOR 1..N NUMBER OF WORDS
 RTS ;NOW POSITIONED AT POINTER
;
;
TLETVER:
;VERIFY A TWO LETTER COMBINATION.
;.A IS NUMBER 1..N (WILL BE ZERO..N)
;
;DEC NUMLET ;!!!!! REMOVE THIS !!!!! AS SOON AS COMPRESSOR
;KNOWS ENOUGH TO COUNT DOUBLED CHARACTERS ONCE!
;
 STA VIDEO4
 ASL ;A = A * 2
 TAX 
 STA VIDEO4+1
;
 LDA (WORD),Y  
 STA VIDEO4+2 ;DEBUG ONLY
;
 LDA DOUBLETS,X
 STA VIDEO4+3
 CMP (WORD),Y     
 BNE DOUBAD
;
 INY
 LDA (WORD),Y 
 BNE TLETVE1
 JMP MEMOUT ;MEMORY IS OUT OF CHARACTERS...
;
TLETVE1:
 LDA (WORD),Y  
 STA VIDEO3+3 ;DEBUG ONLY!
;
 LDA DOUBLETS+1,X ;TEST AGAINST SECOND LETTER OF DOUBLET
 STA VIDEO3+4         
 CMP (WORD),Y
;
 BEQ DSC ;THIS DOUBLET IS OK
DOUBAD:     
 BCC DWLESS ;TARGET WORD < DISK DATA
 BCS DWNF   ;TARGET WORD > DISK DATA
;
DSC:
 JMP SAMECR ;DOUBLET VERIFIED
DWNF:
;DEBUG
 LDA #$C1
 JMP TEXIT
 JMP WNF
DWLESS:
 JMP WLESS    
;
;
INTRKSEC:
; ADD 1 TO SECTOR, IF RANGE OVERFLOWED, THEN ADD 1 TO TRACK
; USES A,Y
; UNHARMED .X
 INC SECTOR 
 LDA SECTOR
 CMP #12 ;AT LEAST 12 SECTORS ON ANY TRACK
 BCC SECOK
;
;SECTORS/TRACK = 20 + 2* (T>17) + (T>24) + (T>30)
;
 LDA TRACK
 LDY #20  
 CMP #18 ; IF X > 17 THEN DEY,DEY
 BCC TCHK1 ;T = 0..17
 DEY
 DEY
TCHK1:
 CMP #25
 BCC TCHK2 ;T = 0..24
 DEY
TCHK2:  
 CMP #31
 BCC TCHK3 ; T = 0..34
 DEY
TCHK3:
 CPY SECTOR ;.Y = NUMBER SECTORS THIS REGION 0..N
 BEQ SECOK
 BCS SECOK
 INC TRACK
;
 LDA TRACK
 CMP #18 ;DOS STUFF?
 BNE TCHK4 ;NO, REGULAR START
 LDA #2      
!byte $2C
TCHK4:
 LDA #0
 STA SECTOR
SECOK:
 RTS
;
; INC SECTOR
; LDX SECTOR
; LDA SECTAB,X
; CMP SECTOR
;THIS METHOD PLUS A TABLE COULD VORK FASTER
;
TERROR:
;DEBUG
 LDA #$1E 
 JMP TEXIT ;WE HAVE A TRACK ERROR
;
INCPOS:
;WATCH FOR END OF BUFFER, ADVANCE TO NEXT TRACK,
;SECTOR IF SO.  INCREMENT SO FOR FINAL WORD (TO
;AVOID) LOCATION.
 INC PO 
 BNE INCPOS1 ;WE ARE NOT OUT OF BYTES YET
;
 STA $453
;
 JSR INTRKSEC ;BUMP UP NEXT TRACK/SECTOR
 LDA #0 ;CLEAR NEW PO
 STA PO
 JSR INCWSO ;SO = SO + 1
;
 JMP RSECTOR ;READ SECTOR FROM EXISTING TRACK, SECTOR
INCPOS1:
 RTS
;
READSEC:
;BE SURE TRACK AND SECTOR ARE SET TO ABSOLUTE
;"START OF FILE" BEFORE CALLING
 LDA SO 
 STA P1 
 LDA SO+1
 STA P1+1 ;MOVE SO(SECTOR OFFSET) TO P1
;
FUCK:
 LDA P1+1
 ORA P1
 CMP #0
 BEQ RSECTOR ;IF AT START, THEN SKIP BUMP ROUTINE
;
BUMPFD:   
 JSR INTRKSEC ;INCREMENT SECTOR AND TRACK BY 1
 JSR DECWP1
 JMP FUCK
; BNE BUMPFD
;
;READ FROM EXISTING TRACK, SECTOR
;
RSECTOR:
;UNHARMED .X
 TXA      
 PHA
 JSR CLRCHN
 LDX #$F
 JSR CHKOUT
;
 LDX #UMSGE-UMSG-1
SENDU1:
 LDA UMSG,X
 JSR CHROUT
 DEX 
 BPL SENDU1 ;'U1:2 0 '
;
 LDA #'T'  
 STA $438
 LDA TRACK
 STA $439
 JSR SENDASC 
 LDA #' '
 JSR CHROUT
 LDA #'S'
 STA $43A
 LDA SECTOR
 STA $43B
 JSR SENDASC
 JSR CLRCHN
 LDX #$2
 JSR CHKIN ;CHANNEL 2 IS INPUT
 PLA
 TAX
HRTS:
 RTS
;
POSITON: 
;
 LDA PO
 BEQ HRTS 
;DEBUG WATCH OUT FOR THIS SHIT!!!
 JSR CLRCHN ;CLEAR CHANNEL 2
 LDX #$0F
 JSR CHKOUT
;
 LDX #PMSGE-PMSG-1
POSITO1:
 LDA PMSG,X ;'B-P:2,'
 JSR CHROUT
 DEX
 BPL POSITO1
 LDA #'P'
 STA $43C
;
 LDA PO
 STA $43D
 JSR SENDASC
;
;JSR CRLF
 JSR CLRCHN ;CLOSE CHANNEL 15
 LDX #$2
 JMP CHKIN
;
INCWSO:
 INC SO
 BNE INCWSO1
 INC SO+1
INCWSO1:
 RTS
;
CLRMP1:
 LDA #0
 STA MP1
 STA MP1+1
 STA MP1+2
 RTS
;
CRLF:
 LDA #$D
 JMP CHROUT
;
SENDASC:
;SEND .AC IN ASCII (0..255) TO CHROUT
; UNHARMED .X
; WILL SEND MINIMUM (0, NOT 000) TO DISK
 STX T4 ;SAVE .X
;
 LDX #'0' 
 LDY #'0'
SEHUND:
 CMP #100
 BCC SETENS 
 SBC #100
 INX ;ONE HUNDRED
 BNE SEHUND ;ANOTHER HUNDRED?
SETENS:
 CMP #10
 BCC ONES
 SBC #10
 INY
 BNE SETENS
ONES:
 ADC #'0'
 STA T3
 CPX #'0' ;IS HUNDREDS PLACE 0?
 BEQ LODID ;IF SO, DO NOT SEND, CHECK 10'S
;
 TXA ;.A = HUNDREDS PLACE
 STY T5 ;IN CASE CHROUT SHOULD HARM .Y
 JSR CHROUT ;HUNDREDS PLACE
 LDA T5 ;A = Y (ALWAYS SEND TENS HERE)
 BNE LODID1 ;BRA
;
LODID:
 CPY #'0' ;IS TENS PLACE 0?
 BEQ LODID2 ;IF SO, SKIP & SEND ONES
;
 TYA ;TENS IS NOT ZERO, SEND
LODID1:
 JSR CHROUT ;TENS PLACE
LODID2:
 LDA T3
 JSR CHROUT ;ONES PLACE
 LDX T4 ;RESTORE X
 RTS
;
MP1XMP2:
;16 * 8 MULTIPLY WITH 24 BIT RESULT
;USES AC,RESULT,MP1,MP2
;UNHARMED .X,.Y
;
 TXA
 PHA ;SAVE .X
 LDX #8 ;NUMBER OF BITS TO SHIFT THRU
 LDA #0
 STA RESULT
 STA RESULT+1
;
MSHIFT:
 ASL RESULT
 ROL RESULT+1
 ROL RESULT+2 ;PRODUCT = 2 * PRODUCT
;
 ASL MP2 ;BYTE-MULTIPLIER * 2
 BCC MNOADD
;
 CLC
 LDA RESULT
 ADC MP1 ;MULTIPLICAND-WORD
 STA RESULT
 LDA RESULT+1
 ADC MP1+1
 STA RESULT+1
 LDA RESULT+2
 ADC #0
 STA RESULT+2
;
MNOADD:
 DEX
 BNE MSHIFT
;
 LDA RESULT+2
 STA MP1+2
 LDA RESULT+1
 STA MP1+1
;
 PLA
 TAX ;RESTORE .X
;
 LDA RESULT
 STA MP1           
 RTS
;
MP1TTMP:
 LDA MP1
 STA TEMPOR
 LDA MP1+1
 STA TEMPOR+1
 LDA MP1+2
 STA TEMPOR+2   
 RTS ;MOVE MP1 TO TEMPORARY
;
;MP1T:
; RTS ;MOVE TEMPORARY TO MP1
;
FND1LT:
;FIND FIRST LETTER OF WORD
;SO, PO OF WORD ONLY INPUT
; USES X,A,T1
; UNHARMED Y
;
 LDX #2
FND1L1:
 LDA SO,X
 CMP WSO,X    
 BNE FND1L2 ;NOT DUPLICATE OF CALLING WORD
 DEX 
 BPL FND1L1
;
 SEC
;RTS ;CS = THIS IS SAME AS CALLED WORD
;REMOVE FOR NOW TO ALLOW ALL WORDS
;
FND1L2:
;
 LDX #0 
 STX T1 ;LETTER A..Z
 BEQ FND1L4
;
FND1L3:
 INX
 INX
 INX
FND1L4: 
 INC T1 ;LETTER A..Z
;
 LDA LETTER+1,X 
 CMP SO+1
 BEQ FND1L5
 BCS FND1L7 ;LETTER > SO, LAST LETTER IS LETTER
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN.
;
FND1L5:  
 LDA LETTER,X  
 CMP SO
 BEQ FND1L6 
 BCS FND1L7 
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN.
;
;
FND1L6:
 LDA LETTER+2,X ;POSITION
 CMP PO
 BEQ FND1L8 ;ON EXACT BOUNDRY,NO DEC
 BCC FND1L3 ;LETTER < PO, BUMP UP TABLE, TRY AGAIN.
;
FND1L7:
 DEC T1
FND1L8:
 LDA T1
 CLC
 RTS
;
WSTARTT:
 LDA #2 
!byte $2C
PSTARTT:         
 LDA #23
 STA TRACK
 LDA #0
 STA SECTOR
 RTS
;
MP1ROL:
 STA BITROT ;# OF BITS TO SHIFT
MP1RL1:
 LSR MP1+2
 ROR MP1+1 
 ROR MP1   
 DEC BITROT
 BNE MP1RL1 
 RTS
;
MP1ASL:
 STA BITROT ;# OF BITS TO SHIFT
MP1AS1:
 ASL MP1
 ROL MP1+1
 ROL MP1+2
 DEC BITROT
 BNE MP1AS1
 RTS    
;
DECWP1:
 LDA P1
 BNE DECWP11
 DEC P1+1
DECWP11:
 DEC P1
 RTS
;
DEC1MP1:
 LDA MP1 ;MP1 = MP1-1 (16 BIT ONLY!!!)
 BNE DECMP11
 DEC MP1+1
DECMP11:
 DEC MP1
 RTS
;
INLETT:
;SET FOR LETTER READ AND FALL IN INBITS
 LDA #5
;
INBITS:   
; PEEL .A BYTES FROM INPUT CHANNEL
;
; USES .A,.X,.Y,T1,T2,SO,PO,BIIT,BITBIN,BITROT
; RETURNS .A, RETRNA
;
STRIP:
 STA BITROT  ;NUMBER OF BITS
 LDA #0
 STA RETRNA
 STA RETRNA+1 ;CLEAR OUT RETURNED VALUE
STRIP0:
 LDA BIIT
 BEQ STRIP2 ;NO BITS LEFT IN BIN
STRIP3:
 ASL BITBIN
 ROL RETRNA
 ROL RETRNA+1 ;SLIDE NEW BIT INTO RETURN WORD
 DEC BIIT
 DEC BITROT
 BNE STRIP0
 JSR STRIPBUG ;DEGUBBING ONLY
 LDA RETRNA
 CLC
 RTS
;
STRIP2:
 STY T1   
 STX T2
 JSR GETIN
;DEBUG
 PHP
 PHA
 LDA DEBUG
 BEQ DEGG
 PLA
 PHA
SMOD:
 STA $4000 
 INC SMOD+1
 BNE DEGG
 INC SMOD+2
DEGG:
 PLA
 PLP  
;
 BCS BEXIT
 STA $451
;
;HANDLE TRACK/SECTOR BUFFERING
 PHA 
 LDA PO
 STA $453
;
 JSR INCPOS ;BUMP UP POSITION AND STREAM FILE IF NEEDED
 PLA
;
POSOK:
 STA BITBIN
 LDY T1
 LDX STATUS
 BNE BEXIT ;GET OUT
 LDX T2
 LDA #8
 STA BIIT
 BNE STRIP3 ;BRA
;
FLUSH: 
;CLEAR OUT BITBIN FOR NEW STRIP
 LDA #0
 STA BIIT
 RTS
;
BEXIT: 
;DEBUG
 LDA #$DE ;DISK ERROR!
 JMP TEXIT
;
 SEC    
 RTS   
;
WNDX:  
!byte 0
!byte 0
PUTCHAR:
;PUT A CHAR FROM WORD INTO BUFF
 STY WNDX+1 ;SAVE .Y
 LDY WNDX
 STA $400,Y
 INC WNDX
 LDY WNDX+1 ;RESTORE .Y
 RTS
;
DEBUG
!byte 0;FLAG TO KEEP DISK LOG OR NOT
STRIPBUG:
;FOR DEBUGGING PURPOSES ONLY
 LDA DEBUG
 BEQ STRIPB2 ;DO NOT DEBUG NOW
;
 LDA RETRNA         
 JSR STRIPB1
 LDA RETRNA+1
 JSR STRIPB1
 RTS
STRIPB1:
 STA $3000   
 INC STRIPB1+1
 BNE STRIPB2
 INC STRIPB1+2
STRIPB2:
 RTS
;
CLSNUM: ;0 OR CLUSTER NUMBER TO PRESENT
!byte 0;INIT TO ZERO
;
IODRIVE:
!text "I0"
;
UMSG:
!text " 0 2:1U"
UMSGE:     
;
PMSG:
!text " 2:P-B"
PMSGE:  
;
CHANNEL:
!byte '#'
;
CTOTALS:
; TOTALS (BY SECTION) FOR THESAURUS
!word 0000,0001,0075,0132,0235,0378,0567,0787,1083,1359
!word 1641,1934,2274,2745,3183,3341,0000
;*NEVER* CHANGE THIS TABLE W/O REFLECTING IN CNUMPTRS!!!
;
;
CNUMPTRS:
; TABLE OF WORDS OF TOTALS FOR NUMBER OF POINTERS/REGION (CUMULATIVE)
; *NEVER* CHANGE THIS TABLE W/O REFLECTING IN CTOTALS!!!
V1 =  BC*0001
V1X =  BC*0074-01*0074 
;CONV VAR SUBSTITUTED with EQU
V2 =  V1+V1X
V2X =  BC*0057-02*0057
;CONV VAR SUBSTITUTED with EQU
V3 =  V2+V2X
V3X =  BC*0103-03*0103
;CONV VAR SUBSTITUTED with EQU
V4 =  V3+V3X
V4X =  BC*0143-04*0143
;CONV VAR SUBSTITUTED with EQU
V5 =  V4+V4X
V5X =  BC*0189-05*0189
;CONV VAR SUBSTITUTED with EQU
V6 =  V5+V5X
V6X =  BC*0220-06*0220
;CONV VAR SUBSTITUTED with EQU
V7 =  V6+V6X
V7X =  BC*0296-07*0296
;CONV VAR SUBSTITUTED with EQU
V8 =  V7+V7X
V8X =  BC*0276-08*0276
;CONV VAR SUBSTITUTED with EQU
V9 =  V8+V8X
V9X =  BC*0282-09*0282   
;CONV VAR SUBSTITUTED with EQU
V10 =  V9+V9X
V10X =  BC*0293-10*0293
;CONV VAR SUBSTITUTED with EQU
V11 =  V10+V10X
V11X =  BC*0340-11*0340
;CONV VAR SUBSTITUTED with EQU
V12 =  V11+V11X
V12X =  BC*0471-12*0471
;CONV VAR SUBSTITUTED with EQU
V13 =  V12+V12X 
V13X =  BC*0438-13*0438
;CONV VAR SUBSTITUTED with EQU
V14 =  V13+V13X
V14X =  BC*0158-14*0158
;CONV VAR SUBSTITUTED with EQU
V15 =  V14+V14X
;
;
!word 0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15
;
LETTER:
;TABLE OF STARTING SO,PO FOR EACH LETTER A..Z
;A
!word 0
!byte 0
;B
!word 29
!byte 098
;C
!word 48
!byte 027
;D
!word 84
!byte 222
;E
!word 114
!byte 146
;F
!word 135
!byte 249
;G
!word 157
!byte 163
;H
!word 169
!byte 103
;I
!word 180
!byte 220
;J
!word 205
!byte 232
;K
!word 208
!byte 186
;L
!word 210
!byte 061
;M
!word 223
!byte 244
;N
!word 242
!byte 123
;O
!word 248
!byte 054
;P
!word 258
!byte 068
;Q
!word 293
!byte 243
;R
!word 295
!byte 161
;S
!word 321
!byte 015
;T
!word 364
!byte 227
;U
!word 384
!byte 033
;V
!word 397
!byte 211
;W
!word 406
!byte 000
;X
!word 416
!byte 036
;Y
!word 416
!byte 026
;Z
!word 417
!byte 012
;END OF ALL (FOR USE BY SO,PO COMPARITOR)
!word 417
!byte 0
;
LETTEO:
;TABLE OF STARTING SO,PO FOR EACH WORD AO..ZO
;AO
!word 18
!byte 187
;BO
!word 40
!byte 120
;CO
!word 60
!byte 130
;DO
!word 109
!byte 114
;EO
!word 125
!byte 112
;FO
!word 148
!byte 207
;GO
!word 163
!byte 017
;HO
!word 176
!byte 098
;IO
!word 104
!byte 168
;JO
!word 206
!byte 210
;KO
!word 210
!byte 056
;LO
!word 219
!byte 191
;MO
!word 236
!byte 235
;NO
!word 245
!byte 189
;OO
!word 252
!byte 106
;PO
!word 273
!byte 077
;QO WATCH OUT HERE, S/B SAME AS ORIG
!word 293
!byte 243
;RO
!word 317
!byte 204
;SO
!word 341
!byte 049
;TO
!word 374
!byte 100
;UO
!word 396
!byte 044
;VO
!word 404
!byte 160
;WO
!word 413
!byte 122
;XO AGAIN SAME
!word 416
!byte 036
;YO
!word 416
!byte 204
;ZO
!word 417
!byte 078
;
; DOUBLET TABLES
;
DOUBLETS:
!byte 'E'-64,'R'-64;ER 0
!byte 'O'-64,'N'-64;ON 1
!byte 'T'-64,'I'-64;TI 2
!byte 'A'-64,'T'-64;AT 3
!byte 'T'-64,'E'-64;TE 4
;
!byte 'Q'-64,'U'-64;QU 5 (SPECIAL CASE, REPLACE Q CODE)
;
PSODATA:
;STORAGE FOR EACH CLUSTER'S ENTRIES
;SO POSITIONS
!word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
PPODATA: 
;PO POSITIONS
!byte 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;
CDATA:
;ACTUAL CLUSTER #'S PICKED UP TO REFERENCE
!word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
;
;SOME VARIABLES FOR STRIP (S/B ZP)
;
RETRNA
!word 0;RETURN VALUE FOR STRIP (WORD)
BIIT
!byte 0
BITBIN
!byte 0
BITROT
!byte 0
;
; TEST CODE ONLY... DELETE THIS SHIT
UGH
!word 0
;
FTEST:
 LDA #0
 STA UGH
;
 INC DEBUG ;TURN ON DISK LOG
FUCKW: 
 LDA #16
 JSR INBITS         
 DEC UGH
 BNE FUCKW
 LDA #$DE
 JMP TEXIT 
;
DELAY:
 PHA
 STX $1300
 LDX #$80
DELAY2:
 LDA #$00
DELAY1:
 SEC
 SBC #$01
 BNE DELAY1
 DEX
 BPL DELAY2
 LDX $1300
 PLA
 RTS
;
TEXIT:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)
ENDPOS:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
 LDA #$2
 JSR CLOSE
 JSR $FFE7
 BRK
 BRK
 BRK  
;
CLEARF:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)
ENDPOO:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
 LDA #$2
 JSR CLOSE
 JMP CLALL
;
!byte 0,0,0;SAFETY
!eof
; 
