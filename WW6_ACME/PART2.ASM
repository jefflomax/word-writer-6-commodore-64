;
!zone PART2
;
;
; EXTERN IN_DATABASE_MODE
;
; PUBLIC LOADR1
;
;
FC_RUN_STOP:
 LDA MOVE_COPY_HL        ;ARE WE MARING A BLOCK?
 BPL VERSION_MSG        ;IF NO, VERSION MESSAGE
;
; LDA IN_DATABASE_MODE	;AND ARE WE ALSO IN THE DB?
; BEQ KILL_BLOCK
;
;
KILL_BLOCK:
REMOVE_BLOCK:
 LDX #0                  ;WIPE OUT BLOCK
 STX MOVE_COPY_HL
 STX CURFLG              ;DISALLOW CR TO CREATE TEXT
 JMP DISPLAY_SCREEN_AND_HEADER
;
VERSION_MSG: 
 LDX #55
 JMP SERPP0
;
PRTVER9:
 JMP ON_AND_REFREASH
;
;
FC_CATALOG:
 LDA #USE_DATA_DISK
 JSR DISKIN 		;SET TO DATA PATH, CHECK DRIVE
 BCS PRTVER9
;
 LDA #$93
 JSR CHROUT
 LDA TXCOLR
 STA $286
;
 LDA CURRENT_KEY
 CMP #$BE               ;COMM-V
 BNE .NO_MSG
;
 LDX #0 
 JSR PRINT_MSG_X
 JSR CRLF
;
.NO_MSG:
 JSR CATLOG
;
 JSR PRESS_ANY_KEY_CHROUT
;
 JSR WAIT_FOR_KEY
 JMP FULL_SCREEN
;
PRESS_ANY_KEY_CHROUT:
;
 JSR CRLF
 LDX #<(PRESS_ANY_KEY_MSG-WORKING_MSG)
PRINT_MSG_X:
;
 LDA WORKING_MSG,X
 CMP #'>'
 BEQ .OUT
 JSR CHROUT
 INX
 BNE PRINT_MSG_X
;
.OUT:
 RTS
;
;
;
FC_TOGINSERT:
FC_TOGGLE_INSERT:
 LDA OUTMODE          ;OVR ONLY IN OUTLINER
 BNE FC_IN_ABORT
;
; LDY #'R'             ;.Y R OR S
 LDA INSERTM
 EOR #$80
 STA INSERTM
 BNE TOGINS1
TOGINS0:                          
 LDA #'O'                         
; LDX #'V'
; LDY #'R'
 BNE TOGINS2                      
TOGINS1:                          
 LDA #'I'                         
; LDX #'N'
; LDY #'S'            ;['S']
; INY
TOGINS2:
 STA HEAINS+1
; STX HEAINS+1
; STY HEAINS+2 ;SET HEADER TO 'INS' OR 'OVR'
;
FC_IN_ABORT:
 JMP HEADER
;
;
FC_SEARCH_AGAIN:
 JSR DO_SEARCH_AGAIN
 JMP DISPLAY_ON_AND_LINE_OUT
;
FC_SEARCH:
 JSR DO_SEARCH
 JMP DISPLAY_ON_AND_LINE_OUT
;
;
DO_SEARCH_AGAIN:
 JSR FC_CURSOR_RIGHT     ;PREPARE FOR NEXT SEARCH
SEARCH_AGAIN_FROM_CURS:
 LDA #0
 STA RPSLEN
 BEQ SEARCH
;
DO_SEARCH:
 LDX #0
 STX STEMP   ;REPLACE DONE?
 STX CURFLG
 JSR SERPPT
 JSR INPUT0
 BEQ FC_SEARCH ;NO NULLS!
 STX SEARCH_STRING_LENGTH
STRIN1:
 LDA VIDEO,X
 STA CBUF,X
 DEX
 BPL STRIN1
 LDA CBUF
 CMP #' '
 BNE SAMPTH
 LDA SEARCH_STRING_LENGTH
 CMP #2
 BCC FC_SEARCH
SAMPTH:
 LDX #1
 JSR SERPPT
 JSR INPUT0
 STX RPSLEN     ;0 = DO NOT REPLACE, NZ = REPLACE LENGTH
;
STRIN2:
 LDA VIDEO,X
 STA CBUF2,X
 DEX
 BPL STRIN2 ;STRINGS SET!
;
 JSR HEADER
;
SEARCH:
;
;BEGIN BY POINTING TEXT AT CURRENT CURSOR POSITION
 JSR EDIT_BUFFER_TO_TEXT    ;COPY EDITED LINE BACK INTO TEXT
 JSR TETORETNA              ;SAVE OFF CURRENT POINTER
;
 LDA CURRENT_CHAR           ;COLUMN WHERE TEXT CURSOR IS
 JSR ADDATX                 ;POINT TEXT AT SEARCH POINT
;
 LDY #0
 JMP FIND_VALID_LETTER2
;
SEARCH_LOOP:
;
 LDY #0
 STY TEMP3                  ;INDEX FOR SEARCH STRING
 STY TEMP1                  ;INDEX FOR TEXT STRING
;
SEARC2:
 LDY TEMP1                  ;GET INDEX TO TEXT
 LDA (TEXT),Y               ;AND TEXT CHARACTER
 CMP #ENDT                  ;SEE IF IT IS END
 BEQ SEARCH_ABORT           ;IF SO ABORT SEARCH
 CMP #$82                   ;IS IT A EMBEDDED CODE OR RETURN?
 BCC SEARCH_WORD            ;NO, TEST REG LETTER
;
SEARCH_SKIP_CHAR:
 INC TEMP1
 BNE SEARC2
;
SCASE1 =  *+1
SEARCH_WORD:
 AND #$FF ;MORE CASE STUFF
 LDY TEMP3
 CMP CBUF,Y
 BNE SEARCH_NEXT_WORD     
;
SEARCH_3:
 INC TEMP1                  ;TEXT INDEX
 INC TEMP3
 INY
 CPY SEARCH_STRING_LENGTH
 BNE SEARC2
;
 CPY #1
 BNE .SKP
 LDA CBUF                ;IS THIS MARK CHARACTER?
 BMI POSITION            ;BIF YES
.SKP:            
 LDY TEMP1               ;PROVE IT IS ACTUALLY WORD END
 LDA (TEXT),Y
 BMI POSITION
;
 JSR LETTER_OR_NUMBER
 BCS POSITION ;MATCH
;
SEARCH_NEXT_WORD:
 LDY #0
.LOOP1:
 JSR INCTE1
 LDA (TEXT),Y         
 CMP #ENDT
 BEQ SEARCH_ABORT
 BCS FIND_VALID_LETTER
 CMP #$82
 BCS .LOOP1                    ;ISOLATE $80
 CMP #$80                      ;AND $81 FOR MARK VALUES
 BCS SEARCH_LOOP 
;
; JSR LETTER_OR_NUMBER
 JSR TESTC0                    ;CC=LETTER, CS=NO.
 BCC .LOOP1
;
FIND_VALID_LETTER:
 JSR INCTE1
FIND_VALID_LETTER2:
 LDA (TEXT),Y         
 CMP #ENDT
 BEQ SEARCH_ABORT
 CMP #$82
 BCS FIND_VALID_LETTER
; JSR LETTER_OR_NUMBER
; BCS FIND_VALID_LETTER
 CMP #' '
 BEQ FIND_VALID_LETTER
;
.FOUND_WORD:
 JMP SEARCH_LOOP
;
SEARCH_ABORT:
 JSR RETNATOTE
 LDX STEMP
 BNE .SKP0279
 LDX #41
 JSR SERPP0
.SKP0279:
; JMP DISPLAYON
 RTS
;
POSITION:
; LDA TEXT
; STA P2
; LDA TEXT+1
; STA P2+1
 JSR TEXT_INTO_AX
 STA P2
 STX P2+1
;
 JSR RETNATOTE
;
;
 JSR FC_BEGINNING_OF_LINE       ;TURNS DISPLAY OFF
.NXT_LINE:
 JSR FC_CURSOR_DOWN
 BCS .JUST_RIGHT         	;LAST LINE? (CANNOT EXCEED)
;
;# SMALLER ROUTINE
 LDA TEXT+1
 CMP P2+1
 BEQ .TST_LO
 BCC .NXT_LINE
 BCS .TOO_FAR
.TST_LO:
 LDA TEXT
 CMP P2
 BEQ .JUST_RIGHT
 BCC .NXT_LINE
;
.TOO_FAR:
 JSR FC_CURSOR_UP        	;NOW ON THE "RIGHT" LINE
;
.JUST_RIGHT:
;
 SEC
 LDA P2
 SBC TEXT
 STA COUNT_DOWN
 BEQ .DONE
;
.LOOP3:
 JSR FC_CURSOR_RIGHT
 DEC COUNT_DOWN
 BNE .LOOP3
.DONE:
;
 LDA RPSLEN
 BEQ .SEARCH_DONE
;
 JSR REPLSUB
 INC STEMP
 JMP SEARCH
;
.SEARCH_DONE:
;
 CLC
 RTS
;
DEC_TEMP:
 LDX CURRENT_CHAR
 LDA EDIT_LINE,X
 BMI .SKP0347
 DEC TEMP
.SKP0347:
 RTS                  ;RETURN .X CURRENT_CHAR
;
; JMP SEARCH
;
.SEARCH_DONE0354:
 JMP DISPLY
;
STEMP:
!byte 0
SEARCH_STRING_LENGTH:
!byte 0
;
REPLSUB:
;
 LDA SEARCH_STRING_LENGTH
 STA TEMP   
.LOOP4:
 LDX CURRENT_CHAR
 INX
 CPX CHARS_IN_LINE
 BNE .IN_LINE
;
 LDA TEMP                ;DON'T DO CD IF OUT OF SOURCE STRING
 CMP #1
 BEQ .IN_LINE
;
 JSR DEC_TEMP            ;SETS .X TO CURRENT_CHAR
; DEX
 LDA EDIT_LINE,X 
 CMP #' ' 
 BNE .SKP0380
 JSR FC_DELETE_CHAR
 JMP .SKP1
;
.SKP0380:
 JSR FC_DELETE_CHAR_RT
.SKP1:
 JSR EDIT_BUFFER_TO_TEXT
 JSR FC_BEGINNING_OF_LINE ;GO_LEFT_MARGIN
 JSR FC_CURSOR_DOWN
 JMP .TST_DONE
;
.IN_LINE:
 JSR DEC_TEMP
 JSR FC_DELETE_CHAR_RT
.TST_DONE:
 LDA TEMP 
 BNE .LOOP4 
;
 LDA INSERTM
 PHA
 LDX #$FF
 STX INSERTM
;
 INX ;[0]
 STX COUNT_DOWN
.LOOP6:
 LDA CBUF2,X
 JSR FC_WORK_KEY
 INC COUNT_DOWN
 LDX COUNT_DOWN
 CPX RPSLEN
 BCC .LOOP6
;
 PLA
 STA INSERTM
REPL_RTS:
 RTS
;
;
;
BLKSET =  *+1
FC_CHECK_SPELLING:
 LDA #$00       ;SM1 0=NO
 BNE SWAPE1
;
 LDX EOT+1
 INX
 CPX #>ENDRAM_MP
 BCS REPL_RTS
;
 LDX #28        ;CHECK SPELLING?(Y/N)
 JSR PRKECY     ;PRINT & CMPY
 BNE ABORTBLK2  ;GET OUT
;
 INC BLKSET     ;SECOND BLOCK ACTIVE
 LDA #USE_SPELL_DISK
 JSR DISKIN     ;SET TO SPEL/THES PATH, CHECK DRIVE
 BCS SWAPE2
;
 LDX #32        ;SORTING, PLEASE WAIT
 JSR SERPPT
 JSR EDIT_BUFFER_TO_TEXT
 JSR INIT_BLOCK_TWO      ;SET UP BLOCK 2
 JSR FC_CLEAR_HOME_NT    ;AND CLEAR HOME
 JMP DOSPEL
;
SWAPE1:
 JSR SWPBLK
 JSR RESET
 JSR FC_CLEAR_HOME_DSP
;
SWAPE2:
 DEC BLKSET     
;
ABORTBLK2:
 JMP HEADER
;
;
FC_THESAURUS_LOOKUP:
 LDX BLKSET              ;NOT IN BANK 2 YOU DON'T
 BNE ABORTBLK2
;
 LDA HIMEM+1
 SBC #20
 CMP EOT+1   
 BCS DOTHESC
 LDX #36
 JMP SERPP0              ;NEED SUFF MEMORY
;
DOTHESC:
 JSR EDIT_BUFFER_TO_TEXT
 JMP DOTHSR ;DO THE THESAURES
;
;
ISTRLEN:
!byte 0;LENGTH OF STRING
;
INPUT0: 
 LDA #$1D          ;INPUT STRING OF MAX CHARACTERS
INPUTS:
 STA MSLEN         ;INPUT STRING OF .A CHARACTERS
INPUT:
 LDX #0
INPUTF:
;INPUT WITH SET MSLEN (MAX) AND FORCED LENGTH (.X)
 STX ISTRLEN ;LENGTH OF CURRENT STRING
INPUT1:
 CPX ISTRLEN
 BCC INPUTLL ;LENGTH LESS THE ISTRLEN
 STX ISTRLEN ;ISTRLEN CAN GROW WITH .X
;
INPUTLL:
 JSR CURSONOFF
;
INPUT9:
 STX TEMP3
 JSR KEYBRD
 LDX TEMP3
;
 PHA
 JSR CURSONOFF
 PLA
;
 BIT KEYABT ;IN NO ABORT MODE?
 BPL INPUT4 ;ABORTS OK, DO REG
;
 CMP #$11 ;CURSOR DOWN
 BEQ INPUT6 
 CMP #$91 ;CURSOR UP
 BEQ INPUT6 
 CMP #$03 ;RUN/STOP
 BNE INPUT4
INPUT6:
 SEC ;EXIT CS IF IN "NO ABORT" W/CUP OR DOWN
 RTS   
;
INPUT4:
 CMP #$D ;RETURN?
 BEQ INPUT2
;
 CMP #157 ;CURSOR LEFT?
 BNE INPCURR ;NO, TRY RIGHT
;
 TXA ;CLOBBER .A FOR .X FLAG
 BEQ INPUT1 ;AT LEFT MARGIN, EXIT
 DEX 
 BPL INPUT1 ;MOVE CURSOR LEFT, EXIT
;
INPCURR:
 CMP #29 ;CURSOR RIGHT?
 BNE INPDEL ;NO, TRY DELETE
;
 CPX ISTRLEN
BSINPUT1:
 BCS INPUT1 ;AT OR PAST END OF STRING, EXIT
 INX
BPINPUT1:
 BPL INPUT1
;
INPDEL:
 CMP #$14 ;DELETE KEY
 BNE INPUT7 ;GO TRY CLR/HOME
 JSR INPUTDEL
 BPL INPUT1
;
INPUT7:
;CLR/HOME ERASE FIELD
 CMP #147 ;CLR/HOME
 BNE INPUT8 ;TRY REGULAR
 LDY MSLEN
INPUT7A:
 JSR INPUTDEL
 DEY
 BNE INPUT7A ;ERASE WHOLE FIELD
 BEQ INPUT1
;
INPUT8:
;HOME MOVE TO START FIELD
 CMP #19 ;HOME KEY
 BNE INPUTINS
 LDX #0
 BEQ INPUT1 ;BEGIN AGAIN
;
INPUTINS:
 CMP #148 ;INSERT?
 BNE INPUT3 ;TRY NORMAL KEY
 JSR INPINSERT
 BNE INPUT1
;
INPUT3:
 STA INPBUF,X ;SET CHAR IN BUFFER (PETASCII)
 JSR PETASC ;CONVERT PETASCII TO SCREEN
 BCS BSINPUT1
 STA VIDEO,X
 INX
 CPX MSLEN
 BCC INPUT1
 DEX
 BPL BPINPUT1
;
INPUT2:
 LDX ISTRLEN
 STX MSLEN ;SET NEW MESSAGE LEN
 CPX #0 ;NULL STRING?
 CLC 
 RTS
;
;
INCEO1:
 INC EOT
 BNE INCEO3
 INC EOT+1
INCEO3:
 RTS
;
;
LINOUT:
 LDA LINE
;
CLINOT:
 JSR HEXOUT
; STA VIDEO+$21
; LDA TEMP1
; STA VIDEO+$20
; RTS
 LDY #':'
 LDX #$1F
 JMP PAG_LIN_COL_OUT1
;
;
MVTEMV:
 LDA TEXT
 STA MOVELO
 LDA TEXT+1
 STA MOVELO+1
 RTS 
;
;
PSHEOT LDA EOT
 STA SAVEOT
 LDA EOT+1
 STA SAVEOT+1
PSH_RTS:
 RTS
;
;
CLR_CHK_LOAD_FILE:
 JSR CLRCHN 		;CLEAR 15
 JSR CHNL2I
 LDX $90
 BNE PSH_RTS
;
;LOADR1:
;
 LDA #$C0
 STA POINTER4   ;FLAG MERGE (IGNORE FDEF)
 JSR CHRIN      ;GET 1ST BYTE OF FILE
 STA POINTER+1  ;LOAD FORMAT
 LDX $90        ;CHECK STATUS NOW!
 BNE PSH_RTS    ;IF GOOD, 1ST BYTE GOOD
;
 LDX SAVEOT
 LDY SAVEOT+1   ;NEW LOAD ADDRESS
 CPX #<STARTRAM ;IS THIS A MERGE?
 BEQ .NLOAD     ;NO, LOAD
 BNE .MLOAD     ;YES, MERGE
 CPY #>STARTRAM ;TEST HI, NO, LOAD
 BEQ .NLOAD
;
.MLOAD:
 INC DOCUMENT_ALTERED
 STX EOT
 STY EOT+1
 PHA
 LDY #$00
 LDA #RETURN
 STA (EOT),Y
 PLA
 JSR INCEO1
 BNE .MERGE_JOIN
;
.NLOAD: 
;
 STX EOT
 STY EOT+1      ;SET EOT TO PROPER ADDRESS
;
 LDY #0
 STY DOCUMENT_ALTERED
;
 LDY #$80       ;SET FLAG FOR LOAD FONT_TABLE
 STY POINTER4   ;LOAD FLAG
;
.MERGE_JOIN:
;
 CMP #$FE       	;WW4 FORMAT?
 BNE LOAD_OLD_FORMATS 	;TRY 1/3
 JSR LDTABS     	;READ TABS
 JSR CHRIN      	;GET FONT_TABLE PRESENT BYTE
 CMP #0 
 BEQ LOAD_WW4   	;NO FONT.DEF IN TEXT, HENCE, READ DURING PRINT
;
 CMP #$FE		;IF FONT.DEF PRESENT, GO AS NORMAL
 BEQ .FONT_DEF_HERE
;
 LDX IN_DATABASE_MODE	;ARE WE IN THE CARDFILE NOW?
 BNE .CARD_DEF_HERE	;.AC = 1, READ CARD INFO
;
 LDA #$C1		;IGNORE CARDFILE INFO
.CARD_DEF_HERE:
 STA POINTER4		;SET FLAG, 1 == CARDFILE MODE
;
.FONT_DEF_HERE:
 JSR SAVE_LOAD_FDEF_TABLE1
;
LOAD_WW4:
 JSR CHRIN      ;GET CHAR
;
 LDX OUTMODE		;ARE WE IN THE OUTLINER?
 BNE .IN_OUTL_OR_DB	;IF SO SUPRESS ALL HI-BIT CODES
 LDX IN_DATABASE_MODE	;ARE WE IN THE CARDFILE?
 BEQ .NOT_OUT      	;IF NOT, ALLOW ALL (BRANCH)
;
 JSR LOAD_256_SUPRESS	;MINIDB
 BCC .NOT_PG_256
;
 JSR CLALL
 JMP KILL_DOC		;CLEAR HOME AND MNLINE
;
.NOT_PG_256:
 CMP #CMARK		;IF SO, NO CHECKMARKS OR HI BIT CODES IN DB!
 BEQ LOAD_WW4		;IF CHECKMARK, READ NEXT CHAR
;
.IN_OUTL_OR_DB:
 CMP #ENDT  		;OUTLINER OR DB
 BCS .NOT_OUT		;EOT/SRET/RET ALLOWED
 CMP #$81		;ANYTHING ELSE NOT
 BCS LOAD_WW4
;
.NOT_OUT:
 JSR STCRCK     	;STORE & CHECK
 BCC LOAD_WW4
.OUT0722:
 LDA POINTER4		;WAS THIS A ACTIVE CARDFILE LOAD?
;
;CARDFILE LOADED IN NON-CARDFILE MODE P4 = $C1
;
 CMP #1
 BNE .NOT_CARDFILE
;
 LDA FIELD_NAMES
 LDY #'N'
 JSR SET_PL		;SETUP PAGE LENGTH
 JSR SET_VM_ZERO	;SETUP VERTICAL MARGINS TO ZERO
;
.NOT_CARDFILE:
 RTS
;
LOAD_OLD_FORMATS:
 LDX #0
 STX POINTER2   ;"ATTRIBUTES" OFF
;
!byte $A2;LDX #
NEW_FORMAT_ONLY:
!byte $FF
 BNE .REG_LOAD
 JMP STCRC1
;
.REG_LOAD: 
 CMP #$FF       ;WW3 FORMAT?
 BNE LOAD_WW1_EN;NO, GO WW1/2
 LDX #$00
.LOOP:
 JSR CHRIN      ;THROW AWAY 255 TABS
; LDA $90
; BNE STCRC1    ;NO ERROR TESTING!
 DEX
 BNE .LOOP
;
LOAD_WW3:
;
 JSR CHRIN      ;GET CHAR
 JSR CM_LINE
 JSR STCRCK     ;STORE & CHECK
 BCC LOAD_WW3 
 RTS
;
LOAD_WW1_EN:
 PHA
 JSR CLRCHN
 LDX #11
 JSR PRKECY     ;GET WW1, DM REPORT, OR PETASCII
 STA POINTER2+1 ;HB OF POINTER2 SHOWS FORMAT
 JSR CHNL2I
 PLA
 JMP FIRST_ENTRY        ;START 1ST LETTER
;
LOAD_WW1:
 JSR CHRIN ;GET CHAR
;LOAD_WW1_EN:
FIRST_ENTRY:
 LDX POINTER2+1
 CPX #'P'               ;PETASCII?
 BNE .TL_2              ;NO, TEST DM2
;
 CMP #$0D
 BEQ .FIX_RET
 CMP #95
 BNE .TL_2A
.FIX_RET:
 LDA #$FF
 BNE .TL_2A
;
.TL_2: 
 CPX #'D'
 BNE .TL_3
.TL_2A:
 JSR XLATE              ;WILL DO NEAT THINGS ON SCREEN
;
.TL_3:
 CMP #$FC               ;TRANSLATE ABOVE
 BCC LOADR5
 SBC #$FC               ;MAKE 0..3
 TAX
 LDA NWCODS,X
;
 CMP #$FC		;OLD "DELIMETER"?
 BEQ LOADR5		;DON'T PUT A SPACE BEFORE
;
 PHA			;SAVE OFF EOL CHARACTER
 LDA $90		;PICK UP STATUS
 PHA			;STORE IT
 LDA #0
 STA $90		;CLEAR STATUS
 LDA #' ' 
 JSR STCRCK		;STORE SPACE
 PLA			;RESTORE STATUS
 STA $90		;TO VAR
 PLA			;RESTORE CHAR
;
LOADR5:
 JSR CM_LINE
 BCS .OUT0822 
 JSR STCRCK
 BCC LOAD_WW1
.OUT0822:
 RTS
;
;
STCRCK:
 LDY #0
;
 LDX POINTER+1    ;FORMAT?
 CPX #$FE         ;WW4?
 BEQ STORE1       ;SKIP ALL THIS
;
 CMP #SRETRN    
 BNE .CHECK_ATTS   ;IF NOT SOFT RETURN TRY ATTRIBUTES
 LDX #' '          ;PUT OUT SPACE AND SOFT RETURN
 JSR STORE_X_EOT_INC
;
.CHECK_ATTS:
 CMP #ENDREC 
 BEQ STORE1       ;RETURNS ARE NOT ATTS
 BCC .ON_OR_OFF    ;NORMAL CHARACTER
 LDX POINTER2
 BEQ STORE1       ;ATTS NOT ON, FOUND RETURN
 LDX #'U'-'@'+$80  ;OFF CODE
 JSR STORE_X_EOT_INC
 LDX #0
 STX POINTER2
 BEQ STORE1       ;STORE RETURN
;
;
.ON_OR_OFF:
 LDX POINTER2      ;ARE WE LOOKING FOR OFF
 BNE .OFF_CODE
;
 TAX
 BPL .NO_ADJUST    ;LOOKING FOR ON CODE
 INC POINTER2 
 LDX #'U'+$80      ;ON CODE
 BNE .STORE  
;
.OFF_CODE:
 TAX
 BMI .NO_ADJUST    ;DIDN'T FIND OFF
 DEC POINTER2      ;FOUND OFF CODE
 LDX #'U'-'@'+$80  ;OFF CODE
.STORE:
 JSR STORE_X_EOT_INC
;
.NO_ADJUST:
 CMP #$FC
 BCS STORE1
 AND #$7F       ;KILL HB
STORE1:
 LDY #0
 STA (EOT),Y    ;PUT CHAR IN TEXT
 CMP #ENDT      ;LAST?
 BEQ LOAD_OUT   ;GO QUIT IF SO
 LDX $90        ;STATUS?
 BEQ STCRC2     ;STATUS OK
STCRC1:
 LDA #ENDT
; BNE STCRCK     ;PUT IT OUT
 BNE STORE1
;
STCRC2:
 JSR INCEO1     ;EOT + 1
;
 SEC
 LDA HIMEM+1
 SBC EOT+1
 TAX
 BNE .MEM_LEFT
 LDA HIMEM
 SBC EOT
 CMP #10
 BCC STCRC1
;
.MEM_LEFT:
 CLC
 RTS
;
LOAD_OUT:
 SEC 
; PLA
; PLA ;NO RETURN ADDR
 RTS
;
STORE_X_EOT_INC:
 PHA
 TXA
 STA (EOT),Y
; JSR INCEO1
; PLA
; RTS
;*NOTE* WAS JSR INCEO1/ PLA/ RTS
 PLA
 JMP INCEO1
;
;
NWCODS:
!byte $FC,$FC,$FD,$FF
;
CM_LINE:
 CMP #CMARK
 BNE .OUT0928       ;NOT A CMARK LINE
;
 JSR STCRCK     ;PLACE CHECKMARK
 BCS .OUT0928       ;IF ERROR,EXIT CS
;
.NUM_LOOP:
 JSR CHRIN      ;GET 2ND CHAR
 CMP #$FC
 BCS .A_OUT_DONE
 PHA 
 JSR CHKNUM
 PLA
 BCS .LETTER
;
; PHA
; LDA #'M'-'@'
; JSR STCRCK
; PLA
 LDX #'M'-'@'
 JMP STORE_X_EOT_INC
;
.LETTER:
 AND #$3F       ;UPPER/LOWER/RVS WILL ALL DO
 CMP #'C'-64    ;IS THIS 'C'
 BNE .H_F
 LDX #'*' 
 JMP STORE_X_EOT_INC
;
.H_F:
 JSR STCRCK
 BCS .OUT0928
 JSR CHRIN   ;KILL 2ND
 JMP CHRIN
;
.A_OUT_DONE:
 JMP STCRCK     ;USUALLY CS
.OUT0928:
 CLC
 RTS
;
INCTE2:
 JSR INCTE1
INCTE1:
 INC TEXT
 BNE INCTE3
 INC TEXT+1
INCTE3 RTS
;
;
COPYDN:
; INC EOT+1
; JSR MVEOMH
 SEC ;ACTUALLYEOT-MOVEHI
 LDA EOT ;TO TEMP0
 SBC MOVEHI
 STA TEMP0
 LDA EOT+1
 SBC MOVEHI+1
; STA TEMP1
;
COPYD3:
 LDY #0
; LDX TEMP1 ;PAGES
 TAX
 BEQ COPYD1
COPYD2:
 LDA (MOVEHI),Y
 STA (MOVELO),Y
 INY
 BNE COPYD2
 INC MOVELO+1
 INC MOVEHI+1
 DEX               ;PAGES TO MOVE ADDITION
 BNE COPYD2        ;DO MORE ADDITION
COPYD1 LDX TEMP0   ;CHARS
 INX
COPYD6:
 LDA (MOVEHI),Y
 STA (MOVELO),Y
 INC MOVEHI
 BNE COPYD4
 INC MOVEHI+1 ;SIXTEEN BIT
COPYD4:
;# INLINE
; JSR INCML1
 INC MOVELO
 BNE COPYD5
 INC MOVELO+1 
;
COPYD5:
 DEX
 BNE COPYD6
; DEC EOT+1
COPEXT:
 RTS
;
CLR_CHNL2I:
 JSR CLRCHN	;CLEAR THE CHANNELS
CHNL2I:
 LDX #2
 JMP CHKIN 	;CHNL IN
;
;
PAGNUM:
;
 LDX #PW_START_PAGE
 JSR GET_PRINT_WINDOW_NUMBER
 RTS
;
DECEO1:
 LDA EOT
 BNE DECEO2
 DEC EOT+1
DECEO2:
 DEC EOT
 RTS
;
;
;
RETOUT:
;
 LDX BIGGEST_POINTSIZE  ;PUT OUT BP
RETOUT_X:
;OR .X
; SEC                    ;DEC PRTLIN
; LDA PRTLIN
; DB $E9         ;SBC #00
;RET_SM1:
; DB $00
; STA PRTLIN
 CPX PRTLIN             ;IF .X(BP) < PRTLIN, SEND OUT .X. PRTLIN -=X
 BCC .BP_OUT            ;ELSE, IF PRTLIN >= .X(BP)
 LDX PRTLIN             ;SEND OUT PRTLIN CR'S, PRTLIN -= PRTLIN
.BP_OUT:
 STX RET_SM1            ;OR .X
 SEC                    ;DEC PRTLIN
 LDA PRTLIN
!byte $E9;SBC #00
RET_SM1:
!byte $00
 STA PRTLIN
;
.BP_OUT1070:
 JMP PXCRLF
;
;
PETASC:
 CMP #32
 BCC PETAS1
 CMP #$40
 BCC PETAS4
 CMP #$5B
 BCC PETAS3
 CMP #$60 ;TEST THIS
 BCC PETAS3
;
 CMP #$C0
 BCC PETAS1 ;BAD
 CMP #$DB
 BCS PETAS1 ;BAD
 AND #$7F
PETAS2:
 BNE PETAS4
PETAS3:
 AND #$3F
PETAS4:
 CLC
 RTS
PETAS1:
 SEC
 RTS
;
;
!if  REMOVE_TEXT { 
DRAWOUT:
;CS DRAW 'OUTLINER'
;CC DRAW '        '
;	  DATABASE
 LDX #7 		;'OUTLINER' LENGTH
DRAW_DB:
 LDY #7
DRAWOU1:
 BCC DRAWOU2 ;SPACES
; LDA OUTMSG,X ;GET CHAR
 LDA DB_OUT_TEXT,X
 BCS DRAWOU3
DRAWOU2:
 LDA #' '
DRAWOU3:
 STA HEADOT,Y
 DEX
 DEY
 BPL DRAWOU1
 RTS
} 
;
DRAWOUT:
;CS DRAW 'OUTLINER'
;CC DRAW '        '
;	  DATABASE
 LDX #7 		;'OUTLINER' LENGTH
DRAW_DB:		;PASS .X DB LENGTH
 LDY #7
 LDA #' '		;ASSUME SPACE
DRAWOU1:
 BCC DRAWOU3 		;SPACES
 LDA DB_OUT_TEXT,X
DRAWOU3:
 STA HEADOT,Y
 DEX
 DEY
 BPL DRAWOU1
 BCS .TEXT
 LDA #'6'
 STA HEADOT
.TEXT:
 RTS
;
;
CURSONOFF:
;TOGGLE HI BIT OF VIDEO,X
 LDA VIDEO,X
 EOR #$80
 STA VIDEO,X
 RTS
;
INPUTDEL:
;DELETE FOR INPUT
;.Y UNTOUCHED
 LDA ISTRLEN ;DO WE HAVE A STRING?
 CMP #1
 BCC INPDELET5 ;NOT ENOUGH CHARS, ABORT
 DEC ISTRLEN ;NOW ONE LESS
;
 CPX #0 ;ARE WE ON LEFT MARGIN?
 BEQ INPDELET1 ;PULL ALL FROM RIGHT
 DEX ;AIM TO KILL PREVIOUS CHAR
INPDELET1:
 STX TEMP3 ;SAVE CURRENT .X POSITION
INPDELET2:
 LDA VIDEO+1,X
 STA VIDEO,X
 LDA INPBUF+1,X
 STA INPBUF,X
 INX
 CPX ISTRLEN ;ARE WE POINTED AT LAST CHAR?
 BCC INPDELET2 ;NO, MOVE MORE
;
 LDA #' '
 STA VIDEO+1,X ;CLEAR OFF LAST CHAR
 STA VIDEO,X
 LDX ISTRLEN
 LDX TEMP3
;
INPDELET5:
 RTS
;
INPINSERT:
;INSERT IN INPUT MODE
 STX TEMP3 ;SAVE OFF CURRENT .X
 LDX MSLEN
 DEX ;GET POSSIBLE LEN-1
INPINSER1:
 LDA VIDEO,X
 STA VIDEO+1,X
 LDA INPBUF,X
 STA INPBUF+1,X
 DEX
 BMI INPINSER1A 
 CPX TEMP3 ;BACK DOWN TO (AND INCLUDING) OLD POSITION
 BCS INPINSER1 ;IF>= DO NEXT CHAR
;
INPINSER1A:
 LDX ISTRLEN
 CPX MSLEN ;WAS OLD LENGTH = MAX?
 BEQ INPINSER2 ;IF SO, DO NOT ADD 1
 INC ISTRLEN ;LEN = LEN + 1
INPINSER2:
 LDX TEMP3 ;GET OLD POSITION
 LDA #' '
 STA VIDEO,X ;CLEAR IT
 RTS
;
;
!eof
;
; PUBLIC BLKSET
; PUBLIC CLINOT
; PUBLIC CLR_CHK_LOAD_FILE
; PUBLIC CLR_CHNL2I
; PUBLIC COPYDN
; PUBLIC DRAW_DB
; PUBLIC DRAWOUT
; PUBLIC FC_TOGINSERT
; PUBLIC INCTE1
; PUBLIC INCTE2
; PUBLIC INPUTS
; PUBLIC LINOUT
; PUBLIC PETASC
; PUBLIC TOGINS0
; EXTERN EDIT_BUFFER_TO_TEXT
; EXTERN FC_CURSOR_DOWN
; EXTERN FC_CURSOR_UP
; EXTERN FC_DELETE_CHAR
; EXTERN FC_DELETE_CHAR_RT
; EXTERN FC_DELETE_WORD
; EXTERN FC_EDIT_BUFFER_TO_TEXT
; EXTERN GO_LEFT_MARGIN
; EXTERN KILL_DOC
; EXTERN LOAD_256_SUPRESS
; EXTERN TESTEN1
; EXTERN FIELD_NAMES
; EXTERN JUSTIFY_TABLE
; EXTERN MAXIMUM_LINES
; EXTERN PRTLMG
; EXTERN SET_PL
; EXTERN SET_VM_ZERO
