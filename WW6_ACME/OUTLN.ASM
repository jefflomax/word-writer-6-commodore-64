;
!zone OUTLN;Outline Processor 6502 9/10 
;
;
;OUTLINER CONSISTS OF FIVE BASIC ROUTINES:
;
;1) DOINDEX-   SET INDEX IN USER'S TEXT IF POSSIBLE
;2) REFORMALL- STEP THRU ALL TEXT AND REFORMAT AS OUTLINE
;   REFORMAT-  REFORMAT FROM START TO SOMEWHERE
;3) UPLEVEL-   MOVE A RANGE OF THE OUTLINE UP ONE LEVEL
;4) DOWNLEVEL  MOVE A RANGE OF THE OUTLINE DOWN ONE LEVEL
;5) REMOVE**   REVIVE A IMPROPERLY FORMED LINE
;
;
;
;
;
; PUBLIC FC_OUTLINE_REFORMAT
;
;
; EXTERN MOVE_TO_COLUMN_A
;
CURRENT_CHAR =  $88
CASEMASK =  $40 ;VALUE TO TURN ON UPPERCASE
;
;WORD WRITER 64 SPECIFIC EQUATES
ENDT =  253
RETN =  $FD ;EOT,SRET,HRET IN WW64
SCREEN =  $77
TEXT =  $7F
TEXPAG =  $7B
OUTVAR =  $B0 ;4 BYTES ZP
;# CONFLICT
OUTVR1 =  $F7 ;4 BYTES ZP
COUNT_DOWN =  $AB
CURFLG =  $34           ;# HARDLY WORTH ZP STATUS
;
;
;
;ROUTINES FROM WORDPROCESSOR:
;
;
;
;
;
;
;VARIABLES
;START_FORM EQU $30 ;POINTER TO BEGIN FOR REFORMAT
;END_FORM   EQU $32 ;POINTER TO END FOR REFORMAT
;INDEX      EQU $34 ;VARIABLE TO INDEX TABLE, ETC.
;LEVEL      EQU $35 ;ROMAN, UPCASE, DEC1, LOCASE, DEC2 (1..5)
;PLACE      EQU $36 ;POSITION A..Z OR 1..99
;LEN        EQU $37 ;LENGTH OF STRING TO PLACE IN TEXT
;T1         EQU $39 ;TEMPORARY BYTE:
;UPCMASK    EQU $3B ;MASK VALUE TO MAKE LOWER CASE UPPER CASE
;PREV_LEVEL EQU $3C ;LAST LEVEL USED IN REFORMAT
;
;OVERLAY JUMP TABLE
OVERLAY_START:			;START OF MODS
;
;
;THESE WILL NORMALLY BE EITHER CLC, RTS OR JUST RTS
;
OV_SET_TO_TOP_PAGE:
 CLC
 RTS
LEN:				;VARIABLS MOVED IN TO FILL SPACES
!byte 0
;
OV_ALLOW_CURSOR_UP:
 CLC
 RTS
UPCMASK:			;VARIABLS MOVED IN TO FILL SPACES
!byte 0
;
OV_DB_PREV_PAGE:
 CLC
 RTS
STUFF_TEXT:			;VARIABLS MOVED IN TO FILL SPACES
!byte 0
;
OV_SHOW_FIELD_NAME:
 RTS				;NEEDS NO STATUS
START_FORM:			;VARIABLS MOVED IN TO FILL SPACES (WORD)
!word 0
;
OVR_FC_SORT_INDEX:		;DOUBLESHOT
 JMP FC_SET_INDEX
;
OVR_FC_DELETE_LINE:		;DOUBLESHOT
 JMP FC_DELETE_LINE
;
OVR_FC_INSERT_LINE:		;DOUBLESHOT
 JMP FC_INSERT_LINE		
;
OV_ADD_EOR:			;DO NOTHING AT ALL
 RTS
!word 0
;
FC_OUTLINE_UPLEVEL:
 JMP OUTLINE_UPLEVEL
;
FC_OUTLINE_DOWNLEVEL:
 JMP OUTLINE_DOWNLEVEL
;
OVR_FC_TAB_FORWARD:
 JMP TAB_FORWARD
;
OVR_FC_FORMAT:			;DOUBLESHOT
 JMP O_FC_FORMAT
;
OVR_FC_FONT_WINDOW:		;DOUBLESHOT
 JMP FC_FONT_WINDOW		 
;
;
;TABLES/VARIABLE IN CODE
;
;INDEXTAB[5] NEXT AVAILABLE PLACE FOR EACH LEVEL
INDEXTAB:
!byte 1,1,1,1,1
;*NOTE* MOVE TO AN RTS FOR EXTRA SAFETY
;DECLARATION FOR COMPILING
;
ENTER_DATABASE_MODE:
EXIT_DATABASE_MODE:
SET_DB_FIELD_NAME:		;DIRECT CALL
ENTER_DB_FIELDS:		;DIRECT
SET_PL:				;DIRECT
SET_VM_ZERO:			;DIRECT
LOAD_256_SUPRESS:		;DIRECT
;
!byte 00;DEAD SPACE IN CASE INIT FOULS
;
VALID:
;LIST OF VALID CHARACTERS X_. ON X
!text " 0123456789IVX"
VALIDE:
;
;TABPOS[5] (CONSTANT) STARTING LOCATION FOR EACH FIELD
;1..6 7..9 10..12 13..15 16..18 (END)
;
TABPOS:
!byte 1,7,10,13,16,19,255
;
MAXLEN =  20 ;LARGEST POSSIBLE POSITION FOR INDEX REQUEST
;
;STRING[7] AREA TO BUILD RIGHT ALIGNED STRING
STRING:
!text "     ."
STRINGE =  *-2 ;RIGHTMOST (EXCEPT PERIOD)
;
SAVEX =  OUTVR1
;
;START_FORM:
; DW 0 ;POINTER TO BEGIN FOR REFORMAT
;MOVED TO JUMP TABLE
END_FORM =  OUTVR1+1
; DW 0 ;POINTER TO END FOR REFORMAT
OL_INDEX =  OUTVAR
; DB 0 ;VARIABLE TO INDEX TABLE, ETC.
LEVEL =  OUTVAR+1
; DB 0 ;ROMAN, UPCASE, DEC1, LOCASE, DEC2 (1..5)
PLACE =  OUTVAR+2
; DB 0 ;POSITION A..Z OR 1..99
;LEN:
; DB 0 			;LENGTH OF STRING TO PLACE IN TEXT
;MOVED TO JUMP TABLE
OL_T1 =  OUTVR1+3
; DB 0 ;TEMPORARY BYTE:
;UPCMASK:
; DB 0 ;MASK VALUE TO MAKE LOWER CASE UPPER CASE
;MOVED TO JUMP TABLE
PREV_LEVEL =  OUTVAR+3
; DB 0 ;LAST LEVEL USED IN REFORMAT
;
;STUFF_TEXT:
; DB 0
;MOVED TO JUMP TABLE
STUFF_CURSOR:
!byte 0
;
;--------------------
;
FC_SET_INDEX:
 LDX OUTMODE
 BEQ .ABORT
;
 JSR FC_EDIT_BUFFER_TO_TEXT
 JSR DOINDEX			;TESTEN1
 JSR FC_EDIT_BUFFER_TO_TEXT
 JSR DISPLAYON
 LDX #0               ;1
 STX CURFLG
.ABORT:
 RTS
;
;--------------------
;
DOINDEX:
TESTEN1:
;
 JSR PUSH_TEXT
;
 LDA TEXT
 STA END_FORM
 LDA TEXT+1
 STA END_FORM+1
;
 JSR TREFORM
;
 JSR POP_TEXT
;
 JSR CHECKSPACES ;1..CURSOR ALL SPACES?
 BCS INDEX6 ;NO, MARK THIS LINE BAD
;
 JSR CSRTOLEVEL ;CONVERT CURSOR POSITON TO LEVEL
;
;VALID LEVEL IS ANY 1..PREV_LEVEL+1
;
 LDX PREV_LEVEL ;LAST LEVEL USED BY REFORMAT
 INX ;LEVEL + 1
;
 CPX LEVEL ;COMPARE WITH REQUESTED LEVEL
;BCC INDEX4 ;LESS THAN IS OK
;BEQ INDEX4 ;EQUAL IS OK
 BCS INDEX4
;
;IF NOT LESS OR EQUAL MUST BE NEXT FIELD, UNLESS
;(PREV_LEVEL+1) IS SIX, IT MUST STAY FIVE
;
 CPX #6
 BNE INDEX2 ;5 OR LESS, OK
 DEX ;NOW 5
INDEX2:
 STX LEVEL
;
INDEX4:
 LDX LEVEL
 LDA TABPOS-1,X
 JSR SETCURSOR ;SET CURSOR POSITION TO .A
;
 LDX LEVEL ;GET LEVEL #
 LDA INDEXTAB-1,X ;.A = PLACE VALUE FOR THIS LINE
 STA PLACE 
;
 JSR MAKESTRING ;CONVERT LEVEL,PLACE TO STRING
 LDA #0
 STA STUFF_TEXT
 JSR WRITESTRING ;WRITE STRING INTO TEXT AT CURRENT CURSOR POSITION
;
 LDX LEVEL
 INX ;POINT AT NEXT "LEVEL" (2..6)
 LDA TABPOS-1,X
 CLC
 ADC #1 ;GIVE ONE BLANK SPACE AFTER INDEX
 JMP SETCURSOR ;SET USER TO ENTER HIS JUNK
;
INDEX6:
;'BAD' LINE FOUND
 JSR FC_BEGINNING_OF_LINE ;SET CURSOR TO BEGINNING OF LINE
 LDA #'*' ;ASTERISK MEANS A NO NO
; JSR STORELT ;STORE LETTER IN TEXT
 JSR WORK_KEY
 LDA #'*'
; JMP STORELT ;STORE LETTER IN TEXT
 JMP WORK_KEY
;
;
;
CHECKSPACES:
;
;SEE IF TEXT[1..CURSOR] = SPACES
;
; JSR CURSORP ;LDA CURSOR POSITON
;#
 LDA ACTUAL_COLUMN
 CMP #MAXLEN+1
 BCS COUNTS6 ;CURSOR IS OUT OF RANGE
;
 TAY
 BEQ CHECKS1 ;IF 1ST DO NOT LOOK BACK
 DEY ;IF TEXT,0..TEXT,Y
 STY OL_T1 ;SAFE PLACE FOR NOW
; BEQ CHECKS1 ;IF ON 1ST CHAR DO NOT LOOK BACK
;DOES NOT WORK COL 1
; JSR TLINBEGIN ;MOVE TEXT TO START OF LINE -DO NOT HARM CURSOR
;# REMOVED
;
CHECKS1:
 LDY OL_T1
 LDX #1
;
COUNTS2:
 LDA (TEXT),Y 
 CMP #ENDT      ;RET CODE?
 BCS COUNTS3
 CMP #$80
 BCS COUNTS4
 CMP #' '
 BEQ COUNTS4 ;SPACE, OK
COUNTS3:
 LDX #0 ;NO! NON SPACE
COUNTS4:
 DEY
 BPL COUNTS2 
;
 CPX #1
 BEQ CHECKS8
 SEC
COUNTS6:
 RTS       
CHECKS8:
 CLC
 RTS
;
;
;
CSRTOLEVEL:
;CONVERT CURSOR POSITON TO LEVEL
;
 LDA ACTUAL_COLUMN
; JSR CURSORP ;.A = CURSOR POSITION
;
ATOLEVEL:
;CONVERT .A TO LEVEL
 TAX
 LDA LEVELTAB-1,X
 STA LEVEL
 RTS
;
LEVELTAB:
;LEVEL FOR EACH POSSIBLE CURSOR POSITION
!byte 1,1,1,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,5,5
;    1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;
SETCURSOR:
;SET CURSOR POSITION TO .A IN CURRENT LINE
;
 PHA
;1-19-89
; JSR TEXT_TO_EDIT_BUFFER
 JSR FC_BEGINNING_OF_LINE
 PLA
 CMP #$2
 BCC .OUT
;
 JMP MOVE_TO_COLUMN_A
.OUT:
 RTS
;
; STA T1 ;COUNTER (1..N)
;SETCURS1:
; DEC T1 ;(0..N-1)
; BEQ SETCURS2
; JSR FC_CURSOR_RIGHT ;CURSOR RIGHT
; JMP SETCURS1
;SETCURS2:
; RTS
;
;MAKESTRING  USING LEVEL AND PLACE  AS INPUTS, CREATE
;(LEVEL,PLACE)A STRING, RIGHT ALIGNED, OF LENGTH LEN IN
;             STRING TO BE COPIED INTO TEXT.
;
MAKESTRING:
;
 JSR CLEARSTRING ;FILL STRING WITH _______.
 LDA PLACE ;VALUE TO CONVERT
 LDX LEVEL ;LEVEL (1..5)
 INC INDEXTAB-1,X ;INCREMENT FOR NEXT TIME (0..4)
;
 LDY #0
 STY UPCMASK ;UPPER CASE MASK
;
 LDY #3 ;
 STY LEN ;LENGTH OF ALL BUT ROMAN
;
 CPX #3 ;IS THIS DECIMAL?
 BEQ DECIMAL
 CPX #5 ;SECOND DECIMAL?
 BNE MAKESTRIN0
 LDY #')' ;SPECIAL CASE FOR RIGHT PAREN
 STY STRINGE+1 ;NEW END
 BNE DECIMAL
MAKESTRIN0:
 CPX #1 ;ROMAN?
 BEQ ROMAN
;EITHER UPCASE OR LOCASE HERE
 CPX #4 ;LO CASE?
 BEQ ALPHA
 LDY #CASEMASK   
 STY UPCMASK
;
ALPHA:
;MAKE PLACE A. TO Z. OR *.
;
 CMP #27 ;IS IT TOO BIG?
 BCS TWOAST ;YES, GIVE TWO ASTERISKS
 STA STRINGE ;STRING CREATED
ALPHA1:
 RTS
;
DECIMAL:
;MAKE .A  1. TO 99. OR **.
 CMP #100 ;IS IT TOO BIG?
 BCS TWOAST ;YES, GIVE TWO ASTERISKS
;
 JSR AXASCII ;.A = ONES ASCII, .X = TENS ASCII
 STA STRINGE ;ONES PLACE SET
 CPX #'0' ;IS TENS PLACE NEEDED?
 BEQ ALPHA1 ;NO, LEAVE
 STX STRINGE-1 ;SET TENS PLACE
 RTS
;
TWOAST:
;THE FOOL HAS GONE AND MADE TOO DEEP A LEVEL
;STICK IT TO HIM.
 LDA #'*' 
 STA STRINGE
 STA STRINGE-1
 RTS
;
ROMAN:
;
 LDY #6
 STY LEN ;LENGTH OF A ROMAN IS ALWAYS 10
;
 CMP #27 ;IS VALUE TOO BIG?
 BCS TWOAST ;YES, CONVERT TO ASTERISKS
;
 LDY #STRINGE-STRING ;SET INDEX TO NEXT STRING POSITION
 LDX #0
ROMAN1:
 CMP #$A
 BCC ROMAN2
 SBC #$A
 INX
 BNE ROMAN1 ;ISOLATE ONES
;
ROMAN2:
 STX OL_T1 ;SAVE OFF TENS PLACE FOR LATER USE
;
 CMP #0 ;IF ONES = ZERO
 BEQ ROMAN8 ;GO HANDLE TENS PLACE
;
 CMP #4
 BCS ROMAN4 ;GO 4..9
;WE HAVE 1..3
ROMAN3:
 JSR ROMAIS ;WRITE .A I'S
 JMP ROMAN8 ;GO HANDLE TENS PLACE
;
ROMAN4:
 CMP #4 ;IS THIS 4?
 BNE ROMAN5 ;TRY 5..9
 JSR ROMSETV ;WRITE A V
 LDA #1
 BNE ROMAN3 ;AND A I AND THEN TENS
;
ROMAN5:
 CMP #9
 BCS ROMAN7 ;TRY 9..9
 CMP #5 ;IS THIS EXACTLY 5?
 BEQ ROMAN6 ;SEND JUST V
 SEC ;THIS SHOULD NOT BE NEEDED
 SBC #5 ;6..8 -> 1..3
 JSR ROMAIS ;WRITE .A I'S
ROMAN6:
 JSR ROMSETV ;WRITE V
 JMP ROMAN8 ;GO HANDLE TENS PLACE
;
ROMAN7: 
;FINALLY 9 A REAL SPECIAL CASE
 LDX #1
 JSR ROMSETX ;WRITE ONE X
 LDA #'I'
 STA STRING,Y
 DEY
;
ROMAN8:
;HANDLE TENS PLACE
 LDX OL_T1 ;#TENS 0..2
 BEQ ROMAN10
ROMSETX:
 LDA #'X'
ROMAN9:
 STA STRING,Y
 DEY
 DEX
 BNE ROMAN9
;
ROMAN10:
 RTS
;
ROMAIS:
;SET .A I'S INTO STRING
 TAX ;1..N
 LDA #'I' 
ROMAIS1:
 STA STRING,Y
 DEY
 DEX
 BNE ROMAIS1
 RTS
;
ROMSETV:
;SET A V IN STRING
;UNHARMED .A
 PHA
 LDA #'V'
 STA STRING,Y
 DEY
 PLA
 RTS
;
WRITESTRING:
;
;STRING IS RIGHT ALIGNED, LENGTH LEN
;
 LDA #STRINGE+1-STRING+1 ;TOTAL LENGTH OF STRING
 SEC
 SBC LEN
 TAX
 STX SAVEX ;DEFINATLY SAFE X STORAGE
WRITES1:
 LDX SAVEX
 LDA STRING,X
 PHA ;CHECK FOR . OR )
 AND #%00110000 ;TEST FOR SYMBOL (!..)) ONLY
 CMP #%00100000 ;SYMBOL = 10 BITS 5..4
 BEQ WRITES2 ;YES, RESTORE SYMBOL AND GO ON
 PLA
 ORA UPCMASK ;TURN ON HI BIT IF UPCASE
 BNE WRITES3 ;BRA
WRITES2:
 PLA
WRITES3:
; JSR STORELT ;PUT CHARACTER IN TEXT
 LDX STUFF_TEXT
 BEQ .REG_STORE
;
 LDY STUFF_CURSOR
 STA (TEXT),Y
 INC STUFF_CURSOR
 BNE .SKP
;
.REG_STORE:
 JSR WORK_KEY
.SKP:
 LDX SAVEX
 INC SAVEX
 CPX #STRINGE+1-STRING ;0..5 = 6
 BCC WRITES1 ;LOOP THRU STRING
;
 RTS
;
CLEARSTRING:
;SET STRING = _____.
 LDA #'.'
 STA STRINGE+1
 LDY #STRINGE-STRING
 LDA #' '
CLEARS1:
 STA STRING,Y
 DEY
 BPL CLEARS1
 RTS
;
REFORMAT:
;
;THIS ROUTINE REFORMATS THE DOCUMENT FROM START_FORM TO END_FORM
;IT REQUIRES THAT ALL SCREEN ORIENTED VARIABLES BE SAVED OFF AND
;THAT SCREEN DISPLAY BE DISABLED.  IN WW64, THIS IS NO FUN.
;
; LDA TEXT
; PHA
; LDA TEXT+1
; PHA
 JSR PUSH_TEXT
;
;
 LDA START_FORM
 STA TEXT
 LDA START_FORM+1
 STA TEXT+1
;
;SAVE OTHER VIDEO, COLUMN, COUNT, TEXTMO, SCRMO, LINE, PAGE, ETC
;
 JSR DISPLAYOFF ;DISABLE ANY SCREEN CHANGES
;
 LDX #1
 STX PREV_LEVEL ;LAST LEVEL (1..5) USED
 DEX ;[0]
 JSR INITINDEX ;INDEXTAB[X+1..5] = 1
;
REFORM1:
;SEE IF THIS IS BEYOND "LAST LINE"
 LDA TEXT+1
 CMP END_FORM+1
 BCC REFORM5 ;REFORMAT THIS LINE
 BEQ REFORM3 ;TEST LO BYTES
 BCS REFORM10 ;QUIT REFORMAT
;
REFORM3:
 LDA TEXT
 CMP END_FORM
;BCC REFORM5 ;REFORMAT THIS LINE
 BCS REFORM10 ;QUIT REFORMAT
;
REFORM5:
;POSITION IS OK, HOW ABOUT LINE?
;JSR ALLBLANK ;IF LINE IS ALL SPACES, DO NEXT LINE
;BCS REFORM9  ;GO DO THE NEXT LINE
;
 LDY #0 
 LDA (TEXT),Y
 CMP #'*' ;IS 1ST CHARACTER BAD LINE MARKER?
 BEQ REFORM9  ;GO DO NEXT LINE (SHOULD MARK THIS LINE)
;
 JSR COUNTSPACES
 BCS REFORM9  ;TOO MANY SPACES OR SOME OTHER ERROR, NEXT LINE
;
;
 STA LEVEL ;SAVE .A
 LDX #5 ;PLACE TO SEARCH
REFORM5A:
 LDA (TEXT),Y
 CMP #'.'
 BEQ REFORM5B
 CMP #')'
 BEQ REFORM5B
 INY
 DEX
 BNE REFORM5A
 BEQ REFORM9 ;NOT PROPER FIELD, QUIT LINE
REFORM5B:
;
;TWO TO THE LEFT OF DECIMAL MUST = SPACE, 0..9, OR IVX
;OR THIS IS NOT VALID
 DEY
 DEY
 LDA (TEXT),Y
 LDY #VALIDE-VALID
REFORM5C:
 CMP VALID,Y
 BEQ REFORM5D
 DEY
 BPL REFORM5C
 BMI REFORM9 ;NOT PROPER FILES, QUIT LINE
REFORM5D:
;VALID CHARACTER FOUND.
;
 LDA LEVEL ;TEMP--NOT REALLY LEVEL
;
 JSR ATOLEVEL ;CONVERT .A TO LEVEL (1..5)
;
;VALID LEVEL IS ANY 1..PREV_LEVEL+1
;
 LDX PREV_LEVEL ;LAST LEVEL USED BY REFORMAT
 INX ;LEVEL + 1
;
 CPX LEVEL ;COMPARE WITH REQUESTED LEVEL
; BCC INDEX4 ;LESS THAN IS OK
; BEQ INDEX4 ;EQUAL IS OK
 BCS REFORM6 ;INDEX4
;
;IF NOT LESS OR EQUAL MUST BE NEXT FIELD, THIS
;INDEX IS INVALID.  TAG LINE '**' AND PROCEED
;
 JSR INDEX6 ;DRAW ** AT BEGINNING OF LINE
 JMP REFORM9 ;DO NEXT LINE
;
;
REFORM6:
;
 LDX LEVEL
 LDA TABPOS-1,X
; JSR SETCURSOR ;SET CURSOR TO POSITION .A
 STA STUFF_CURSOR     ;LINE POSITION FOR DIRECT STORE
 DEC STUFF_CURSOR
;
 LDA LEVEL ;IF LEVEL IS >= PREVIOUS LEVEL DO NOTHING
 CMP PREV_LEVEL 
 BCS REFORM7
;
 TAX ;OTHERWISE, SET INDEXTAB[LEVEL+1..END] = 1
 JSR INITINDEX ;SO FUTURE SUB-LEVELS START AT BEGINNING
;
REFORM7:
;
 LDX LEVEL
 STX PREV_LEVEL ;SET PREVIOUS LEVEL TO CURRENT
 LDA INDEXTAB-1,X
 STA PLACE ;LEVEL,PLACE SET FOR MAKESTRING
 JSR MAKESTRING
 LDA #1
 STA STUFF_TEXT
 JSR WRITESTRING ;PUT NEW INDEX ON TOP OF OLD ONE
;
REFORM9:              
;DO NEXT LINE
 JSR TEXT_TO_NEXTLINE
 JMP REFORM1 ;DO NEXT LINE IF APPROPRIATE
;
REFORM10:
;
;DONE, NOW RESTORE ALL SAVED STUFF AND SCREEN
;
;PULLWD TEXT
; PLA
; STA TEXT+1
; PLA
; STA TEXT
 JSR POP_TEXT
;
;RESTORE OTHER VIDEO, COLUMN, COUNT, TEXTMO, SCRMO, LINE, PAGE, ETC
;
 JMP DISPLAYON ;RE-ENABLE (&REFREASH) DISPLAY
;
;
;UPLEVEL
;MOVE UP CURRENT LEVEL (UNLESS ROMAN(1)) AND ALL SUBORDINATE
;LEVELS UNTIL NEXT OCCURANCE OF CURRENT LEVEL OR LESS IS FOUND
;(SKIP BLANK LINES)
;
TESTEN2:
OUTLINE_UPLEVEL:
UPLEVEL:
;
 LDX OUTMODE
 BNE .IN_MODE
 RTS
;
.IN_MODE:
 JSR FC_BEGINNING_OF_LINE ;MOVE TEXT (AND CURSOR) TO START OF THIS LINE
;
;PUSHWD TEXT
; LDA TEXT
; PHA
; LDA TEXT+1
; PHA
;
 JSR DISPLAYOFF
;
 LDA #$00
 STA COUNT_DOWN
 STA PREV_LEVEL
;
UPLEVEL1:
 JSR COUNTSPACES
 BCS DOWNLEVEL10   ;ILLEGAL SIZE ON 1ST LINE, EXIT
 CMP #7
 BCC DOWNLEVEL10 
;
UPLEVEL1A:
 JSR ATOLEVEL      ;LEVEL KNOWN
;
;LDA LEVEL
 CMP #1
 BEQ UPLEVEL4      ;CANNOT UPLEVEL LEVEL #1, EXIT
;
 CMP PREV_LEVEL ;IS CURRENT LEVEL <= PREV_LEVEL
 BCC UPLEVEL4 ;WE ARE DONE
 BEQ UPLEVEL4 ;WE ARE DONE
;
 LDX PREV_LEVEL ;IS THIS FIRST PASS?
 BNE UPLEVEL2 ;IF =0 THEN STORE 1ST LEVEL, ELSE NOT.
 STA PREV_LEVEL ;ONLY 1ST PASS
;
UPLEVEL2:
 JSR DELETE3 ;DELETE THREE SPACES FROM THIS LINE
UPLEVEL3: ;ADD
 JSR FC_CURSOR_DOWN
 BCS UPLEVEL4
 JSR FC_BEGINNING_OF_LINE
 INC COUNT_DOWN
; JSR TEXT_TO_NEXTLINE ;ADV TO NEXT LINE
; JSR TEXCF0 ;IS CURRENT CHAR THE END OF TEXT?
;BEQ UPLEVEL4
;
 BEQ UPLEVEL4 ;ADD
 JSR COUNTSPACES ;ADD
 BCC UPLEVEL1A ;ADD (RVS)
 BCS UPLEVEL3 ;ADD
;BNE UPLEVEL1 ;RESET NEXT LINE
;
UPLEVEL4:
DOWNLEVEL8:
;
;REFORMAT ALWAYS BEGINS AT START-OF-TEXT
;
; LDA END_OF_TEXT
; STA END_FORM
; LDA END_OF_TEXT+1
; STA END_FORM+1
;
;(TREFORM ASSUMES END_FORM IS SET, SETS START_FORM = STARTTEXT)
; JSR TREFORM
 JSR REFORMALL ;REFORMAT WHOLE DOCUMENT
;
DOWNLEVEL9:
;PULLWD TEXT
; PLA
; STA TEXT+1
; PLA
; STA TEXT
;
; LDA #0
; STA COLUMN
; STA COUNT
; JSR FC_BEGINNING_OF_LINE ;LEFMGN ;RESET TO 1ST COLUMN
;
 JMP CD_CURSOR_UPS
;
DOWNLEVEL10:
 JMP DISPLAYON ;RESTORE DISPLAY
;
;
DELETE3:
;WE ARE AT THE BEGINNING OF A LINE, PRESS DELETE KEY
;THREE TIMES.  (LINE LINGTH S/B > 3)
;
 JSR FC_DELETE_CHAR
 JSR FC_DELETE_CHAR
 JMP FC_DELETE_CHAR
;
;DOWNLEVEL MOVES EACH LINE FROM CURRENT CURSOR OUT THREE SPACES
;UNTIL IT SEES A LINE HAVING THE SAME LEVEL OF THE FIRST ONE
;
TESTEN3:
DOWNLEVEL:
OUTLINE_DOWNLEVEL:
;
;
 LDX LAST_KEY
 CPX #$B5
 BNE .TEST_MODE
 LDX #58
 JMP SERPP0
;
.TEST_MODE:
 LDX OUTMODE
 BNE .OUT_MODE
.NO_DOWN_LEVEL:
 RTS
;
.OUT_MODE:
 JSR FC_BEGINNING_OF_LINE ;SETS TO REAL 1ST COLUMN
 JSR EDIT_BUFFER_TO_TEXT
; JSR TEXT_TO_EDIT_BUFFER
;
;PUSHWD TEXT & SET END_FORM = TEXT
 LDA TEXT
 STA END_FORM
 PHA
 LDA TEXT+1
 STA END_FORM+1
 PHA                        ;SAVE TEXT LO, HI ON STACK
;
;MOVWD TEXT TO END_FORM
;
;JSR REFORMAT ;FIX INDEXTAB UP TO CURRENT LINE
;(TREFORM ASSUMES END_FORM IS SET, SETS START_FORM = STARTTEXT)
 JSR TREFORM
;
;PULLWD TEXT
 PLA
 STA TEXT+1
 PLA
 STA TEXT ;RESTORE USERS TEXT POSITON
;
;(STACK EMPTY)
;
;PUSHWD TEXT
; LDA TEXT
; PHA
; LDA TEXT+1
; PHA
;
;STACK CONTAINS TEXT
 LDA #0
 STA STUFF_TEXT          ;WILL BE USING ACTUAL ROUTINES
 STA COUNT_DOWN          ;NUMBER OF CURSOR DOWN'S
;
 JSR DISPLAYOFF
;
 JSR COUNTSPACES         ;WHERE IS LEVEL (VALID?)
 BCS DOWNLEVEL10         ;ABORT IF ILLEGAL 1ST LINE
;
 JSR ATOLEVEL            ;LEVEL IS CALCULATED FROM .A
;
;IS THIS LEGAL LEVEL TO PUSH DOWN?
;LAST USED LEVEL IS PREV_LEVEL IF THIS LINE'S
;LEVEL IS NOT <= PREV2_LEVEL, THEN A DOWNLEVEL
;IS ILLEGAL AS IT WILL CREATE A "MISSING LEVEL"
;
; LDX PREV_LEVEL
;
;LDA LEVEL (ALREADY PRESENT)
 CMP PREV_LEVEL
 BEQ DOWNLEVEL1 
;BCC DOWNLEVEL1
 BCS DOWNLEVEL10 ;ILLEGAL FIRST LINE
;
DOWNLEVEL1:
;
;LDA LEVEL
 STA PREV_LEVEL
;
 CMP #1
 BNE DOWNLEVEL2
;
 JSR CLEARSTRING ;STRING = ------.
 LDA #'A'       ;MAKE SMALL INDEX SO IT "PUSHES" WELL
 STA STRINGE
;
 LDA #6
 STA LEN
 JSR WRITESTRING ;MAKE SLIDEABLE 1ST LEVEL
 JSR FC_BEGINNING_OF_LINE
;
DOWNLEVEL2:
;
 JSR INSERT3 ;PLACE THREE SPACES AT START OF LINE
;
DOWNLEVEL4:
;
; JSR TEXT_TO_NEXTLINE ;MOVE TO NEXT LINE
 JSR FC_CURSOR_DOWN
 BCS DOWNLEVEL6
 JSR FC_BEGINNING_OF_LINE
 INC COUNT_DOWN
; JSR TEXCF0 ;ARE WE DONE WITH OUTLINE?
; BEQ DOWNLEVEL6 ;DONE, NOW REFORMAT
;
 JSR COUNTSPACES ;HOW MANY SPACES?
 BCS DOWNLEVEL4 ;IF THIS LINE LOOKS BLANK, TRY NEXT
;
 JSR ATOLEVEL ;CALCUALTE LEVEL FROM .A
;LDA LEVEL (ALREADY PRESENT)
 CMP PREV_LEVEL ;IS THIS THE <= LEVEL WE STARTED ON?
 BCC DOWNLEVEL6 ;IF < ENDSTUFF
;BEQ DOWNLEVEL8
 BEQ DOWNLEVEL6 ;IF = ENDSTUFF
 BNE DOWNLEVEL2 ;OTHERWISE, DO NEXT LINE
;
DOWNLEVEL6:
;
 JMP DOWNLEVEL8 ;THIS IS INSIDE UPLEVEL
;
INSERT3:
 JSR FC_INSERT_CHAR
 JSR FC_INSERT_CHAR
 JMP FC_INSERT_CHAR  
;
INITINDEX:
;INDEXTAB[X+1..5] = 1
 INX
 LDA #1
INITI1:
 STA INDEXTAB-1,X
 INX
 CPX #6 ;PAST END LEVEL
 BCC INITI1
 RTS
;
COUNTSPACES:
;COUNT THE NUMBER OF CHARACTERS UP TO THE 1ST TEXT
;CHAR ON A LINE, CHECK AGAINST MAXLEN
 LDY #0
CNTSPC1:
; LDA (TEXT),Y
; CMP #RETN         ;END OF LINE = ERROR
 JSR TEXCFE
 BCS CNTSPC3       ;EOL = ERROR [CS] FLAGS BAD
;
 CMP #' '
 BNE CNTSPC2       ;1ST NON-SPACE FOUND
 INY
 BNE CNTSPC1       ;LOOK AT NEXT CHARACTER
;
CNTSPC2:
;1ST NON SPACE .Y (0..Y)
 INY               ;(1..N)
 TYA
 CMP #MAXLEN+1     ;LARGEST POSITION TO XLATE
;[CS] IF = OR GREATER THAN MAX
;[CC] IF OK
CNTSPC3:
 RTS
;
;
;KLUDGE!
;--------------------------------
;WORD WRITER 64 SPECIFIC ROUTINES
;--------------------------------
;
O_FC_FORMAT:
 LDX OUTMODE
 BNE FC_OUTLINE_REFORMAT
;
.NORMAL:
 JMP FC_FORCE_FORMAT		;IN EDITLN
;
;
;REFORMALL
; REFORMATS ALL OF DOCUMENT, HOPEFULLY CHANGING "NOTHING"
;
FC_OUTLINE_REFORMAT:
TESTEN4:
 JSR EDIT_BUFFER_TO_TEXT
 JSR FC_BEGINNING_OF_LINE
 JSR REFORMALL
 JSR TEXT_TO_EDIT_BUFFER
 JMP FC_BEGINNING_OF_LINE_DSP
;
REFORMALL:
;
 LDA END_OF_TEXT 
 STA END_FORM
 LDA END_OF_TEXT+1
 STA END_FORM+1
;
TREFORM:
;
;MOVWD STARTTEXT TO START_FORM
;
 LDA STARTTEXT            
 STA START_FORM
 LDA STARTTEXT+1
 STA START_FORM+1 ;SET BEGINNING POINT FOR REFORMAT
;
;PUSHWD TEXPAG
; LDA TEXPAG
; PHA
; LDA TEXPAG+1
; PHA
;
;PUSHWD SCREEN
; LDA SCREEN
; PHA
; LDA SCREEN+1
; PHA
;
;PUSHWD TEXT
; LDA TEXT
; PHA
; LDA TEXT+1
; PHA
 JSR PUSH_TEXT
;
;MOVWD TEXT TO END_FORM
;
 JSR REFORMAT ;FIX INDEXTAB UP TO CURRENT LINE
;
;PULLWD TEXT
; PLA
; STA TEXT+1
; PLA
; STA TEXT ;RESTORE USERS TEXT POSITON
 JSR POP_TEXT
;
;PULLWD SCREEN
; PLA
; STA SCREEN+1
; PLA
; STA SCREEN
;
;PULLWD TEXPAG
; PLA
; STA TEXPAG+1
; PLA
; STA TEXPAG
 JMP RESET
;
;
TAB_FORWARD:
 LDA OUTMODE       	;IN OUTLINER?
 BNE .IN_OUTLINER	;NO ACTUAL TABS ALLOWED IN OUTLINER OR DB
;
; JSR FC_TAB_IN_TEXT
; JSR FIX_ACTUAL_COLUMN
; JMP FC_WRAP_LINE
 JMP FC_TAB_FORWARD_NORMAL
;
.IN_OUTLINER:
 LDX #$FF
 LDA ACTUAL_COLUMN 
.LOOP:
 INX
; CMP TAB_TABLE,X
 CMP TABPOS,X		;LOOK AT OUTLINER TAB TABLE
 BCS .LOOP 
;
; LDA TAB_TABLE,X
 LDA TABPOS,X
 CMP #$FF
; BEQ ?TAB_ABORT
 BEQ CNTSPC3		;RTS
;
!if  0    { 
 BIT INSERTM
 BPL MOVE_TO_COLUMN_A
 SEC
 SBC ACTUAL_COLUMN ;.A HOLDS # COLUMNS TO MOVE
;
 STA COUNT_DOWN
;
.LOOP1:
 LDA #' '
 JSR FC_WORK_KEY
 DEC COUNT_DOWN
 BNE .LOOP1
.TAB_ABORT:
FTF_ABORT:
 RTS
} 
;
;
;*NOTE* THIS IS USED ONLY BY THE OUTLINER NOW!!
;
MOVE_TO_COLUMN_A:
 STA COUNT_DOWN
 INC CURFLG              ;ALLOW EXTEND
;
.LOOP2:
 JSR FC_CURSOR_RIGHT
 LDA ACTUAL_COLUMN
 CMP COUNT_DOWN
 BNE .LOOP2
;
 LDA #0
 STA CURFLG              ;DISALLOW EXTEND
 JMP CHANGED_EDIT_BUFFER
;
; 2019 MOD
!fill 8, $FF
;
!eof
;
; PUBLIC ENTER_DATABASE_MODE
; PUBLIC EXIT_DATABASE_MODE
; PUBLIC SET_DB_FIELD_NAME
; PUBLIC ENTER_DB_FIELDS
; PUBLIC SET_PL
; PUBLIC SET_VM_ZERO
; PUBLIC LOAD_256_SUPRESS
; PUBLIC OVERLAY_START
; PUBLIC OV_ADD_EOR
; PUBLIC OV_ALLOW_CURSOR_UP
; PUBLIC OVR_FC_DELETE_LINE
; PUBLIC OVR_FC_INSERT_LINE
; PUBLIC OVR_FC_FORMAT
; PUBLIC OVR_FC_FONT_WINDOW
; PUBLIC OV_DB_PREV_PAGE
; PUBLIC OV_SET_TO_TOP_PAGE
; PUBLIC OV_SHOW_FIELD_NAME
; PUBLIC OVR_FC_SORT_INDEX
; PUBLIC OVR_FC_TAB_FORWARD
; PUBLIC TESTEN1
; PUBLIC FC_OUTLINE_DOWNLEVEL
; PUBLIC FC_OUTLINE_UPLEVEL
; PUBLIC DOINDEX
; PUBLIC REFORMAT
; PUBLIC TABPOS
; EXTERN GETIN
; EXTERN LAST_KEY
; EXTERN ACTUAL_COLUMN
; EXTERN CD_CURSOR_UPS
; EXTERN CHANGED_EDIT_BUFFER
; EXTERN CHARS_IN_LINE
; EXTERN EDIT_LINE
; EXTERN END_OF_TEXT
; EXTERN FC_CURSOR_DOWN
; EXTERN FC_DELETE_LINE
; EXTERN FC_EDIT_BUFFER_TO_TEXT
; EXTERN FC_FORCE_FORMAT
; EXTERN FC_INSERT_LINE
; EXTERN FC_TAB_FORWARD_NORMAL
; EXTERN ON_LAST_LINE
; EXTERN OUTMODE
; EXTERN PUSH_TEXT
; EXTERN POP_TEXT
; EXTERN STARTTEXT
; EXTERN TEXCF0
; EXTERN TEXCFE
; EXTERN SERPP0
; EXTERN COLUMN
; EXTERN RESET
; EXTERN AXASCII
; EXTERN FC_CURSOR_LEFT
; EXTERN FC_CURSOR_RIGHT
; EXTERN FC_DELETE_CHAR
; EXTERN FC_FONT_WINDOW
; EXTERN DISPLAYON
; EXTERN DISPLAYOFF
; EXTERN EDIT_BUFFER_TO_TEXT
; EXTERN FC_INSERT_CHAR
; EXTERN TEXT_TO_NEXTLINE
; EXTERN FC_BEGINNING_OF_LINE
; EXTERN FC_BEGINNING_OF_LINE_DSP
; EXTERN TEXT_TO_EDIT_BUFFER
; EXTERN WORK_KEY
