;
!zone THESRUS;THESAURUS REX 
;
!SOURCE "WWSETUP.ASM"
;
;TIMEWORKS 6502 THESAURUS--COMMODORE SPECIFIC, USES DIRECT TRACK-
;	SECTOR ACCESS ON 1541 *ONLY*
;	(C)1987 TIMEWORKS -- JEFF LOMAX
;
;
;   GENERAL CALLING SEQUENCE:
;	BE SURE CLSNUM IS ZERO
;	CALL ROUTINE (THESAURUS) WITH APPROPRIATE POINTER TO WORD
;		IF (CS) THEN THE WORD WAS NOT FOUND
;		IF (CC) THEN
;   			PROGRAM WILL RETURN WITH WORD IN WORD BUFFER
;			.X = CLUSTER NUMBER
;
;			MAKE REPEATED CALLS UNTIL (CS) INDICATING
;			LAST WORD XMITTED.
;
;			WATCH .X CAREFULLY FOR CLUSTER NUMBER CHANGES
;
;  		DURING CALLS, NEVER HARM:
;      			MAXWOR   LINDEX   DEVICE   NUMLET
;      			TEMPOR+1 LEN
;
;
;
;
RETRNA =  $4F ;$50
BIIT =  $51 
BITBIN =  $52 
BITROT =  $53 
;
;
;NEEDS:
;* CHECK ERROR FLAG (CS) AFTER ALL INBITS/INLETT
;* CHECK IF DISKETTE IS T-DISK, AFTER OPENS
;* COMPRESS WORD LENGTH S/B 1 LESS
;* CHANGE ALL WORD REFERENCES TO ABSOLUTE
;* PATCH IN WW'S WINDOW ROUTINES CHROUT, ETC
;
; THESAURUS EQUATES/VARIABLES
;
CSIZE =  12 ;NUMBER OF BITS IN A CLUSTER NUMBER
WPLEN =  17 ;NUMBER OF BITS IN A POINTER TO CLUSTER
BC =  17 ;LARGEST POSSIBLE CLUSTER SIZE
;
;VARIABLES
;
P1
!fill   $2, $FF
TS_T1
!fill   $1  , $FF;TEMPOROARY USED FNDLT1,INBITS,
NUMLET
!fill   $1  , $FF;LENGTH OF WORD, NUMBER OF CLUSTERS
TS_LEN
!fill   $1  , $FF;
SO
!fill   $2  , $FF;{ SECTOR OFFSET
PO
!fill   $1  , $FF;} POSITION IN SECTOR
TRACK
!fill   $1  , $FF;ACTUAL TRACK OF DRIVE
SECTOR
!fill   $1  , $FF;ACTUAL SECTOR OF DRIVE
MAXWOR
!fill   $1  , $FF;NUMBER OF WORDS/CLUSTER THIS REGION
MP1
!fill   $3  , $FF;THREE BYTE VALUE FOR MATH #1 (2 SIG)
;
MP2
!fill   $1  , $FF;ONE BYTE POINTER FOR MATH #2
;
LINDEX
!fill   $1  , $FF;POINTS TO NEXT LETTER'S SO,PO IN LETTER
;
TEMPOR
!fill   $3  , $FF;THREE BYTE TEMPORARY FOR MATH
BIIIT
!fill   $1  , $FF;BIT OFFSET IN SECTOR
T2
!fill   $1  , $FF;TEMPORARY USED INBITS,
TS_RESULT
!fill   $3  , $FF;MORE THREE BYTE MATH STUFF
WSO
!fill   $2  , $FF;{ SO OF CURRENT WORD POINTING TO
WPO
!fill   $1  , $FF;} PO OF CURRENT WORD POINTING TO
T3
!fill   $1  , $FF;TEMPORARY USED SENDASC,
T4
!fill   $1  , $FF;TEMPORARY USED SENDASC,
T5
!fill   $1  , $FF;TEMPORARY USED SENDASC,
;
;
;SYSTEM EQUATES/VARIABLES
;
TS_STATUS =  $90
;
;EXAMPLE CALL MODULE
;
; LDA #0
; STA WNDX ;CLEAR POINTER
; STA CLSNUM
;
;
;
THESAURUS:
;
 JSR FLUSH ;CLEAR BITBIN
 STA WNDX ;[0]
;
;GO OFF TO PRESENT WORD IF ALREADY IN LOOKUP MODE
 LDA CLSNUM
 BEQ LOOKUP ;LOOK UP THE WORD OR
 JMP PRESENT ;PRESENT WORDS
;
;
LOOKUP:  
;ASSUME WORD IS AT WORD WITH NULL TERMINATOR
;
 JSR INIDSK 		;OPEN 15,?,15,"I0"
;
 LDA #1
 LDX #<CHANNEL
 LDY #>CHANNEL
 JSR OPNDIC 		;OPEN2,?,2,"#"
;
;VERIFY THESARUS DISK PRESENT
 LDA #18
 STA TRACK
 LDA #0
 STA SECTOR
 LDA #144
 STA PO
 JSR RSECTOR
 JSR POSITON
 LDA #16
 JSR INBITS
 CMP #'H'
 BNE JMWNF
 LDA RETRNA+1
 CMP #'T'
 BNE JMWNF
;
;
 JSR FLUSH
;
 JSR WSTARTT 	;SET START OF TRACK FOR WORD FILE
;
 LDY #0
 LDA WORD,Y 	;RETRIEVE FIRST CHARACTER 1..26 (ASSUME "PERFECT" WORD)
 CMP #'Z'-$40
 BNE .OK 
 CMP WORD+1,Y
 BEQ JMWNF
;
.OK:
 SEC
 SBC #1 	;IF 1..26 -> 0..25
 STA TS_T1  
 ASL 		;.A * 2
 ADC TS_T1
;
 TAX 		;X CONTAINS INDEX TO LETTER TABLE (SO,PO)
;
;LOOK UP EITHER BY 1ST LETTER IF ?..?N OR FROM ?O..?Z
;
 INY 		;[1]
 LDA WORD,Y
 BNE SECNDOK
JMWNF:
 JMP WNF 	;IF SECOND LETTER IS END, WE QUIT!
;
SECNDOK:
 CMP #'O'-64 
 BCC USEFRS 	;USE FIRST LETTER, ?A..?N
;THIS IS ?O..?Z WE WILL USE LETTEO TABLE
 LDA LETTEO,X 
 STA SO
 INX 
;
 LDA LETTEO,X
 STA SO+1
 INX 
;
 LDA LETTEO,X ;LOCATE SO, PO AT START OF LETTER
 STA PO
 JMP USEDSEC
;
USEFRS:
;USE ?A..?N TO FIND WORD (LETTER)
 LDA LETTER,X 
 STA SO
 INX 
;
 LDA LETTER,X
 STA SO+1
 INX 
;
 LDA LETTER,X ;LOCATE SO, PO AT START OF LETTER
 STA PO
;
USEDSEC:
 INX
 STX LINDEX
;
 JSR READSEC ;USE U1 TO READ SECTOR
 JSR POSITON ;SET BUFFER POINTER FOR WORD
;
SEARCHW:
 LDA SO
 STA WSO 
 LDA SO+1
 STA WSO+1
 LDA PO
 STA WPO 	;HOLD POSITION OF CURRENT WORD
;
 LDX LINDEX 	;GET LETTER INDEX
 LDA SO   
 CMP LETTER,X 
 BNE SEARCH1 	;OK, DO SEARCH
 LDA SO+1
 CMP LETTER+1,X 
 BNE SEARCH1 	;SO'S DIFFERENT, DO SEARCH
 LDA PO ;CHECK PO
 CMP LETTER+2,X ;DIFFERENT?
 BEQ WNF 	;NO! THE WORD IS NOT FOUND
;
SEARCH1:
;
 LDA #4 	;SIZE OF [WORDLEN]
 JSR INBITS 	;READ 4 BITS FROM INPUT CHANNEL
 TAX
; .X = NUMBER OF CHARACTERS -1 IN WORD
; 0 = 1 CHAR, WITH 1ST LETTER OMITTED, TOTALS 2.
; INX ;0=1 TO READ
; S/B COMPRESSED FOR 1 LESS ON LENGTH
;
 STX NUMLET 	;NUMBER OF LETTERS
 LDY #1 	;SET UP TO 2ND CHAR AND THRU WORD
;
NXTCHR:
;
 JSR INLETT 	;READ 2ND LETTER
;
; HANDLE DOUBLETS/SPACE/QU
;
 BNE NXTCHR1 	;IF THIS IS ZERO, SUBSTITUTE
;
 LDA #' ' 	;A SPACE AND CHECK
 CMP WORD,Y
 BEQ SAMECR
 BNE WLESS
;
NXTCHR1: 
 CMP #'Q'-64 	;IS THE Q (QU)?
 BNE NXTCHR2
;
 LDA #5 	;QU FLAG
 BNE NXTCHR3 	;TREAT AS DOUBLET
;
NXTCHR2:
 CMP #27 	;IS THIS 1..26
 BCC NXTCHR4 	;TREAT AS NORMAL LETTER
 SBC #27 	;MAKE # 0..4 FOR DOUBLETS
NXTCHR3: 
 JMP TLETVER 	;VERIFY APPROPRIATE TWO LETTER
;
NXTCHR4:
;
 CMP WORD,Y
 BEQ SAMECR
 BCC WLESS 	;TARGET WORD < DISK DATA
;TARGET WORD > DISK DATA
;
; WORD NOT FOUND
;
WNF: 
; LDA #2
; JMP TEXIT
;SHOULD BE JSR CLOSEAL
 JSR CLEARF     
 SEC ;EXIT WITH CARRY SET.
 RTS
;
SAMECR:
 DEC NUMLET
 LDA NUMLET
 BEQ DSKOUT ;THE DISK IS OUT OF CHARACTERS
 INY        ;MOVE TO NEXT MEMORY CHAR
 LDA WORD,Y
; BEQ MEMOUT ;THE MEMORY IS OUT OF CHARACTERS
 BNE NXTCHR ;GO TRY THE NEXT CHARACTER
; RE-ORDER BRANCH
MEMOUT:
; THE MEMORY IS OUT OF CHARACTERS, THE DISK IS NOT.
; THIS MEANS THE WORDS DO NOT MATCH HERE.  WE CAN ASK
; THE USER IF THIS WORD IS OK, OR WE CAN TRY SOME SUFFIX
; ANALYSIS/DELETION.
;
; LDA #3
; JMP TEXIT
 JMP WNF ;FOR NOW, WORD NOT FOUND
;
DSKOUT:
; THE DISK DRIVE HAS RUN OUT OF CHARACTERS IN THIS WORD.
; IS THE MEMORY ALSO OUT?
 INY
 LDA WORD,Y
 BNE MEMCHR ;NO THE MEMORY STILL HAS CHARACTERS.
;
; THE DISK AND THE MEMORY ARE BOTH OUT OF CHARACTERS
; WE HAVE A WINNER!!!
;
 JMP EVALCL ;WORD IS FOUND!!!
;
MEMCHR:
; THE DRIVE IS OUT OF WORD AND THE MEMORY IS NOT
; GO TO NEXT WORD.
; JMP NXTWORD
;
WLESS:
; THE TARGET WORD IS GREATER THAN THE DISK WORD
; GO TO THE NEXT WORD.
; JMP NXTWORD
;
NXTWORD:
;
NXTWORD1:
;MAY EMPLOY FAST NEXT WORD ROUTINE TO ALLOW FOR BYTE
;READ (AFTER CURRENT BIT-BUFFER IS DEPLETED)
;FOR NOW, SIMPLE INBITS.
;
 DEC NUMLET 
 LDA NUMLET
 BMI NXTW2 ;JUST BE SAFE, DO NOT PULL MILLIONS
 BEQ NXTW2 ;THERE ARE NO MORE DISK LETTERS
;
NXTW1:  
;
 JSR INLETT ;READ ALL REMAINING LETTERS
 DEC NUMLET         
 BNE NXTW1    
;
NXTW2:
 LDA #4
 JSR INBITS
;
 STA NUMLET ;NUMBER OF CLUSTERS.
 INC NUMLET ;0..15 -> 1..16
NXTW3:
 LDA #CSIZE  
 JSR INBITS
 DEC NUMLET
 BNE NXTW3  
;
 LDA BIIT ;THESE ARE EXACTLY THE
 BEQ NXTW4         
;
;NUMBER OF BITS IN THE BUFFER.
 JSR INBITS
NXTW4:
;
;IT WOULD BE FASTER HERE TO SIMPLY ZERO
;BIIT AND CALL THE APPROPRIATE ROUTINES TO
;BUMP UP PO
;
 JMP SEARCHW ;GO LOOK AT THE NEXT WORD THEN
;
CPFIL1:
 LDA #4
 JMP TEXIT
;
EVALCL:
;WORD FOUND, FILL TABLE OF CLUSTER POINTERS
;
;EVALUATE THE CLUSTER INFORMATION
;
 LDA #4
 JSR INBITS ;RETRIEVE # OF CLUSTERS
;
 TAX
 INX ;0..15 -> 1..16 (MIN 1 S/B 2..17)
 STX NUMLET ;NUMLET = NUMBER OF CLUSTERS
 STX TS_LEN ;SAVE #CLUSTERS IN PO
;
 LDA #0 ;CLEAR TEMPOR FOR
 STA TEMPOR ;INDEX TO POINTER TABLE
;
CPFILL:
 LDA #CSIZE ;SIZE IS 13 (S/B 12) BITS
 JSR INBITS
 BCS CPFIL1 ;ERROR ON READ
;
 LDX TEMPOR           
 STA CDATA,X
 LDA RETRNA+1
 INX
 STA CDATA,X
 INX
 STX TEMPOR 
;
 DEC TS_LEN ;LEN = NUMLET DEC TO FILL TABLE
 BNE CPFILL ;FILL UP CDATA TABLE
;
;
;BEGIN LOOP TO:
;1) CALCULATE POINTER POSITIONS
;2) FILL POINTER TABLES AND
;3) PRESENT WORDS
;   (NUMLET COUNTS DOWN)
;
 LDA #0 
 STA TS_LEN ;SET INDEX TO START OF CDATA TABLE
;
MAINCL: 
;MAIN CLUSTER/WORD PRESENTATION LOOP
;
 LDX CLSNUM
 CPX NUMLET
;BEQ MAINCL1
 BCC MAINCL1 ;NOT DONE
 JSR CLEARF ;END FILE
;[CS] ON FINAL EXIT
 SEC
 LDX #0
 RTS ;ALL DONE !!!!
;
;
MAINCL1:
 LDX TS_LEN  
 LDA CDATA,X 
 STA P1    
 INX
 LDA CDATA,X
 STA P1+1
 INX
 STX TS_LEN ;WHICH CLUSTER # TO LOOP ON
;
 INC CLSNUM ;CLUSTER # [1..N] BEING PRESENTED
;
 JSR FINDLOC ;RETURN SEEK CLUSTER, MAXWOR = #CHARS
;
 LDX #0 
 STX TEMPOR ;BUMP UP BY TWO'S THRU SO TABLE
;
WPFILL:
;FILL UP SO,PO TABLES OF WORDS FOR THIS CLUSTER
 LDA #9
 JSR INBITS ;.X IS SAFE THRU
 LDY TEMPOR  
 STA PSODATA,Y ;SO OF XTH WORD
 INY
 LDA RETRNA+1
 STA PSODATA,Y ;SO (HI) OF XTH WORD
 INY
 STY TEMPOR ;SET TO NEXT POSITION
;
 LDA #8
 JSR INBITS
;
 STA PPODATA,X ;PO OF XTH WORD
 INX ;0..(MAXWOR-1)
 CPX MAXWOR
 BCC WPFILL ;FILL WORD POINTER TABLE
;
;SEND 1ST WORD TO WORD,Y
;
 LDY #0   
 STY TEMPOR ;INIT 1ST PASS
;
PRESENT: 
;WORD-LOOP FROM JUMP
;
 LDA TEMPOR
 PHA
 TAX
 LDA PSODATA,X
 STA SO 
 INX                                          
 LDA PSODATA,X 
 STA SO+1
 INX
 STX TEMPOR
 PLA
 LSR ;INDEX FOR OTHER TABLE
 TAX
 LDA PPODATA,X
 STA PO ;GET WORD POSITION F/TABLE
;
;
 CPX MAXWOR       
;BEQ WPFILE0
 BCC WPFILE0
;
 JMP MAINCL ;PRESENT THE REST OF THE CLUSTERS
;
;
;SET SO, PO
WPFILE0:
;
 JSR FND1LT ;WHAT IS 1ST LETTER?
 BCS PRESENT ;SAME AS LAST CALL WORD, TRY NEXT
 JSR PUTCHAR ;PLACE CHAR IN WORD BUFFER
;
 JSR FLUSH ;CLEAN OUT BITBIN FOR NEXT READ
;
 JSR WSTARTT ;SET TRACK, SECTOR ON START OF WORD FILE
;
 JSR READSEC ;READ SECTOR SO TO FIND WORD
;
 JSR POSITON ;POSITION AT WORD (LENGTH,FIELD...)
;
 LDA #4
 JSR INBITS
 STA TEMPOR+1 ;TEMPOR+1 IS LENGTH
;
WPFILE1:
 JSR INLETT ;GET A LETTER FROM DISK
 BNE WPFILE2 ;
 LDA #' ' ;WE HAVE A SPACE!
 BNE WPFILE4 ;DO NOT FALL THRU, WILL BE "DOUBLET"
;
WPFILE2: 
 CMP #'Q'-64 ;IS THIS Q CODE?
 BNE WPFILE3
 JSR PUTCHAR ;PUT OUT THE Q
 LDA #'U'-64
;
WPFILE3:
 CMP #27   
 BCC WPFILE4 ;NORMAL LETTER
 SBC #27 
 ASL ;MAKE INDEX TO DOUBLET TABLE
 TAX        
 LDA DOUBLETS,X
 JSR PUTCHAR 
 LDA DOUBLETS+1,X
;
WPFILE4: 
 JSR PUTCHAR
;
 DEC TEMPOR+1
 BNE WPFILE1
;
 LDA #0 
 JSR PUTCHAR 
 LDX CLSNUM
 CLC
 RTS
;
;
FINDLOC: 
;GIVEN CLUSTER NUMBER 0..8192 RETURN SO, PO, BIT
; CREATE #POINTERS DISTANCE INTO FILE IN MP1
; MULTIPLY BY WPLEN FOR NUMBER OF BITS IN FILE
; #BITS / 2048 = SECTOR OFFSET
; #BITS - (SO * 2048) = BITSINSECTOR
; BITSINSECTOR / 8 = POSITION
; BITSINSECTOR AND 111 = BIT OFFSET
; MAXWOR = # WORDS IN CLUSTER
;
;INDEX :     CTOTALS   CNUMPTRS
; 16   :        0         00
; 15   :        X        16*NC
; 14   :       X+Y    16*NC+15*NC
; ...  :       ...        ...
;  1   :        N
;
;ASSUME P1 = CLUSTER NUMBER
;
 LDA #BC ;SILLY SPECIAL CASE FOR 1 17 ENTRY CLUSTER
 STA MAXWOR
;
 JSR CLRMP1 ;MP1 = 000
;
 LDA P1
 ORA P1+1
; CMP #0
 BEQ ABSSTR ;ABSOLUTE BEGINNING,
;
 LDX #BC+2 ;MAXIMUM WORDS/CLUSTER (BC) S/B LARGER 3..N
 STX MAXWOR ;COUNT DOWN
 LDX #$FE ;-2
FLOOP: 
 INX
 INX ;0..2..4..6..
 DEC MAXWOR ;18..1
;
 LDA P1+1
 CMP CTOTALS+1,X
 BEQ FLOO1 ;TEST LO BYTES
 BCS FLOOP ;P1 > #TOTALS ENTRY, NEXT REGION!
 BCC FIRSTR ;P1 < #TOTALS, THIS REGION!
;
FLOO1:
 LDA P1
 CMP CTOTALS,X
 BEQ FLOFIR ;1ST CLUSTER IN REGION, FORCE ZERO
;THEN WE ARE DONE
 BCS FLOOP ;P1 > #TOTALS ENTRY, TRY NEXT REGION
 BCC FIRSTR ;IN PREVIOUS REGION
;
;IF THIS WERE 1ST ELEMENT OF 1ST REGION, PROCESS SEPERATELY
FLOFIR:
;ONLY FOR 1ST ELEMENT IN A REGION
 DEC MAXWOR ;ONE MORE DOWN BECAUSE ON SAME REGION,NOT PAST
 JMP MP1ISF ;AND COMPUTE
;
FIRSTR:
;
;ADJUST .X (2..4..6..8) TO POINT TO PREVIOUS
;REGION.  NOTE THAT 0 IS NOT POSSIBLE DUE TO PREVIOUS
;CHECK FOR P1=0, AND ANY OTHER NUMBER IS OBVIOUSLY
;GREATER.
 DEX
 DEX
;
;CALCULATE NUMBER OF POINTERS THIS REGION
;ACTUAL CLUSTER NUMBER(P1) - TOTAL ENTRIES TO HERE CTOTALS
 SEC 
 LDA P1
 SBC CTOTALS,X 
 STA MP1
 LDA P1+1
 SBC CTOTALS+1,X
 STA MP1+1 ;MP1 = NUMBER OF ENTRIES FROM START OF REGION
;
; LDA MP1
; ORA MP1+1
; CMP #0
; BNE MP1ISF ;(DEBUG) MP1 IS NEVER TO BE ZERO!
; LDA #$8
; JMP TEXIT ;EXIT FLAGGING MP1=1
;
MP1ISF:
;JSR DEC1MP1 ;MP1 = MP1-1 (COUNT TOTALS FROM 0) NO,CLUSTERS
;COUNT FROM 0..N
;
 LDA MAXWOR
 STA MP2
 JSR MP1XMP2 ;MP1 = MP1 * MP2 (16*8)-> (24)
;
;MP1 NOW HOLDS NUMBER OF POINTERS FROM START OF REGION
;
;NOW ADD NUMPTRS TOTAL FROM PREVIOUS REGIONS
 CLC
 LDA CNUMPTRS,X
 ADC MP1
 STA MP1
 LDA CNUMPTRS+1,X    
 ADC MP1+1
 STA MP1+1
 LDA CNUMPTRS+2,X
 ADC MP1+2
 STA MP1+2
;
;NOW MP1 CONTAINS TOTAL NUMBER OF POINTERS FROM START OF FILE
;
 LDA #WPLEN      
 STA MP2 ;MP2 = # BITS IN EACH POINTER
;
 JSR MP1XMP2 ;MP1 = MP1 * MP2
;MP1 NOW HOLDS TOTAL NUMBER OF BITS FROM START OF FILE
;
ABSSTR:
;GOOD PLACE FOR ABSOLUTE START (1ST WORD) ENTRY
;
 JSR MP1TTMP ;MOVE MP1 TO TEMPOR
;
 LDA #11
 JSR MP1ROL ; MP1 = MP1 / 2048 BY SHIFTING
 LDA MP1 ;S/B UNNECCESSARY
 STA SO ;HERE IS THE BLOODY SECTOR OFFSET!
 LDA #0  
 STA SO+1 ;ASSUME POINTER FILE < 256 SECTORS
;
 LDA #11  
 JSR MP1ASL ;MP1 = MP1 * 2048 BY SHIFTING
; NOW MP1 CONTAINS NUMBER BITS IN ALL SECTORS UP TO ACTUAL
; SUBTRACT THIS FROM TEMPOR TO CREATE BITS IN SECTOR
 SEC
 LDA TEMPOR
 SBC MP1
 STA MP1
 AND #$7 ;CHECK THIS
 STA BIIIT ;TO CREATE ACTUAL BIT POSITION
 LDA TEMPOR+1
 SBC MP1+1
 STA MP1+1
 LDA #0
 STA MP1+2 ;MP1 = BITS IN SECTOR
;
 LDA #3
 JSR MP1ROL ;MP1 = MP1 / 8 BY SHIFTING
 LDA MP1
 STA PO ;POSITION IN SECTOR
;
; CONVERT SO,PO,BIIT INTO TRACK,SECTOR,POS
;
 JSR FLUSH ;CLEAR OUT BITBIN FOR FRESH DATA
;
 JSR PSTARTT ;SET TRACK, SECTOR START FOR PFILE
;
 JSR READSEC ;READ SECTOR WITH SO OF CLUSTER INFORMATION
;
 JSR POSITON ;SET POINTER TO BYTE CONTAINING POINTER
;
 LDA BIIIT
 BEQ FIRST1 
;#11/20
 JMP INBITS ;STRIP AWAY THE "GARBAGE" BITS
;
FIRST1:
 RTS ;NOW POSITIONED AT POINTER
;
;
TLETVER:
;VERIFY A TWO LETTER COMBINATION.
;.A IS NUMBER 1..N (WILL BE ZERO..N)
;
;
 ASL ;A = A * 2
 TAX 
;
 LDA WORD,Y  
;
 LDA DOUBLETS,X
 CMP WORD,Y     
 BNE DOUBAD
;
 INY
 LDA WORD,Y 
 BNE TLETVE1
 JMP MEMOUT ;MEMORY IS OUT OF CHARACTERS...
;
TLETVE1:
 LDA WORD,Y  
;
 LDA DOUBLETS+1,X ;TEST AGAINST SECOND LETTER OF DOUBLET
 CMP WORD,Y
;
 BEQ DSC ;THIS DOUBLET IS OK
DOUBAD:     
 BCC DWLESS ;TARGET WORD < DISK DATA
;# 11/20 DROPTHRU
; BCS DWNF   ;TARGET WORD > DISK DATA
;
DWNF:
 JMP WNF
DSC:
 JMP SAMECR ;DOUBLET VERIFIED
DWLESS:
 JMP WLESS    
;
;
INTRKSEC:
; ADD 1 TO SECTOR, IF RANGE OVERFLOWED, THEN ADD 1 TO TRACK
; USES A,Y
; UNHARMED .X
 INC SECTOR 
 LDA SECTOR
 CMP #15 ;AT LEAST 15 SECTORS ON ANY TRACK
 BCC SECOK
;
;SECTORS/TRACK = 20 + 2* (T>17) + (T>24) + (T>30)
;                          -1       -1       -1
;
 LDA TRACK
 LDY #20  
 CMP #18 ; IF X > 17 THEN DEY,DEY
 BCC TCHK1 ;T = 0..17
 DEY
 DEY
TCHK1:
 CMP #25
 BCC TCHK2 ;T = 0..24
 DEY
TCHK2:  
 CMP #31
 BCC TCHK3 ; T = 0..34
 DEY
TCHK3:
 CPY SECTOR ;.Y = NUMBER SECTORS THIS REGION 0..N
 BEQ SECOK
 BCS SECOK
 INC TRACK
;
 LDA TRACK
 CMP #18 ;DOS STUFF?
 BNE TCHK4 ;NO, REGULAR START
 LDA #2      
!byte $2C
TCHK4:
 LDA #0
 STA SECTOR
SECOK:
 RTS
;
INCPOS:
;WATCH FOR END OF BUFFER, ADVANCE TO NEXT TRACK,
;SECTOR IF SO.  INCREMENT SO FOR FINAL WORD (TO
;AVOID) LOCATION.
 INC PO 
 BNE INCPOS1 ;WE ARE NOT OUT OF BYTES YET
;
 JSR INTRKSEC ;BUMP UP NEXT TRACK/SECTOR
 LDA #0 ;CLEAR NEW PO
 STA PO
 JSR INCWSO ;SO = SO + 1
;
 JMP RSECTOR ;READ SECTOR FROM EXISTING TRACK, SECTOR
INCPOS1:
 RTS
;
READSEC:
;BE SURE TRACK AND SECTOR ARE SET TO ABSOLUTE
;"START OF FILE" BEFORE CALLING
 LDA SO 
 STA P1 
 LDA SO+1
 STA P1+1 ;MOVE SO(SECTOR OFFSET) TO P1
;
READS1:
 LDA P1+1
 ORA P1
; CMP #0
 BEQ RSECTOR ;IF AT START, THEN SKIP BUMP ROUTINE
;
BUMPFD:   
 JSR INTRKSEC ;INCREMENT SECTOR AND TRACK BY 1
 JSR DECWP1
 JMP READS1 
;
;
;READ FROM EXISTING TRACK, SECTOR
;
RSECTOR:
;UNHARMED .X
 TXA      
 PHA
 JSR CLRCHN
 LDX #$F
 JSR CHKOUT
;
 LDX #UMSGE-UMSG-1
SENDU1:
 LDA UMSG,X
 JSR CHROUT
 DEX 
 BPL SENDU1 ;'U1:2 0 '
;
 LDA TRACK
 JSR SENDASC 
;
; LDA #' '
; JSR CHROUT
 JSR SPACE_OUT
;
 LDA SECTOR
 JSR SENDASC
;
;JSR CLRCHN
;LDX #$2
;JSR CHKIN ;CHANNEL 2 IS INPUT
 JSR CHNL2I  
 JSR CLR_CHNL2I
 PLA
 TAX
HRTS:
 RTS
;
POSITON: 
;
 LDA PO ;DON'T BOTHER TO SEND IF ZERO
 BEQ HRTS 
;
 JSR CLRCHN ;CLEAR CHANNEL 2
 LDX #$0F
 JSR CHKOUT
;
 LDX #PMSGE-PMSG-1
POSITO1:
 LDA PMSG,X ;'B-P:2,'
 JSR CHROUT
 DEX
 BPL POSITO1
;
 LDA PO
 JSR SENDASC
;
 JSR CLRCHN ;CLOSE CHANNEL 15
;LDX #$2
;JMP CHKIN
 JMP CHNL2I
;
INCWSO:
 INC SO
 BNE INCWSO1
 INC SO+1
INCWSO1:
 RTS
;
CLRMP1:
 LDA #0
 STA MP1
 STA MP1+1
 STA MP1+2
 RTS
;
SENDASC:
;SEND .AC IN ASCII (0..255) TO CHROUT
; UNHARMED .X
; WILL SEND MINIMUM (0, NOT 000) TO DISK
 STX T4 ;SAVE .X
;
 LDX #'0' 
 LDY #'0'
SEHUND:
 CMP #100
 BCC SETENS 
 SBC #100
 INX ;ONE HUNDRED
 BNE SEHUND ;ANOTHER HUNDRED?
SETENS:
 CMP #10
 BCC ONES
 SBC #10
 INY
 BNE SETENS
ONES:
 ADC #'0'
 STA T3
 CPX #'0' ;IS HUNDREDS PLACE 0?
 BEQ LODID ;IF SO, DO NOT SEND, CHECK 10'S
;
 TXA ;.A = HUNDREDS PLACE
 STY T5 ;IN CASE CHROUT SHOULD HARM .Y
 JSR CHROUT ;HUNDREDS PLACE
 LDA T5 ;A = Y (ALWAYS SEND TENS HERE)
 BNE LODID1 ;BRA
;
LODID:
 CPY #'0' ;IS TENS PLACE 0?
 BEQ LODID2 ;IF SO, SKIP & SEND ONES
;
 TYA ;TENS IS NOT ZERO, SEND
LODID1:
 JSR CHROUT ;TENS PLACE
LODID2:
 LDA T3
 JSR CHROUT ;ONES PLACE
 LDX T4 ;RESTORE X
 RTS
;
MP1XMP2:
;16 * 8 MULTIPLY WITH 24 BIT RESULT
;USES AC,RESULT,MP1,MP2
;UNHARMED .X,.Y
;
 TXA
 PHA ;SAVE .X
 LDX #8 ;NUMBER OF BITS TO SHIFT THRU
 LDA #0
 STA TS_RESULT
 STA TS_RESULT+1
;
MSHIFT:
 ASL TS_RESULT
 ROL TS_RESULT+1
 ROL TS_RESULT+2 ;PRODUCT = 2 * PRODUCT
;
 ASL MP2 ;BYTE-MULTIPLIER * 2
 BCC MNOADD
;
 CLC
 LDA TS_RESULT
 ADC MP1 ;MULTIPLICAND-WORD
 STA TS_RESULT
 LDA TS_RESULT+1
 ADC MP1+1
 STA TS_RESULT+1
 LDA TS_RESULT+2
 ADC #0
 STA TS_RESULT+2
;
MNOADD:
 DEX
 BNE MSHIFT
;
 LDA TS_RESULT+2
 STA MP1+2
 LDA TS_RESULT+1
 STA MP1+1
;
 PLA
 TAX ;RESTORE .X
;
 LDA TS_RESULT
 STA MP1           
 RTS
;
MP1TTMP:
 LDA MP1
 STA TEMPOR
 LDA MP1+1
 STA TEMPOR+1
 LDA MP1+2
 STA TEMPOR+2   
 RTS ;MOVE MP1 TO TEMPORARY
;
;
FND1LT:
;FIND FIRST LETTER OF WORD
;SO, PO OF WORD ONLY INPUT
; USES X,A,T1
; UNHARMED Y
;
 LDX #2
FND1L1:
 LDA SO,X
 CMP WSO,X    
 BNE FND1L2 ;NOT DUPLICATE OF CALLING WORD
 DEX 
 BPL FND1L1
;
 SEC
 RTS ;CS = THIS IS SAME AS CALLED WORD
;REMOVE FOR NOW TO ALLOW ALL WORDS
;
FND1L2:
;
 LDX #0 
 STX TS_T1 ;LETTER A..Z
 BEQ FND1L4
;
FND1L3:
 INX
 INX
 INX
FND1L4: 
 INC TS_T1 ;LETTER A..Z
;
 LDA LETTER+1,X 
 CMP SO+1
 BEQ FND1L5
 BCS FND1L7 ;LETTER > SO, LAST LETTER IS LETTER
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN.
;
FND1L5:  
 LDA LETTER,X  
 CMP SO
 BEQ FND1L6 
 BCS FND1L7 
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN.
;
FND1L6:
 LDA LETTER+2,X ;POSITION
 CMP PO
 BEQ FND1L8 ;ON EXACT BOUNDRY,NO DEC
 BCC FND1L3 ;LETTER < PO, BUMP UP TABLE, TRY AGAIN.
;
FND1L7:
 DEC TS_T1
FND1L8:
 LDA TS_T1
 CLC
 RTS
;
WSTARTT:
 LDA #2 
!byte $2C
PSTARTT:         
 LDA #23
 STA TRACK
 LDA #0
 STA SECTOR
 RTS
;
MP1ROL:
 STA BITROT ;# OF BITS TO SHIFT
MP1RL1:
 LSR MP1+2
 ROR MP1+1 
 ROR MP1   
 DEC BITROT
 BNE MP1RL1 
 RTS
;
MP1ASL:
 STA BITROT ;# OF BITS TO SHIFT
MP1AS1:
 ASL MP1
 ROL MP1+1
 ROL MP1+2
 DEC BITROT
 BNE MP1AS1
 RTS    
;
DECWP1:
 LDA P1
 BNE DECWP11
 DEC P1+1
DECWP11:
 DEC P1
 RTS
;
DEC1MP1:
 LDA MP1 ;MP1 = MP1-1 (16 BIT ONLY!!!)
 BNE DECMP11
 DEC MP1+1
DECMP11:
 DEC MP1
 RTS
;
INLETT:
;SET FOR LETTER READ AND FALL IN INBITS
 LDA #5
;
INBITS:   
; PEEL .A BYTES FROM INPUT CHANNEL
;
; USES .A,.X,.Y,T1,T2,SO,PO,BIIT,BITBIN,BITROT
; RETURNS .A, RETRNA
;
TS_STRIP:
 STA BITROT  ;NUMBER OF BITS
 LDA #0
 STA RETRNA
 STA RETRNA+1 ;CLEAR OUT RETURNED VALUE
TS_STRIP0:
 LDA BIIT
 BEQ TS_STRIP2 ;NO BITS LEFT IN BIN
TS_STRIP3:
 ASL BITBIN
 ROL RETRNA
 ROL RETRNA+1 ;SLIDE NEW BIT INTO RETURN WORD
 DEC BIIT
 DEC BITROT
 BNE TS_STRIP0
 LDA RETRNA
 CLC
 RTS
;
TS_STRIP2:
 STY TS_T1   
 STX T2
;
 JSR CHRIN
;
 BCS BEXIT
;
;HANDLE TRACK/SECTOR BUFFERING
 PHA 
; LDA PO
 JSR INCPOS ;BUMP UP POSITION AND STREAM FILE IF NEEDED
 PLA
;
POSOK:
 STA BITBIN
 LDY TS_T1
 LDX TS_STATUS
 BNE BEXIT ;GET OUT
 LDX T2
 LDA #8
 STA BIIT
 BNE TS_STRIP3 ;BRA
;
FLUSH: 
;CLEAR OUT BITBIN FOR NEW STRIP
 LDA #0
 STA BIIT
 RTS
;
BEXIT: 
;DEBUG
 LDA #$DE ;DISK ERROR!
 JMP TEXIT
;
 SEC    
 RTS   
;
WNDX:  
!byte 0
!byte 0
PUTCHAR:
;PUT A CHAR FROM WORD INTO BUFF
 STY WNDX+1 ;SAVE .Y
 LDY WNDX
 STA WORD,Y
 INC WNDX
 LDY WNDX+1 ;RESTORE .Y
 RTS
;
;DISK DRIVE # SPECIFICATION
UMSG:
!text " 0 2:1U"
UMSGE:     
;
THESAURUS_DRIVE =  UMSG+1
;
PMSG:
!text " 2:P-B"
PMSGE:  
;
CHANNEL:
!byte '#'
;
CTOTALS:
; TOTALS (BY SECTION) FOR THESAURUS
!word 0000,0001,0075,0132,0235,0378,0567,0787,1083,1359
!word 1641,1934,2274,2745,3184,3342,0000
;*NEVER* CHANGE THIS TABLE W/O REFLECTING IN CNUMPTRS!!!
;
;
CNUMPTRS:
; TABLE OF WORDS OF TOTALS FOR NUMBER OF POINTERS/REGION (CUMULATIVE)
; *NEVER* CHANGE THIS TABLE W/O REFLECTING IN CTOTALS!!!
V1 =  BC*0001
V1X =  BC*0074-01*0074 
;CONV VAR SUBSTITUTED with EQU
V2 =  V1+V1X
V2X =  BC*0057-02*0057
;CONV VAR SUBSTITUTED with EQU
V3 =  V2+V2X
V3X =  BC*0103-03*0103
;CONV VAR SUBSTITUTED with EQU
V4 =  V3+V3X
V4X =  BC*0143-04*0143
;CONV VAR SUBSTITUTED with EQU
V5 =  V4+V4X
V5X =  BC*0189-05*0189
;CONV VAR SUBSTITUTED with EQU
V6 =  V5+V5X
V6X =  BC*0220-06*0220
;CONV VAR SUBSTITUTED with EQU
V7 =  V6+V6X
V7X =  BC*0296-07*0296
;CONV VAR SUBSTITUTED with EQU
V8 =  V7+V7X
V8X =  BC*0276-08*0276
;CONV VAR SUBSTITUTED with EQU
V9 =  V8+V8X
V9X =  BC*0282-09*0282   
;CONV VAR SUBSTITUTED with EQU
V10 =  V9+V9X
V10X =  BC*0293-10*0293
;CONV VAR SUBSTITUTED with EQU
V11 =  V10+V10X
V11X =  BC*0340-11*0340
;CONV VAR SUBSTITUTED with EQU
V12 =  V11+V11X
V12X =  BC*0471-12*0471
;CONV VAR SUBSTITUTED with EQU
V13 =  V12+V12X 
V13X =  BC*0439-13*0439
;CONV VAR SUBSTITUTED with EQU
V14 =  V13+V13X
V14X =  BC*0158-14*0158
;CONV VAR SUBSTITUTED with EQU
V15 =  V14+V14X
;
;
!word 0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15
;
LETTER:
;TABLE OF STARTING SO,PO FOR EACH LETTER A..Z
!if ! ENABLE_THESAURUS { 
;A
!word 0
!byte 0
;B
!word 29
!byte 098
;C
!word 48
!byte 027
;D
!word 84
!byte 222
;E
!word 114
!byte 155
;F
!word 136
!byte 002
;G
!word 157
!byte 172
;H
!word 169
!byte 112
;I
!word 180
!byte 229
;J
!word 205
!byte 241
;K
!word 208
!byte 204
;L
!word 210
!byte 079
;M
!word 224
!byte 006
;N
!word 242
!byte 141
;O
!word 248
!byte 072
;P
!word 258
!byte 086
;Q
!word 294
!byte 005
;R
!word 295
!byte 179
;S
!word 321
!byte 035
;T
!word 365
!byte 000
;U
!word 384
!byte 071
;V
!word 397
!byte 249
;W
!word 406
!byte 038
;X
!word 416
!byte 064
;Y
!word 416
!byte 077
;Z
!word 417
!byte 047
;END OF ALL (FOR USE BY SO,PO COMPARITOR)
!word 418
!byte 0
} 
;
LETTEO:
;TABLE OF STARTING SO,PO FOR EACH WORD AO..ZO
!if ! ENABLE_THESAURUS { 
;AO
!word 18
!byte 187
;BO
!word 40
!byte 120
;CO
!word 60
!byte 130
;DO
!word 109
!byte 182
;EO
!word 125
!byte 021
;FO
!word 148
!byte 216
;GO
!word 163
!byte 026
;HO
!word 176
!byte 107
;IO
!word 204
!byte 177
;JO
!word 206
!byte 228
;KO
!word 210
!byte 074
;LO
!word 219
!byte 209
;MO
!word 236
!byte 253
;NO
!word 245
!byte 207
;OO
!word 252
!byte 124
;PO
!word 273
!byte 095
;QO WATCH OUT HERE, S/B SAME AS ORIG
!word 294
!byte 005
;RO
!word 317
!byte 224
;SO
!word 341
!byte 078
;TO
!word 374
!byte 138
;UO
!word 396
!byte 082
;VO
!word 404
!byte 198
;WO
!word 413
!byte 160
;XO AGAIN SAME
!word 416
!byte 064
;YO
!word 416
!byte 239
;ZO
!word 417
!byte 047
;*NOTE* TEST
!word 418
!byte 0
} 
;
; DOUBLET TABLES
;
DOUBLETS:
!if ! ENABLE_THESAURUS { 
!byte 'E'-64,'R'-64;ER 0
!byte 'O'-64,'N'-64;ON 1
!byte 'T'-64,'I'-64;TI 2
!byte 'A'-64,'T'-64;AT 3
!byte 'T'-64,'E'-64;TE 4
;
!byte 'Q'-64,'U'-64;QU 5 (SPECIAL CASE, REPLACE Q CODE)
} 
;
PSODATA:
;STORAGE FOR EACH CLUSTER'S ENTRIES
;SO POSITIONS
!word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
PPODATA: 
;PO POSITIONS
!byte 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;
CDATA:
;ACTUAL CLUSTER #'S PICKED UP TO REFERENCE
!if ! ENABLE_THESAURUS { 
!word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
} 
;
;SOME VARIABLES FOR STRIP (S/B ZP)
;
;RETRNA  DW 0 ;RETURN VALUE FOR STRIP (WORD)
;BIIT    DB 0
;BITBIN  DB 0
;BITROT  DB 0
;
;
TEXIT:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)
;
CLEARF:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
; LDA #$2
; JSR CLOSE
; JMP CLALL
 JMP CLOSE2
; JMP CLALL
;
IODRIVE:
!text "U;"
;
OVERLAY_MARK_BEGIN:
;
!eof
;

; PUBLIC THESAURUS
; PUBLIC THESAURUS_DRIVE
; EXTERN WORD
; EXTERN CHKOUT
; EXTERN CHROUT
; EXTERN CHNL2I
; EXTERN CLR_CHNL2I
; EXTERN CLALL
; EXTERN CLOSE2
; EXTERN CLOSE15
; EXTERN CLOSE
; EXTERN CLRCHN
; EXTERN CLSNUM
; EXTERN CHRIN
; EXTERN GETIN
; EXTERN INIDSK
; EXTERN OPEN
; EXTERN SETNAM
; EXTERN SETLFS
; EXTERN SPACE_OUT
; EXTERN OPNDIC
