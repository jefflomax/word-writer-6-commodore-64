;
!zone SUPPORT
;
!SOURCE "WWSETUP.ASM"
!SOURCE "VARIABLS.ASM"
;
;
; EXTERN IN_DATABASE_MODE
;
CARDFILE_MAX_PAGES =  255
;
;
STRIP_4_BITS:
 LDA #4		;STRIP 4 BITS
STRIP:
 STA BITROT ;# BITS
 LDA #0
 STA RETRNA
STRIP0:
 LDA BIIT
 BEQ STRIP2
STRIP3:
 ASL BITBIN
 ROL RETRNA
 DEC BIIT
 DEC BITROT
 BNE STRIP0
 LDA RETRNA
 CLC
 RTS
;
STRIP2:
;
 JSR CHRIN
 STA BITBIN  ;FILL UP
;
 LDX $90
 BNE STRIP_ABT ;READW3 ;GET OUT!!!
 LDA #8
 STA BIIT    ;ALL PRESENT
 BNE STRIP3  ;BRA
;
STRIP_ABT:
 SEC
STRIP_RTS:
 RTS
;
;
MOVE_TO_START_OF_WORD:
;
 JSR FC_CURSOR_LEFT
 LDY CURRENT_CHAR
 LDA EDIT_LINE,Y
 BMI .BUMP
 CPY #0         ;TEST FOR BEGINNING
 BEQ STRIP_RTS
;
 JSR LETTER_OR_NUMBER
 BCC MOVE_TO_START_OF_WORD
;
.BUMP:
 JMP FC_CURSOR_RIGHT
;
;
MOVE_TO_END_OF_WORD:
 LDY #1
 STY TEMP               
;
.LOOP1:
 INC TEMP
 JSR FC_CURSOR_RIGHT
 LDY CURRENT_CHAR
 LDA EDIT_LINE+1,Y
 CMP #ENDT
 BCS .OUT
 LDA EDIT_LINE,Y
 BMI .OUT
 JSR LETTER_OR_NUMBER
 BCC .LOOP1
.OUT:
 RTS
;
;
FONT_TABLE_X_INTO_PT:
 LDA FONT_TABLE,X
 STA POINTER
 LDA FONT_TABLE+1,X
 STA POINTER+1
 LDY #97+12
 RTS
;
VID_A_TO_SCRMO:
;
 LDY #>VIDEO
 STY SCRMO+1
 LDY #<VIDEO+$50
 STY SCRMO
 JMP ADDASM ;MAKE IN FINDTX
;
;
FILE_EXISTS:
 JSR SETNAM
 JSR OPNDIC ;OPEN FONTS.DEF
 JSR STATUS
FILE_STATUS:
;
 LDA BPCODES
 ORA BPCODES+1
 CMP #'0'
 RTS
;
;
TEXT_PLS_CURCAR_INTO_AX: 
 CLC
 LDA CURRENT_CHAR 
 ADC TEXT
 LDX TEXT+1
 BCC .SKP
 INX
.SKP:
 RTS 
;
;
ON_LAST_LINE:
;ARE WE BESIDE EOT?
 LDY CURRENT_CHAR
 INY
;
IS_EDIT_LINE_Y_EOT:
 LDA EDIT_LINE,Y 
 CMP #ENDT
 RTS
;
;
SET_SYSTEM_MARK:
; LDA #$60                      ;RTS OPCODE
; STA DISPLY                    ;KILL DISPLAY
 JSR DISPLAYOFF			;KILL DISPLAY
 LDA #$81
!byte $2C
SET_MARK:
 LDA #$80
;
 JSR FC_WORK_KEY_INS
 JMP EDIT_BUFFER_TO_TEXT
;
;
GOTO_SYSTEM_MARK:
 LDX #$81
!byte $2C
GOTO_MARK:
 LDX #$80
 LDA SEARCH_STRING_LENGTH
 PHA                              ;SAVE SEARCH STRING
 LDA CBUF
 PHA                              ;CBUF
;
 STX CBUF                         
 LDA #$01
 STA SEARCH_STRING_LENGTH
;
 CPX #$81			  ;SYSTEM OR USER?
 BEQ .FORCE_HOME			;IF USER, NO HOME
;
 JSR FC_CURSOR_RIGHT
 JMP .JOIN 
;
.FORCE_HOME:
 JSR FC_CLEAR_HOME
;
.JOIN:
 JSR SEARCH_AGAIN_FROM_CURS
 PLA
 STA CBUF
 PLA
 STA SEARCH_STRING_LENGTH
; JMP DISPLAY_AND_LINE_OUT
 RTS
;
;
FC_GOTO_MARK:
 JSR GOTO_MARK
 JMP DISPLAY_ON_AND_LINE_OUT_R
;
;
CURSOR_IN_BLOCK: 
;
 JSR TEXT_INTO_AX
 STA TEXTMO
 STX TEXTMO+1
 LDA #0
 LDY CURRENT_CHAR
 JSR IN_CURRENT_BLOCK
 PHA
 JSR RESET
 PLA
 RTS               ;BEQ NOT IN BLOCK, BNE IN BLOCK
;
SET_SYSTEM_MARK_M1_DIRECT:
 JSR DEC_AX_BY_1
;
SET_SYSTEM_MARK_DIRECT:
;
 JSR AX_INTO_TEXT
 JSR INCTE1
;
 JSR MOVE_UP_ONE
 LDY #0  
 STY EDIT_BUFFER_CHANGED    ;PROHIBIT COPY
 LDA #$81                   ;SYSTEM MARK
 STA (TEXT),Y
 RTS 
;
FC_SCREEN_CONSTRAIN:
 LDA SCREEN_CONSTRAIN
 EOR #$80
 STA SCREEN_CONSTRAIN 
 JMP REFORMAT_DOC
;
;
SCREEN_CODE_TO_WIDTH:
;
 STY .SC_SM1       ;SAVE .Y
 LDY #6
.LOOP:
 CMP EXTENDED_CODES,Y
 BEQ .DONE
 DEY
 BPL .LOOP
.DONE:
 LDA SCREEN_CODE_SUBST,Y
!byte $A0;LDY #$00
.SC_SM1:
!byte $00
 RTS
;
;
SET_UNSET_BOLD: 
;
 CMP #'B'+$80 
 BNE .BOLD_OFF
;
 LDA #$80
 ORA ATTRIBUTES
 BMI .SET
;
.BOLD_OFF: 
 CMP #'B'-'@'+$80    
 BNE .NOT_BOLD
 LDA #$7F
 AND ATTRIBUTES 
.SET: 
 STA ATTRIBUTES
 LDA #0            ;FORCE BEQ IF WAS BOLD
;
.NOT_BOLD: 
 RTS               ;BNE IF NOT BOLD ON/OFF
;
;
EOM_TEST_PLUS_0:
 LDY #0
;
EOM_TEST_PLUS_Y:
;
 PHA
 TYA            	;ALWAYS < 200
 CLC
!byte $69;ADC #3 SAFETY
EOM_SAFETY_FUDGE:
!byte 0
 ADC EOT
 STX XSAVE
 TAX		      	;HB
 LDA #0
 STA EOM_SAFETY_FUDGE
 ADC EOT+1 	   	;.XA = EOT + .Y
;
 CMP #>ENDRAM_M3
 BCC .EXIT
 BEQ .TST_LOW
 BCS .EXIT		;(CS) CANNOT MOVE
;
.TST_LOW:
 CPX #<ENDRAM_M3	;(CC)
;
.EXIT:
 LDX XSAVE
 PLA
 RTS
;
;
NOT_ENOUGH_MEMORY:
;
 LDX #0
 STX RECORD_PLAY
;
 LDX #36
 JSR SERPPT
.FREEZE:
 JSR GETIN
 CMP #$85       ;F1 KEY?
 BNE .FREEZE
;
 LDA #0
 STA $C6        ;KILL KEYBOARD BUFFER
 JMP HEADER     ;REMOVE PROMPT
;
;
CURRENT_CHARACTER_Y:
 LDY CURRENT_CHAR 
 LDA EDIT_LINE,Y
 RTS 
;
;
SHOW_CURRENT_LINE:
 LDY #0
 LDX COUNT       
;
.LOOP0456:
 LDA EDIT_LINE,X
 CMP #ENDT
 BCS .END_LINE 
;
 STA (SCREEN),Y
 INX
 INY
 CPY #$28
 BCC .LOOP0456
 RTS
;
.END_LINE:
 CMP #SRETRN
 BEQ .SPC
 LDA #31
!byte $2C
.SPC:
 LDA #' '
 STA (SCREEN),Y
 INY
 CPY #$28
 BCC .SPC
 RTS
;
DEC_LINE:
;
 LDA CURRENT_FONT
 BMI .TEXT_MODE
;FONT_MODE
 DEC LINE
 RTS
.TEXT_MODE:
 SEC
 LDA LINE
 SBC BIGGEST_POINTSIZE
 STA LINE
 RTS
;
;
BUMP_LINE_PAGE:
;
 LDA PAGE_FORCED
 BEQ .NORMAL
 LDA #0
 STA PAGE_FORCED
 BEQ FORCE_PAGE
;
.NORMAL:
 LDA CURRENT_FONT               ;TEXT OR GRAPHIC MODE
 BPL .GRAF_MODE
;
 LDA NEW_LINE_SPACE             ;TEXT MODE...DID WE JUST \S?
 BEQ .GRAF_MODE                 ;NO CHANGE IN SPACING
;
 JSR A_PLS_CUR_PAGE_LENGTH      ;ADD NEW DEPTH (NLS)
 BCC INC_LINE_TM
 BCS MOVE_TO_NEXT_PAGE
;
.GRAF_MODE:
 JSR BP_PLS_CUR_PAGE_LENGTH
 BCS MOVE_TO_NEXT_PAGE
;
;(FT)
INC_LINE:
;
 LDA CURRENT_FONT
 BMI INC_LINE_TM
;FONT_MODE
 INC LINE
 RTS
;TEXT_MODE:
INC_LINE_TM:
;
;DM MODE, SIMPLE PAGE INC, NO PAGE TABLE
;
 CLC
 LDA LINE
 ADC BIGGEST_POINTSIZE          ;(OLD DEPTH -- BP FOR LINE, NOT DEPTH)
 STA LINE
;
TEST_SET_NLS: 
;DO NOT HARM CARRY
 LDA NEW_LINE_SPACE             ;NEXT LINE DIFFERENT SPACING?
 BEQ .OUT0540 
;
 JSR SET_BIG_AND_CURR_A
 LDA #0
 STA NEW_LINE_SPACE 
.OUT0540:
 RTS
;
MOVE_TO_NEXT_PAGE:
 JSR BP_AND_2LEAD_INTO_A
 JSR A_MIN_CUR_PAGE_LENGTH     ;REMOVE PART WE DON'T NEED
;
;?TEXT_MODE_REENTRY:
FORCE_PAGE:
; LDX IN_DATABASE_MODE		;IS THIS THE DATABASE?
; BNE ?DB_MODE_REENTRY		;IF SO, SKIP PAGE TABLE
;
 LDX PAGE
 CPX #CARDFILE_MAX_PAGES	;ARE WE ABSOULUTELY AT THE END?
 BCS .TOO_MANY_PAGES
;
 LDA IN_DATABASE_MODE		;IS THIS THE DATABASE?
 BNE .DB_MODE_REENTRY		;IF SO, SKIP PAGE TABLE
;
 CPX #MAX_PAGES                ;THATS ALL THE PAGES!
 BCC .OK_FOR_SKIP
;
.TOO_MANY_PAGES:
; LDX #0
; STX RECORD_PLAY
;
 JSR NOT_ENOUGH_MEMORY	;CLEARS RECORD_PLAY
 JSR FC_CLEAR_HOME_DSP
 JMP ENTERW
;
.OK_FOR_SKIP:
;
 LDA LINE
 STA PAGE_TABLE,X
;
 LDA CUR_PAGE_LENGTH
 STA PAGE_LENGTH_LO,X
 LDA CUR_PAGE_LENGTH+1
 STA PAGE_LENGTH_HI,X   ;GRAPHIC FP NOW REQUIRES WHOLE DEPTH
;
.DB_MODE_REENTRY:
 INC PAGE
;
 JSR BP_AND_LEAD_INTO_A
;
 LDX NEW_LINE_SPACE             ;DID A SPACE COMMAND JUST EFFECT US
 BEQ .NOT_PRECEED_CHKS
 STX BIGGEST_POINTSIZE
 STX CURRENT_POINTSIZE 
 TXA                            ;MAKE NEW PAGE DEPTH NLS
 LDX #0
 STX NEW_LINE_SPACE 
;
.NOT_PRECEED_CHKS:
;
 LDX #1
 STX LINE                       ;LINE IS ALWAYS SET TO 1
 DEX 
; LDX #0
; STX LINE                      ;WILL INC TO ONE ON RETURN
 JSR AX_INTO_CUR_PAGE_LENGTH
;
 JSR PAGOUT
 JMP OV_SET_TO_TOP_PAGE
;
;
BIGGEST_AND_CURRENT: 
 LDA CURRENT_FONT
 BPL BC_DONE              ;IF FONT MODE, NO CHANGE
SET_BIG_AND_CURRENT:
 LDA #1     
SET_BIG_AND_CURR_A:
 STA BIGGEST_POINTSIZE
 STA CURRENT_POINTSIZE 
BC_DONE: 
 RTS
;
;
SEARCH_BACK_THRU_CHECKS:
;SEARCH BACK THRU A SERIES CHECKMARKS, PROCESS ANY
;\S? OR \P CHECKS FOUND.
;
; PHP                        ;SAVE COMPARE RESULT
;
 JSR PUSH_TEXT              ;SAVE TEXT
;
 LDX #0                     ;FLAG NO CHECK S PRESENT
 BEQ .FIRST_PASS            ;DON'T SKIP OVER 1ST LINE
.LOOP0633:
 JSR TEXT_TO_PREV_LINE      ;BACKUP A LINE
.FIRST_PASS:
 JSR TEXCF0                 ;GET THE 1ST CHAR
 CMP #CMARK                 ;CHECK MARK LINE?
 BNE .DONE_WITH_CHECKS
 INY                        ;READY TO SEE IF A 'P'
 LDA (TEXT),Y               ;GET CHAR
 AND #$3F                   ;EITHER CASE
 CMP #'S'-64                ;IS THERE AN 'S' IN THIS LIST?
 BNE .NO_S_THIS_LINE        ;IF NOT, NO LOOK BACK THRU SERIES
;
 INX                         ;FOUND A /S
;
.NO_S_THIS_LINE:
 CMP #'P'-64                ;FORCE NEW PAGE?
 BNE .LOOP0633
;
 STA PAGE_FORCED            ;WE FOUND A DAMN 'P'
 BEQ .LOOP0633                  ;KEEP LOOPING BACK THRU CHECKS
;
.DONE_WITH_CHECKS: 
 TXA                        ;IS FLAG SET
 BEQ .NO_S_FOUND
;
 LDA CURRENT_FONT           ;ARE WE IN TEXT MODE?
 BPL .NO_S_FOUND	    ;IF NOT, DON'T PROCESS \S
;
 LDA BIGGEST_POINTSIZE      ;SAVE CURRENT BP
 PHA 
 LDA #'S'-64                ;LOOK FOR PREVIOUS 'S' VALUE
 JSR FIND_PREV_A
;
 PLA                        ;OLD BP
;
 LDX NEW_LINE_SPACE
 BEQ .NO_S_FOUND
;
 STX BIGGEST_POINTSIZE
 STX CURRENT_POINTSIZE 
 STA NEW_LINE_SPACE
;
.NO_S_FOUND:
 JMP POP_TEXT               ;RESTORE TEXT
;
; PLP
; RTS
;
;IS .AC LRCJ?  BNE NO, BEQ YES
IS_LRCJ:
 CMP #'L'-64		;LEFT MARGIN?
 BEQ .IS
 CMP #'J'-64
 BEQ .IS
 CMP #'C'-64
 BEQ .IS
 CMP #'R'-64
.IS:
 RTS		
;
;
FIND_TAB_GT_TLL:
;.Y == 0
 JSR PUSH_P1
.TABLOOP:
 STY .SM1_INDEX		;SAVE INDEX
 LDA TAB_TABLE,Y	;GET NTH TAB POSITION
 CMP #$FF	 	;IF WE FIND $FF, NO TAB WORKED.
 BEQ .IGNORE_TAB	;BIF SUITABLE TAB > CURRENT POS NOT FOUND
 LDX #0			;CLEAR HB FOR TEXT MODE
 JSR SET_AX_LM_LL	;GET "DOT POSITION" IN AX
;
 CPX TAB_LINE_LEN+1	;IF OUR SIZE > LINE LEN?
 BEQ .TST_LO
 BCS FT_TAB_OVER_CURPOS
 BCC .TAB_EQUAL_CURPOS
;
.TST_LO:
 CMP TAB_LINE_LEN	;TEST LO
 BEQ .TAB_EQUAL_CURPOS
 BCS FT_TAB_OVER_CURPOS
;
.TAB_EQUAL_CURPOS:	;ACTUALLY <= CURPOS
!byte $A0;LDY #
.SM1_INDEX:
!byte $00
 INY
 BNE .TABLOOP		;TRY NEXT TAB
;
.IGNORE_TAB:
 CLC			;CC DON'T USE, NO TAB FOUND
FT_TAB_OVER_CURPOS:
 PHP			;SAVE SR ON PROCESSOR STACK
 JSR POP_P1		;GET P1 FROM PROGRAM STACK
 PLP			;GET SR FROM PROCESSOR STACK
FT_ABORT:
 RTS			;CS TAB > TAB_LINE_LEN FOUND
;
;
FIX_ACTUAL_COLUMN_IF_TABLINE:
 LDY TAB_PRESENT_IN_LINE;IF THERE IS NOT A TAB ON THIS LINE
 BEQ FT_ABORT 		;GET OUT OF HERE
;
FIX_ACTUAL_COLUMN:
 LDY JUSTIFY_FORMAT
 BNE .ABORT
;
 LDY CURRENT_FONT	;WE ONLY DO NEAT THINGS IN TEXT MODE
 BPL .ABORT     	;SO LEAVE UNHARMED IF IN FONT MODE
;
 INY			;[0]
 STY CUR_LEFT_FLAG_RESULT1
;
 LDA CURRENT_CHAR	;POSITION OF THE TAB CHAR
 STA CLL_INTERRUPT_POINT;FOR LINE_LENGTH RESULT
;
.SKP0749:
 JSR CALCULATE_LINE_LENGTH1	;CALL CLL AND SET CLFR TO POS TO LEFT OF TAB
;
 LDY #$FF
 STY CLL_INTERRUPT_POINT
;
 LDY CUR_LEFT_FLAG_RESULT1
 BEQ .NO_RESULT
 STY ACTUAL_COLUMN
.NO_RESULT:
 JMP ACTUAL_COLUMN_OUT
.ABORT:
 RTS
;
FIND_TAB_GT_ACT_COL:
 INX				;[0] PREPARE INDEX THRU TAB TABLE
.TABLOOP0765:
 LDA TAB_TABLE,X		;TO FIND THE NEXT TAB > THE ACUTAL_COLUMN
 CMP #$FF			;$FF TERMINATES
;*NOTE* IF TAB SUPPRESSED, COULD BMI
 BEQ .NO_TAB			;THE TABLE, SO BIF FOUND TO DO NOTHING
 CMP ACTUAL_COLUMN		;COMPARE THE TAB WITH THE COLUMN
 BEQ .NEXT
 BCS .TAB_FOUND 
.NEXT:	 
 INX
 BNE .TABLOOP0765
;
.NO_TAB: 			;BEQ TO NO TAB
.TAB_FOUND:			;BCS TO TAB FOUND
 RTS	 
;
;
EOT_OR_ENDREC:
 LDY #0			;PREPARE TO STREAM THRU TEXT
 BEQ .SKIP_INC
.NEXT_CHAR:
 JSR INCTE1
.SKIP_INC:
 JSR LDA_TEXT_Y		;LOAD AND CMP ENDT
 BEQ .DONE0789
 CMP #CMARK		;IS THIS START OF "CHECKMARK LINE?"
 BNE .NORMAL0791
 JSR TEXT_TO_NEXTLINE	;BUMP OVER IT
 JMP EOT_OR_ENDREC	;AND TRY AGAIN.
;
.NORMAL0791: 
 CMP #LINEFLD		;[LINEFLD][SKIPFLD][ENDREC][FA..FC]
 BCC .NEXT_CHAR		;IF < LINEFLD, NEXT CHAR
 CMP #ENDREC+1		;IF > END-OF-RECORD, THEN ITS A HRET OR SRET
 BCS .NEXT_CHAR		;OTHERWISE, FA..FC
.FOUND:
 CMP #ENDT		;FORCE BNE
;
.DONE0789:
 RTS 
;
;
FC_GOTO_PAGE:
;
 LDX #54
 JSR PROMPT_AND_NUMBER
 PHA
 JSR FC_CLEAR_HOME_NT	
 PLA
 CMP #2				;PAGE 1 (OR 0!)
 BCC .ABORT0815			;DO NADA
 STA COUNT_DOWN 
 DEC COUNT_DOWN
;
.LOOP0819:
; LDA PAGE
; STA MOVELO
;
.AGAIN:
 JSR FC_PAGE_FORWARD_NT
; LDA MOVELO
; CMP PAGE
; BEQ ?AGAIN
;
 DEC COUNT_DOWN
 BNE .LOOP0819
;
.ABORT0815:
 JMP ON_AND_REFREASH
;
;--------------------
;
LOAD_ANY_FILE:
;INLINE TABLE:
; LB FILENAME
; REGLOAD (PATH) VALUE
; FILENAME LENGTH
; HB FILENAME
; HB LOAD ADDRESS
; LB LOAD ADDRESS
;
 JSR GETWOR		;.A = FN HB, .X = REGLOAD VAL
 PHA			;SAVE FILENAME HB
 STX REGLOAD    	;USE SPECIFIED PATH
;
 JSR INIDSK     	;CHECK FOR DAMN FILE
;
 PLA			;RESTORE FILENAME HB
 TAY			;PLACE IN .Y
;
 JSR GETWOR		;.A = LEN .X = FN LB
 JSR FILE_EXISTS	;SEE IF IT'S OK TO LOAD THIS FOOL FILE
 CMP #$30		;IF FILE IS PRESENT,
 BEQ .OK		;GO LOAD IT, ELSE
;
 JSR CLRCHN     	;CLOSE OUT THE CHANNELS
 JSR CLALL		;
 JSR GETWOR		;PULL OFF LAST WORD
 SEC			;FLAG A BAD EXIT AND
 RTS			;LEAVE
;
.OK:
 LDA #2			;CHANNEL 2
 JSR XDEVICEN		;DEVICE FROM TABLE
 LDY #0			;SA = 0
 JSR SETLFS		;SET LOGICAL FILE STUFF
;
 JSR GETWOR		;.A = ADDRESS HB, .X = ADDRESS LB
 TAY			;PUT HB ADDRESS IN .Y
 JSR LOAD          	;ALSO SETS .A 0
 JSR CLOSE2
 CLC
 RTS
;
;
TELL_DOCUMENT_ALTERED:
;
;MUST BE CALLED BY ROUTINE CALLED BY DISPATCH
;
 LDA DOCUMENT_ALTERED 
 ORA EDIT_BUFFER_CHANGED
 BEQ .NO_CHANGES
;
 LDX #12
 JSR PRKECY	;'CHANGES WILL BE LOST ARE YOU SURE?'
 BEQ .NO_CHANGES
 PLA
 PLA			;STRIP OUR RETURN AND RETURN
 JMP HEADER
;
.NO_CHANGES:
 RTS
;
;
FC_END_OF_RECORD:
 JSR CURRENT_CHARACTER_Y	;WHAT CHARACTER ARE WE ON
 CMP #LINEFLD			;IS CHARACTER < LINEFLD?
 BCC .SET_ENDREC		;IF SO, MAKE IT AN EOR
;
;[SEC]
 SBC #1
 CMP #LINEFLD-1
 BNE .PLACE
 LDA #ENDREC 
;
.PLACE:
 INC EDIT_BUFFER_CHANGED
 JMP PLACE_CHARACTER
;
.SET_ENDREC:
 JMP PUT_END_OF_RECORD 
;
;
!eof
;
; PUBLIC BIGGEST_AND_CURRENT
; PUBLIC BUMP_LINE_PAGE
; PUBLIC CURRENT_CHARACTER_Y
; PUBLIC CURSOR_IN_BLOCK
; PUBLIC DEC_LINE
; PUBLIC EOM_SAFETY_FUDGE
; PUBLIC EOM_TEST_PLUS_Y
; PUBLIC EOM_TEST_PLUS_0
; PUBLIC EOT_OR_ENDREC
; PUBLIC FIX_ACTUAL_COLUMN
; PUBLIC FIX_ACTUAL_COLUMN_IF_TABLINE
; PUBLIC FC_END_OF_RECORD
; PUBLIC FC_GOTO_MARK
; PUBLIC FC_GOTO_PAGE
; PUBLIC FC_SCREEN_CONSTRAIN
; PUBLIC FILE_EXISTS
; PUBLIC FILE_STATUS
; PUBLIC FIND_TAB_GT_ACT_COL
; PUBLIC FIND_TAB_GT_TLL
; PUBLIC FONT_TABLE_X_INTO_PT
; PUBLIC FORCE_PAGE
; PUBLIC GOTO_MARK
; PUBLIC GOTO_SYSTEM_MARK
; PUBLIC INC_LINE
; PUBLIC IS_LRCJ
; PUBLIC LOAD_ANY_FILE
; PUBLIC MOVE_TO_END_OF_WORD
; PUBLIC MOVE_TO_START_OF_WORD
; PUBLIC NOT_ENOUGH_MEMORY
; PUBLIC ON_LAST_LINE
; PUBLIC SCREEN_CODE_TO_WIDTH
; PUBLIC SEARCH_BACK_THRU_CHECKS
; PUBLIC SET_BIG_AND_CURR_A
; PUBLIC SET_BIG_AND_CURRENT
; PUBLIC SET_MARK
; PUBLIC SET_SYSTEM_MARK
; PUBLIC SET_SYSTEM_MARK_DIRECT
; PUBLIC SET_SYSTEM_MARK_M1_DIRECT
; PUBLIC SET_UNSET_BOLD
; PUBLIC SHOW_CURRENT_LINE
; PUBLIC STRIP
; PUBLIC STRIP_4_BITS
; PUBLIC TELL_DOCUMENT_ALTERED
; PUBLIC TEST_SET_NLS
; PUBLIC TEXT_PLS_CURCAR_INTO_AX
; PUBLIC VID_A_TO_SCRMO
; EXTERN ACTUAL_COLUMN_OUT
; EXTERN ADDASM
; EXTERN AX_INTO_CUR_PAGE_LENGTH
; EXTERN AX_INTO_TEXT
; EXTERN A_MIN_CUR_PAGE_LENGTH
; EXTERN A_PLS_CUR_PAGE_LENGTH
; EXTERN BP_AND_2LEAD_INTO_A
; EXTERN BP_AND_LEAD_INTO_A
; EXTERN BP_PLS_CUR_PAGE_LENGTH
; EXTERN BPCODES
; EXTERN CALCULATE_LINE_LENGTH1
; EXTERN CBUF
; EXTERN CHRIN
; EXTERN CLALL
; EXTERN CLL_INTERRUPT_POINT
; EXTERN CLOSE2
; EXTERN CLRCHN
; EXTERN CUR_LEFT_FLAG_RESULT1
; EXTERN DEC_AX_BY_1
; EXTERN DISPLY
; EXTERN DISPLAYOFF
; EXTERN DISPLAY_AND_LINE_OUT
; EXTERN DISPLAY_ON_AND_LINE_OUT_R
; EXTERN EDIT_BUFFER_TO_TEXT
; EXTERN EDIT_LINE
; EXTERN ENTERW
; EXTERN EXTENDED_CODES
; EXTERN FC_CLEAR_HOME
; EXTERN FC_CLEAR_HOME_DSP
; EXTERN FC_CLEAR_HOME_NT
; EXTERN FC_CURSOR_LEFT
; EXTERN FC_CURSOR_RIGHT
; EXTERN FC_PAGE_FORWARD_NT
; EXTERN FC_REFORMAT_DOC
; EXTERN FC_WORK_KEY_INS
; EXTERN FIND_PREV_A
; EXTERN FONT_TABLE
; EXTERN GETIN
; EXTERN GETWOR
; EXTERN HEADER
; EXTERN INCTE1
; EXTERN INIDSK
; EXTERN IN_CURRENT_BLOCK
; EXTERN JUSTIFY_FORMAT
; EXTERN LDA_TEXT_Y
; EXTERN LETTER_OR_NUMBER
; EXTERN LOAD
; EXTERN MOVE_UP_ONE
; EXTERN NEW_LINE_SPACE
; EXTERN ON_AND_REFREASH
; EXTERN OPNDIC
; EXTERN OV_SET_TO_TOP_PAGE
; EXTERN PAGE_FORCED
; EXTERN PAGE_LENGTH
; EXTERN PAGE_LENGTH_HI
; EXTERN PAGE_LENGTH_LO
; EXTERN PAGE_TABLE
; EXTERN PAGOUT
; EXTERN PLACE_CHARACTER
; EXTERN POP_P1
; EXTERN POP_TEXT
; EXTERN PRKECY
; EXTERN PROMPT_AND_NUMBER
; EXTERN PUSH_P1
; EXTERN PUSH_TEXT
; EXTERN PUT_END_OF_RECORD
; EXTERN RECORD_PLAY
; EXTERN REFORMAT_DOC
; EXTERN REGLOAD
; EXTERN RESET
; EXTERN SEARCH_AGAIN_FROM_CURS
; EXTERN SEARCH_STRING_LENGTH
; EXTERN SERPPT
; EXTERN SETNAM
; EXTERN SET_AX_LM_LL
; EXTERN SCREEN_CODE_SUBST
; EXTERN SCREEN_CONSTRAIN
; EXTERN SETLFS
; EXTERN STATUS
; EXTERN TAB_LINE_LEN
; EXTERN TAB_PRESENT_IN_LINE
; EXTERN TAB_TABLE
; EXTERN TEXCF0
; EXTERN TEXCFE
; EXTERN TEXT_INTO_AX
; EXTERN TEXT_TO_NEXTLINE
; EXTERN TEXT_TO_PREV_LINE
; EXTERN XDEVICEN
