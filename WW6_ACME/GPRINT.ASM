;
!zone GPRINT
;
!SOURCE "WWSETUP.ASM"
!SOURCE "VARIABLS.ASM"
;
;
;
;
;
;
;
;
PLINE_WIDTH =  120        ;WIDTH IN BYTES
PLINE_PWIDTH =  960
;
;
RASTERS_IN_PLINE:   
!byte 0;# RASTERS COPIED TO PLINE
REPLICATIONS:	
!byte 0;COUNT-DOWN VERTICAL OR HORIZONTAL REPLICATIONS
;
P2INC:
!word 0
OFFSET:
!byte 0
CLR_RAST_TEMP:
!byte 0
IN_GRAPHICS_PRINT:
!byte 0
RIGHT_DOT_MARGIN:
!word 0
;
;
GPRINT_FILE:
;
;LOAD PRINTER DRIVER
;
 JSR CLRBLK
 JSR TOP_AREA
;
 JSR LOAD_PRINTER_DRIVER
 BCC GPRINT_START
;
 LDX #2                  ;'DRIVER NOT FOUND'
 RTS                     ;.X = 2, ERRMSG
;
;
GPRINT_START:
;
 LDX #$80
 STX POINTER4            ;LOAD FONT-DEFS IF PRESENT
;
 LDX #USE_DATA_DISK
 STX REGLOAD
;
 BCC .FIRST_COPY
;
 LDX GFNAME_SAVE
 STX MSLEN
.REST_NAME:
 LDA GFNAME_SAVE+1,X
 STA INPBUF,X
 DEX
 BPL .REST_NAME
;
 JSR OPEN_USER_FILE_2
 JMP .JOIN
;
.FIRST_COPY:
 LDX #17
 JSR OPEN_USER_FILE_1    ;OPEN USER'S TEXT FILE
;
.JOIN:
 BCC .SAVE_NAME
 JMP END_IT_ALL
;
.SAVE_NAME:
 LDX MSLEN
 STX GFNAME_SAVE
.STORE_NAME_LOOP:
 LDA INPBUF,X
 STA GFNAME_SAVE+1,X
 DEX
 BPL .STORE_NAME_LOOP
;
.BEGIN:
 JSR CLRCHN              ;KEEP IT CLEAN
;
 JSR GPRINT_DRAW_BOX     ;PRESS RS TO QUIT...
;
 LDX #USE_FONT_DISK
 STX REGLOAD
; JSR OPEN_15_NO_NAME     ;OPEN15,?,15
 LDA #0
 STA FEATUR		  ;0 = DO NOT SUPPRESS GRAPHIC
; JSR SETNAM
;*NEW* ONLY STORE NULL LENGTH
 STA $B7           ;FNLEN
;
 LDA #$E 
 JSR OPEN_A_DV_15
;
 LDA #0
 JSR LOAD_FONT 
;
 LDX #$E
 JSR CHKIN
 LDA #$E
;
 JSR STATUS_DEFAULT_IN         ;READ ERRCHNL
;
 JSR FILE_STATUS
 BEQ .DEF_FONT_OK
;
 LDA #$E
 JSR CLOSE
;
 JSR CLOSE15
 LDX #24                  ;'FONT NOT FOUND'
 RTS
;
.DEF_FONT_OK:
;
 LDA #1
 STA ASCTYP              ;FORCE TO NORMAL ASCII DESPITE PULLDOWN
;
 LDA STPAGE
 STA PAGE
;
 LDA #<GRAPHIC_TEXT_LINE
 LDX #>GRAPHIC_TEXT_LINE
 JSR SETUP_RW_NO_CASE_MOD;.Y = $FF, SET READ_LINE FOR EDIT_LINE
 STY FONT_IN_FAKE_FONT   ;FORCE FAKE_FONT TO EMPTY
 STY IN_GRAPHICS_PRINT   ;$FF GRAPHIC $01 TEXT 00 NOT_PRINTING
;
 JSR BLANK_THE_SCREEN    ;BLANK SCREEN IF ATTRIB SELECTED
;
 JSR SET_VMARGINS
; JSR INIT_PRINTER	      ;OPEN PRINTER, SET VARS, SET TB_MARGIN
 JSR OPEN_PRINTER	   ;CHECK DEVICE PRESENT & OPEN 4,PDEVICE,SECOND
 BCC PRINT_LINE
 LDX #9                  ;DEVICE NOT PRESENT
 RTS
;
PRINT_LINE:
;
 JSR CLEAR_PLINE
;
 JSR INIT_FOR_PLINE	   ;CLEAR RASTERS_IN_PLINE
 JSR P1_AT_TOP_PLINE
;
 LDA #0
 STA ATTRIBUTES          ;ALL PRINT ATTRIBUTES OFF
 STA CURRENT_FONT
;
 JSR OUTPUT_STRING_A	   ;SEND INIT STRING
;
SET_LINE:
;
 JSR READ_LINE
;
DO_TOP_MARGIN:
 JSR PUSH_P1                ;SAVE LINE POS
 JSR DOCHKM
 JSR LOAD_GRAPHIC_IF_NEEDED
;
; PHP
 JSR POP_P1                 ;RESTORE LINE POS
;*NEW* THIS MIGHT NOT HARM THE CARRY
; PLP
;
;HANDLE FORCE PAGE
 LDA PAGE_FORCED        ;WAS THAT -PAGE?
 BEQ .NOT_FORCED        ;IF NOT, CONTINUE...
 JMP FP_RELOOP          ;DISALLOW AND START OVER
; BRK
; JMP END_PRINTING
; BNE J_END_PRINTING
;
;
.NOT_FORCED:
 JSR FIX_LEFT_MARGIN
 BCS SET_LINE
;
 JSR CLEAR_BOTTOM              ;SAVES P1
;
 LDA TOP_MARGIN
 LDX TOP_MARGIN+1
 LDY HEADER_FOOTER_TEXT
 BEQ .SEND_TPM
;
 LDY #0
 JSR GHEADER_FOOTER
 JMP .SET_PAGE_EMPTY
;
.SEND_TPM:
 JSR AX_CLEAR_RASTERS
;
.SET_PAGE_EMPTY:
; LDA #0
; STA FIRST_LINE
; TAX
; JSR AX_INTO_CUR_PAGE_LENGTH
; JMP FIRST_LINE_OF_PAGE
 JSR ZERO_INTO_CUR_PAGE_LENGTH	;.A.X = 0
 STA FIRST_LINE
 BEQ FIRST_LINE_OF_PAGE
;
PROCESS_BITMAPS:
;
 JSR PUSH_P1          
.CHECKS:
 JSR READ_LINE
 JSR DOCHKM           ;HARMS P1, PT
 JSR LOAD_GRAPHIC_IF_NEEDED
;
 LDA PAGE_FORCED
 BNE END_PRINTING
;
;?NOT_FORCED:
;
 JSR FIX_LEFT_MARGIN
 BCS .CHECKS          ;LOOK FOR NEXT "REAL" LINE
;
.SKP:
 JSR POP_P1
;
;
; HANDLE FORCE PAGE
;
;
;
FIRST_LINE_OF_PAGE: 
;
 JSR FIND_BIGGEST_FONT
;
 LDA BIGGEST_FONT        ;HEIGHT OF BIGGEST FONT ON LINE
 BIT EXPAND_ON           ;ARE WE EXPANDING?
 BPL .NOEXP              ;BIF NO
;
 ASL                   ;FONT IS EXPANDED
.NOEXP:
 CLC
 ADC FONT_LEADING        ;AND ITS POTENTIAL LEADING ABOVE
 ADC FONT_LEADING        ;AND ITS (LL ONLY) LEADING BELOW
 STA POINTER
;# BUT FOR THIS, COULD BE BP_PLS_
;
 JSR A_PLS_CUR_PAGE_LENGTH  ;WILL DELETE 1LEAD IF FITS
 BCC RASTERIZE_LINE
;
 SEC
 LDA POINTER
 SBC FONT_LEADING           ;LEAVE SET FOR FINAL LEADING
 JSR A_MIN_CUR_PAGE_LENGTH  ;ADJUST CUR_PAGE BACK FOR DIFF
J_END_PRINTING:
 JMP END_PRINTING
;
RASTERIZE_LINE:
;
 JSR PUSH_P1
 LDA LEFPRT
 LDX LEFPRT+1
 JSR IMAGE_LINE       ;SEND TEXT CHARACTERS THRU IMAGE_CHAR
 JSR POP_P1
;
PROCESS_BANDS:
;
;COUNTING DOWN FROM BIGGEST FONT, MOVE RASTERS TO PLINE, PRINTING
;WHEN FULL
 JSR BUFFER_TO_PLINE
 JSR GETIN1
 CMP #3 
 BNE .LAST_LINE 
 LDX #0                        	;KILL FINAL FOOTER!
 STX HEADER_FOOTER_TEXT+100    	;SO PAGE WILL BE ALL BLANK
 INX
 STX NUMBER_OF_COPIES		;KILL MULTI-COPY
 LDA #ENDT 
 STA PRINT_STATUS 
;
.LAST_LINE: 
 LDA PRINT_STATUS
 CMP #ENDT
 BNE PROCESS_BITMAPS
;
END_PRINTING:
;TEST FOR ALL RASTERS OUT, PAGE END, ETC
;
;IF "SUBSCRIPTS_PRESENT" NZ, THEN THERE ARE IMAGED, UNBANDED
;DATA TO SEND, STARTING AT LINE_BUFFER_E FOR LEADING RASTERS
;
 LDA PRINT_STATUS
 CMP #ENDT
 BNE .NOT_AT_END
 LDA FONT_LEADING
 CLC
 ADC CUR_PAGE_LENGTH
 STA CUR_PAGE_LENGTH
 BCC .BMP
 INC CUR_PAGE_LENGTH+1
.BMP: 
;
.NOT_AT_END:
 JSR FINISH_SUBSCRIPTS
;
END_MESSAGES:
;
 LDA GRAPHIC_X_OFFSET           ;IS THERE A GRAPHIC?
 BMI .NO_GRAPHIC
;
 JSR BAD_HEADER                 ;TERMINATE GRAPHIC
;
.NO_GRAPHIC:
;
 LDA PRINT_STATUS
 CMP #ENDT                     ;IS THIS REALLY THE END?
 BNE .NOT_END_OF_ALL
 LDX HEADER_FOOTER_TEXT+100    ;IS THERE A FOOTER?
 BNE .NOT_END_OF_ALL           ;IF SO, WE'LL SEND PAGE AND FOOTER
 LDX PW_S_EJECT_PAGE
 CPX #'Y'
 BEQ .NOT_END_OF_ALL
 PHA
 BNE .LAST_PAGE                 ;REJOIN EOP
;
.NOT_END_OF_ALL:
 SEC
 LDA PAGE_LENGTH
 SBC CUR_PAGE_LENGTH
 STA POINTER
 LDA PAGE_LENGTH+1
 SBC CUR_PAGE_LENGTH+1
 STA POINTER+1
;
 JSR PT_CLEAR_RASTERS          ;POSITION TO BOTTOM MARGIN
;
 LDA PRINT_STATUS
 PHA
 LDA BOTTOM_MARGIN
 LDX BOTTOM_MARGIN+1
 LDY HEADER_FOOTER_TEXT+100
 BEQ .SEND_BTM
;
 LDY #100
 JSR GHEADER_FOOTER
 JMP .LAST_PAGE
;
.SEND_BTM:
 JSR AX_CLEAR_RASTERS
;
.LAST_PAGE:
;
 INC PAGE
 PLA                           ;PRINT_STATUS (DONE?)
 CMP #ENDT
;BEQ ?SKP
 BEQ END_PRINT_PTC
 LDA PAGE_FORCED               ;WAS THIS A FORCED PAGE?
 BEQ NO_FP_1                   ;NO, DO TOP MARGIN
FP_RELOOP:
 LDA #0
 STA PAGE_FORCED 
 JMP SET_LINE
NO_FP_1:
 JMP DO_TOP_MARGIN             ;IF THERE IS ANOTHER PAGE
;
;?SKP:
END_PRINT_PTC:
 JSR END_PRINT_PATCH 
;
 LDA #3
 JSR OUTPUT_STRING_A
;
END_IT_ALL:
;
 JSR CLOSE_PRINTER		;NEAT & CLEAN
 JSR CLOSE2
;
 LDA NUMBER_OF_COPIES
 CMP #1
 BEQ .ALL_DONE
 DEC NUMBER_OF_COPIES
 SEC				;FLAG NO PROMPT FOR FILENAME
 JMP GPRINT_START		;DO NEXT COPY
;
.ALL_DONE:
 LDA FIRST_PAGE
 STA PAGE
;
 LDX #0
 STX IN_GRAPHICS_PRINT 
 RTS                           ;.X = 0, NO ERROR
;
;
FINISH_SUBSCRIPTS:
;
 LDA FONT_LEADING              ;IS THERE LEADING?
 BEQ .OUT
;
 LDX SUBSCRIPTS_PRESENT        ;ARE THERE SUBSCRIPTS?
 BNE .SEND_SUB_IMAGE
 JMP A_CLEAR_RASTERS           ;HANDLE BOTTOM LEAD
;
.SEND_SUB_IMAGE:
 STA BIGGEST_FONT              ;TO COUNT_DOWN
 INC SUBSCRIPTS_PRESENT
; LDA #<LINE_BUFFER_E
; LDX #>LINE_BUFFER_E
; JSR AX_INTO_P3                ;POINT P3 AT TOP LINE
 JSR W_INTO_P3
!word LINE_BUFFER_E
;
 JMP SUBSCRIPT_TO_PLINE
.OUT: 
 RTS
;
;
FIX_LEFT_MARGIN:
 PHP                  ;SAVE CARRY STATUS
;
 JSR SET_RIGHT_DOT_MARGIN
 LDA RIGHT_DOT_MARGIN+1
 CMP D_PIXELS_PER_LINE+1
 BNE .SKP0625
 LDA RIGHT_DOT_MARGIN
 CMP D_PIXELS_PER_LINE
.SKP0625:
 BCC .NO_KILL
 BEQ .NO_KILL
 LDA #0
 STA LEFPRT
 STA LEFPRT+1
.NO_KILL:
 JSR SET_RIGHT_DOT_MARGIN
 PLP
 RTS
;
SET_RIGHT_DOT_MARGIN:
;
 CLC
 LDA MARGIN
 ADC LEFPRT
 STA RIGHT_DOT_MARGIN
 LDA MARGIN+1 
 ADC LEFPRT+1
 STA RIGHT_DOT_MARGIN+1
 RTS
;
;
;INIT_PRINTER:
;;
; JSR OPEN_PRINTER	   ;CHECK DEVICE PRESENT & OPEN 4,PDEVICE,SECOND
; BCS INIT_PRINTER_ABT	;ERROR-ABORT
;;
; CLC
;INIT_PRINTER_ABT:
; RTS
;
;
BUFFER_TO_PLINE:
;
 CLC
 LDA BIGGEST_FONT
 ADC USER_DEFINED_LEAD
 STA BIGGEST_FONT
;
 JSR PUSH_P1
 JSR W_INTO_PT
!word LINE_BUFFER
;
 SEC                        ;SET P3 TO CORRECT BYTE, LINE_BIT TO CORRECT BIT
 LDA #L_BUFFER_DEPTH        ;POINT SIZE OF LINE BUFFER
 SBC BIGGEST_FONT           ;PTS OF LARGEST FONT IN LINE
;
 LDX #PLINE_PWIDTH/8        ;LENGTH OF LINE
 JSR MUL_AX_PT              ;PT = PT + .A*.X
;
 JSR PT_INTO_AX
 JSR AX_INTO_P3             ;P3 POINTS TO "BASE" OF TOP RASTER
;
 JSR POP_P1
;
SUBSCRIPT_TO_PLINE:
;.P3 = TOP LINE (BASELINE), BIGGEST_FONT = #RASTERS
;
;
.LINE_BEGIN:
 JSR P3_INTO_AX
 STA .READ_RASTER_SM1
 STX .READ_RASTER_SM1+1 
 LDA SPECIAL_EFFECT2
 AND #$F
 STA REPLICATIONS            ;SETUP FOR VREPS
;
;
.VREPS_BEGIN:
; LDA LINE_LEADING
; BEQ ?COPY_RASTER
;
; DEC LINE_LEADING
; BPL ?LINE_IMAGED
;
.COPY_RASTER:
; LDY #PLINE_WIDTH-1                 ;COPY BUFFER
 LDA #0
 BIT SPECIAL_EFFECT1           ;INVERSING?
 BVC .SKP0708                      ;NO, USE 0 MASK
 LDA #$FF                      ;YES, USE $FF MASK
.SKP0708:
 STA .INVERSE_MASK_SM1         ;SELF_MODIFY
;
 LDA SPECIAL_EFFECT1           ;HREP 1?
 AND #1 
 LSR                         ;HREP Y/N TO CARRY
 ROR                         ;$80 YES, $00 NO
 STA SAVEYG                    ;FLAG FOR DOUBLE H
;
 LDY #0
 LDX #0
.LOOP:
!byte $BD;LDA $NNNN,X
.READ_RASTER_SM1:
!word $FFFF
 INX                        ;BUMP UP SOURCE INDEX
!byte $49;EOR #NN
.INVERSE_MASK_SM1: 
!byte $00
;
 BIT SAVEYG
 BPL .NO_EXPAND             ;SKIP AROUND EXPAND CODE
 JSR EXPAND_4_BITS
 JSR EXPAND_4_BITS
 DEY                        ;PREPARE FOR +1
 LDA #1                     ;SET DOTS IN BAND
 BNE .UPDATE_FLAG
;
.NO_EXPAND:
 STA (POINTER1),Y
.UPDATE_FLAG:
 ORA DOTS_PRESENT_IN_BAND
 STA DOTS_PRESENT_IN_BAND
;
 INY
.CONT_LOOP:
 CPY #PLINE_WIDTH            ;COPY BUFFER
 BCC .LOOP 
;
; PRINT GRAPHIC PRINT
;
 LDA FEATUR			;SKIP GRAPHIC FLAG
 BNE .SKIP_GRAPHIC		;IF NZ, DO NOT PRINT NOW
;
 LDA GRAPHIC_X_OFFSET           ;IS THERE A GRAPHIC?
 BPL .DO_GRAPHIC                ;$FF = NO, ELSE LEFT MARGIN
.SKIP_GRAPHIC:
 JMP .LINE_IMAGED               ;TOO FAR FOR BRANCH
;
.DO_GRAPHIC:
;
 JSR PUSH_P1
 JSR SET_AX_LM_LL               ;KILL P1, RETURN .AX MARGIN
 STA DOT_COLUMN
 STX DOT_COLUMN+1 
 JSR POP_P1
;
 JSR READ_IMG_RASTER            ;RETURNS LINE & LENGTH IN PATTERN_BYTES+4
;
 JSR W_INTO_P2                  ;ASSUME NO FLIP
!word 0000
 STA P2INC+1                    ;[AX 0]
 INX
 STX P2INC                      ;P2INC = 1
;
 LDA GRAPHIC_EFFECT             ;$80 = FLIP, $40 = INVERSE
 BPL .GRAPH_LOOP                ;NO FLIP, USE AS NORM
;
 LDA PATTERN_BYTES+4
 LDX PATTERN_BYTES+5 
 JSR DEC_AX_BY_1
 JSR AX_INTO_P2
;
 LDA #$FF
 STA P2INC
 STA P2INC+1                    ;P2INC = -1
;
.GRAPH_LOOP: 
;
; LDA #2
; STA POINTER                    ;HREPS ON
;
.IGRAPH_LOOP:
;
 LDA POINTER2                   ;LB OF DOT TO READ
 AND #$7                        ;BIT INDEX
 TAY
 JSR P2_INTO_AX                 ;DOT TO READ
 JSR LSR_AX_3                   ;/8 BYTE TO READ
 TAX
 LDA GRAPHIC_RASTER_BUFFER,X    ;GET BYTE
 AND BIT_ON,Y                   ;ISOLATE BIT
 BEQ .NO_DOT
;
 LDA DOT_COLUMN
 AND #7
 STA PATTERN_BYTES+2    ;TEMP
 JSR DC_BY8_INTO_AX
 CMP #120               ;OUT OF BAND?
 BCS .NO_DOT            ;CLIP IT!
;
 TAY
 LDA (POINTER1),Y
 LDX PATTERN_BYTES+2
 ORA BIT_ON,X
 STA (POINTER1),Y
.NO_DOT:
 LDA #1
 JSR ADJUST_DOTC
;
; DEC POINTER            ;HREP ON?
; BNE ?IGRAPH_LOOP
;
 JSR INC_P2_INC         ;ADD OR SUBTRACT 1
;
 LDA PATTERN_BYTES+4
 BNE .SKPD
 DEC PATTERN_BYTES+5
.SKPD:
 DEC PATTERN_BYTES+4
;
 LDA PATTERN_BYTES+4
 ORA PATTERN_BYTES+5
 BNE .GRAPH_LOOP
;
 LDA #1
 STA DOTS_PRESENT_IN_BAND      ; TEST THEORY
;
.LINE_IMAGED:
 INC RASTERS_IN_PLINE       ;COUNTS UP TO MATRIX DEPTH
 LDA MATRIX_DEFINITION      ;NUMBER OF WIRES
 AND #$F
 CMP RASTERS_IN_PLINE
 BNE .SKPPRT
;
 JSR PRINT_PLINE            ;ALL FULL, SO SPIT IT OUT
;
.SKPPRT:
 LDA REPLICATIONS
 BEQ .NXT_REAL_LINE
;
 DEC REPLICATIONS
 JSR INCREMENT_P1
 JMP .VREPS_BEGIN
;
.NXT_REAL_LINE:
;
 LDA #PLINE_WIDTH
 JSR INC_P3_BY_A
;
 JSR INCREMENT_P1
;
.TST_OUT:
 DEC BIGGEST_FONT           ;P1 SET FOR NEXT, ARE WE DONE?
; BNE ?LINE_BEGIN
 BEQ .OUT0865
 JMP .LINE_BEGIN
;
.OUT0865:
;
 RTS
;
INCREMENT_P1:
;
 LDA RASTERS_IN_PLINE
 BNE P1_PLS_RASTER_WIDTH
;
P1_AT_TOP_PLINE:
;
; LDA PLINE                  ;POINT P1 AT WORD IN PLINE
; LDX PLINE+1                ;FAST WAY
 LDA #<PLINE_BUFFER
 LDX #>PLINE_BUFFER	      ;PLINE CAN BE PLACED ANYWHERE (CONSTANT IN WW)
 JMP AX_INTO_P1             ;P1 POINTS AT START OF PLINE
;
;
P1_PLS_RASTER_WIDTH:
 LDA #PLINE_WIDTH           ;POINT P1 AT NEXT LINE
 JMP INC_P1_BY_A            ;SET FOR NEXT LINE
;
;
PRINT_PLINE:
;
 LDA DOTS_PRESENT_IN_BAND	;IF THERE ARE NO DOTS IN BAND
 BNE .SSKP			;SEND EMPTY LINE
 JMP NO_LINE
;
.SSKP:
 LDA #$FF
 STA P2INC
 STA P2INC+1
;
 JSR IW_INTO_AX       ;RIGHTMOST PIXEL WE CAN HANDLE
!word D_PIXELS_PER_LINE
 JSR DEC_AX_BY_1
;
 JSR AX_INTO_P2
 JSR AX_INTO_P4       ;P4 = LINE LENGTH BASE 0
;
 BIT SPECIAL_EFFECT1	;ARE WE GOING TO PRINT RIGHT TO LEFT?
 BPL .LEFT_TO_RIGHT
 JMP LINE_STRING      ;AX = LENGTH
;
.LEFT_TO_RIGHT:
 LDX #1
 STX P2INC
 DEX ;[0]
 STX P2INC+1
;
.FIND_END_LOOP:
 JSR READ_PLINE_BYTE
 BNE .FOUND_END_BIT    ;IF BYTE HAS DATA, WE ARE AT END
;
 LDA POINTER2
 BNE .DEC_LO
;
 DEC POINTER2+1
.DEC_LO:
 DEC POINTER2         ;FOR SPEED
;
; JMP ?FIND_END_LOOP
 LDA POINTER2+1
 CMP #$FF             ;IF HB=$FF, DONE
 BNE .FIND_END_LOOP   
 JMP NO_LINE
;
;# FASTER EMPTLY LINE PROCESSING
;
;LDA POINTER2         ;GET LO BYTE
;BEQ ?DEC_BOTH
;DEC POINTER2
;JMP ?LOOP
;
;DEC POINTER2+1
;DEC POINTER2
;LDA POINTER2+1
;BPL ?FIND_END_LOOP
;
;
.FOUND_END_BIT:
;
;
 JSR P2_INTO_AX    ;AX = LENGTH OF LINE
 JSR AX_INTO_P4
;
 JSR INC_AX_BY_1   ;$FFFF = 0 -> BASE1
;
 STA P_ARG_2
 STX P_ARG_2+1
;
;
;NOW DETERMINE LEFT MARGIN STUFF
 JSR W_INTO_P2     ;P2 = FIRST VALID DOT
!word 0000
;
 LDA PIXELS_IN_SPACE	;CAN WE DO LM SPACE PADDING?
 BEQ LINE_START       ;NO, SEND LINE!
;
.PIXELS:
 JSR READ_PLINE_BYTE	;GET THE P2TH BYTE
 BNE LEFT_MAR_FOUND	;THIS IS THE 1ST REAL BYTE
 JSR INC_P2_BY_1	   ;ADD 1 TO BYTE TO READ
 JMP .PIXELS    	   ;CONTINUE LOOKING TILL YOU FIND IT
;
LEFT_MAR_FOUND:
;
;P2 CONTAINS NUMBER OF "EMPTY" DOT-COLUMNS 1..N
;
 LDA POINTER2	      ;ARE THERE ENOUGH TO SEND SPACES
 LDX POINTER2+1		   ;ARE THERE ENOUGH TO SEND SPACES
 BNE SPACES_TO_SEND	;YES, AT LEAST 255 DOT COLUMNS
 CMP PIXELS_IN_SPACE	;IF PIXELS_IN_SPACE >= P2, THEN
 BCS SPACES_TO_SEND  ;SEND PRECEEDING SPACES
;
 JSR W_INTO_P2        ;P2 = FIRST VALID DOT
!word 0000
 JMP LINE_START 	   ;NOT ENOUGH EMPTY TO SEND SPACES
;
SPACES_TO_SEND:
;
;P4(LL) = P4 - CLEAR DOT COLUMNS + REMAINDER (CLEARDOT/PIXELSPC)
;
 JSR AX_INTO_PT       ;FIRST DOT-COLUMN IN PT
 JSR P4_INTO_AX		   ;PUT LINE LENGTH IN AX
 JSR DEC_AX_BY_PT	   ;AX -= PT (CLEAR DOT COLUMNS)
 JSR PUSH_AX	         ;SAVE ADJUSTED LINE LENGTH NEEDING ODD PIXELS
;
 JSR P2_INTO_AX		   ;FIND OUT HOW MANY TO SEND
 LDY PIXELS_IN_SPACE	;NUMBER OF PIXELS IN 1 SPACE
 JSR DIV_AX_BY_Y	   ;RESULT IN PT
 STA OFFSET 		      ;PIXELS TO LEFT OF EDGE TO KEEP
;
;POINTER = NUMBER OF SPACES TO SEND
;
; JSR PUSH_P1		;SAVE P1
 JSR PT_INTO_AX
; JSR AX_MUL_REP_COUNT      ;MULTIPLY DOT-COLUMNS BY HREPS
;
; JSR POP_P1		;RESTORE P1
; JSR PT_INTO_AX		;PASS LENGTH TO PATCH
 JSR PAD_SPACES_PATCH	      ;EXECUTE THE PATCH CODE
 BCS PADDING_DONE	         ;AND PATCH WILL RETURN CS IF IT DID THE WORK
;
 JSR CHANNEL_OUT            ;KEEP TALKING TO PRINTER
.LOOP1014:
;# IS THIS ADJUSTED FOR HREPS?
 LDA #' '		               ;HERE COME THE SPACES
 JSR SEND_A_PT
;
PADDING_DONE:
 LDA OFFSET
 JSR DEC_P2_BY_A            ;P2 = 1ST DOT COLUMN
;
 JSR POP_AX		            ;RESTORE .AX (LINE_LENGTH 0..N)
 LDY OFFSET                 ;ODD PIXELS
 INY                        ;PLUS ONE FOR 1..N+1
 JSR INC_AX_BY_Y	         ;ADD ODD PIXELS TO LINE_LENGTH
 JSR AX_INTO_P4		         ;SET THE LINE LENGTH
;
LINE_STRING:
 STA P_ARG_2
 STX P_ARG_2+1		         ;SET NEW LINE LENGTH
;
;
LINE_START:
;
 JSR START_LINE_PATCH    ;ALTER LINE-START
 BCS .LINE_START_SENT
;
 LDA #1
 JSR OUTPUT_STRING_A	;PRINTER NOW READY FOR P_ARG_2 BYTES OF	DATA
;
.LINE_START_SENT:
 JSR CHANNEL_OUT      ;KEEP TALKING TO PRINTER
;
;P_ARG_2 BECOMES COUNT DOWN, (NO LONGER NEEDED THIS LINE)
;
; LDA PIXELS_IN_SPACE  ;LM NEEDS TO BE SENT BECAUSE
; BNE NEXT_DOT_COLUMN  ;IT WAS NOT HANDLED BY OTHER MEANS
;
; LDA P_ARG_2
; SBC LEFPRT
; STA P_ARG_2
; LDA P_ARG_2+1
; SBC LEFPRT+1
; STA P_ARG_2+1
;
; LDA LEFPRT
; LDX LEFPRT+1
; JSR AX_INTO_PT
;
; JSR PT_EQ_ZERO       ;IS POINTER ZERO?
; LDA POINTER
; ORA POINTER+1         ;IS THIS ZERO?
; BEQ NEXT_DOT_COLUMN
;
; LDA #0
; BIT SPECIAL_EFFECT1
; BVC ?SKP
; LDA #$FF
;?SKP:
; BIT MATRIX_DEFINITION
; BVC ?HIBITOFF
; ORA #$80
;
;?HIBITOFF:
; JSR SEND_A_PT
;
NEXT_DOT_COLUMN:
;
 JSR READ_PLINE_BYTE
;
 BIT MATRIX_DEFINITION	;IS HI-BIT SUPPOSED TO BE ON?
 BVC .HIBITOFF		      ;NO, HI BIT SHOULD STAY OFF
 BIT MATRIX_DEFINITION	;ARE WE SHIFTING IN FROM MSB TO LSB?
 BPL .NO		            ;IF NOT, BITS 0..6 ARE FILLED, SET HI BIT
;
;BITS 7..1 ARE FILLED, SHIFT AGAIN
 ROR POINTER+1		      ;SET TOP BIT UNDEFINED
.NO:
 LDA #$80		            ;SET HI-BIT VALUE
 ORA POINTER+1
 STA POINTER+1	
;
.HIBITOFF:
;
;
;BIT IS NOW COMPLETELY BUILT!
; LDA SPECIAL_EFFECT1	   ;ARE THERE HORIZONTAL REPLICATIONS
; AND #$F		            ;UP TO 15 REPLICATIONS ALLOWED
; STA POINTER		      ;POINTER COUNTS DOWN
;
SEND_BYTES:
 LDA POINTER+1		      ;GET BYTE FOR PRINTER
 JSR BYTE_OUT_PATCH	   ;SEND TO PRINTER
; DEC POINTER	         ;DONE WITH HREPS?
; BPL SEND_BYTES
;
;THIS BYTE AND ALL IT'S HORIZONTAL REPS ARE DONE, CHECK FOR LINE END
;
 SEC
 LDA P_ARG_2		         ;GET LO BYTE
 SBC #1			         ;SUBTRACT 1
 STA P_ARG_2		         ;STORE IT
 BCS .NUM0			         ;SKIP HI BYTE ADJUST IF NO BORROW
 DEC P_ARG_2+1	         ;ADJUST HI BYTE IF BORROW
.NUM0:
 ORA P_ARG_2+1	         ;IS IT ALL ZERO?
 BEQ NO_LINE		         ;BIF ALL DONE WITH THIS LINE
;
 JSR INC_P2_INC		      ;ADD -1 OR +1 TO POINTER, DESTROY .AX
 JMP NEXT_DOT_COLUMN
;
;
NO_LINE:
;
;NEEDS TO BE BUFFERED UP FOR VERTICAL LARGEST VERTICAL STEP
;
 JSR END_LINE_PATCH	;SEND PATCH CODE
;
 LDA #2
 JSR OUTPUT_STRING_A	;SEND END WITH LINE CODES
;
 JSR CLEAR_PLINE      
;
INIT_FOR_PLINE:
 LDA #0
 STA RASTERS_IN_PLINE		;SET TO NO RASTERS IN PLINE
 STA DOTS_PRESENT_IN_BAND	;SET TO NO DOTS ON
 RTS
;
READ_PLINE_BYTE:
;
; INPUT POINTERS:  POINTER2 = BYTE TO READ (0..N-1)
; RETURN REGISTERS: .A = BYTE, MSB = TOP
; RETURN POINTERS:  PT,P1 DESTROYED
;
; LDA PLINE
; STA POINTER1
; LDA PLINE+1
; STA POINTER1+1
;
 LDA #<PLINE_BUFFER
 STA POINTER1
 LDA #>PLINE_BUFFER	;PLINE CAN BE PLACED ANYWHERE (CONSTANT IN WW)
 STA POINTER1+1
;
 JSR P2_INTO_AX		;.AX = BYTE TO READ
 JSR LSR_AX_3      ;DIVIDE AX BY 8
 JSR INC_P1_BY_AX	;ADD .AX TO P1
 LDA POINTER2
 AND #$7		      ;ISOLATE ODD BITS
 TAX			      ;IN .X INDEX
 LDA MATRIX_DEFINITION	;NUMBER PINS IN THIS MATRIX
 AND #$F
 STA POINTER 		;COUNTS DOWN THRU PINS
 LDY #0
 STY POINTER+1		;SHIFT BYTE
 BEQ LOAD_BYTE
;
MOVE_TO_NEXT_BIT:
;
 CLC
 LDA #PLINE_WIDTH
 ADC POINTER1
 STA POINTER1
 BCC LOAD_BYTE
 INC POINTER1+1
;
LOAD_BYTE:
 LDA (POINTER1),Y
 AND BIT_ON,X
 CLC 
 ADC #$FF		;CS IF PIXEL WAS ON, CC ELSE
;
 BIT MATRIX_DEFINITION
 BMI .MSB_BOTTOM
;MSB TOP
 ROL POINTER+1		;PLACE BIT IN PRINTER BYTE (MSB TOP)
 JMP .SKP1189
;
.MSB_BOTTOM:
 ROR POINTER+1		;PLACE BIT IN BUFFER FOR MSB BOTTOM TYPE
.SKP1189:
 DEC POINTER		;ARE WE DONE WITH THIS DOT-COLUMN?
 BNE MOVE_TO_NEXT_BIT	;BIF NOT DONE
;
 LDA POINTER+1		;GET RESULT BYTE
;
 RTS
;
HREP_LINEL_INTO_AX:
 JSR IW_INTO_AX		;GET BYTES/LINE IN AX
!word P_ARG_2
;
AX_MUL_REP_COUNT:
; PHA			;SAVE .A
; LDA SPECIAL_EFFECT1	;GET HREPS COUNT
; AND #$F		;DISREGARD EXTRA STUFF
; TAY			;MULTIPLY LENGTH
; INY			;.Y = BY HREPS + 1
; PLA			;RESTORE .A
; JMP MUL_AX_BY_Y 	;AX CONTAINS TOTAL BYTES TO PRINT
HREP_RTS:
 RTS
;
;
OUTPUT_STRING_A:
;
;.A = 0		INIT_STRING 		.A = 3	END_STRING
;.A = 1		BEGIN_LINE		.A = 4	GRAPHICS_REPEAT
;.A = 2		END_LINE		.A = 5	VRETICAL_STEP
;
 STA SM_3
 TAX
 LDA ARGUMENT_TYPE,X	   ;WHAT IS ARGUMENT TYPE?
 BMI HREP_RTS            ;IF HI BIT SET, GET OUT!
;
 LDA SM_3 
;
 ASL			;*2
 ASL			;*4
 ASL			;*8
 ASL			;*16
;
 TAX			;.X STEPS THRU STRING
 LDY #0		;.Y STEPS 1..X
;
 LDA PRINT_STRINGS-2,X	;GET ARGUMENT POSITION
;
 STA SM_1		            ;ARGUMENT POSITION IN CPY #
;
 LDA PRINT_STRINGS-1,X 	;GET LENGTH OF STRING
 BEQ OSA_ABORT           ;NO STRING!
 STA SM_2		            ;LENGTH OF STRING IN CPY #
;
 STX XSAVE
 JSR CHANNEL_OUT	      ;BE SURE WE ARE TALKING TO THE PRINTER
 LDX XSAVE
;
STRINGS_OUT:
;
SM_1 =  *+1  
 CPY #$FF		      ;ARE WE AT THE ARGUMENT POSITION?
 BNE SENDCHAR		;IF NOT, GO SEND CHARACTER
;			         ;ARGUMENT FOUND
 JSR PUSH_AXY		;SAVE ALL REGS
 JSR PUSH_PT		   ;SAVE POINTER
 JSR PUSH_P1		   ;SAVE POINTER1
;
SM_3 =  *+1
 LDX #$FF     		      ;WHAT IS THE ARGUMENT TYPE INDEX?
;
 LDA ARGUMENT_TYPE,X	   ;WHAT IS ARGUMENT TYPE?
 CMP #1			         ;1) 1 BYTE RAW BINARY?
 BNE .ARG2	
;
 LDA P_ARG_1		         ;GET BYTE TO SEND
 JMP .SENDOUT		      ;SEND TO PRINTER AND CONTINUE
;
.ARG2:
 CMP #2			         ;2) 2 BYTES LO,HI RAW BINARY?
 BNE .ARG3
;
 JSR HREP_LINEL_INTO_AX  ;.AX = LINE LENGTH INCLUDING HREPS
;
 JSR CHARACTER_OUT	      ;SEND LO BYTE TO PRINTER
 TXA
.SENDOUT:
 JSR CHARACTER_OUT	      ;SEND HI BYTE TO PRINTER
;
 JMP .CONTINUE
;
.ARG3:							
 CMP #3	       		   ;3) 4 BYTES ASCII?
 BNE .ARG4
;
 JSR IW_INTO_AX
!word P_ARG_2
 JSR AX_INTO_PT
 LDX #5
 JSR PRTP0               ;MAKE ASCII AT $400
;
 LDX #2
.ASCIIOUT:
;
 LDA VIDEO,X
 JSR CHARACTER_OUT	;SYSTEM VECTORED CHROUT
 INX
 CPX #6
;
 BCC .ASCIIOUT
 BCS .CONTINUE 		;[BRA] DONE SENDING 4 BYTE ASCII
;
.ARG4:
; JMP ?CONTINUE		;4) ASCII W/O LEADING ZEROS?
;
;
.CONTINUE:
 JSR POP_P1        ;RESTORE P1
 JSR POP_PT		   ;RESTORE PT
 JSR POP_AXY       ;RESTORE ALL REGS
;
SENDCHAR:
SM_2 =  *+1
 CPY #$00  		;ARE WE DONE WITH STRING
 BEQ OUT		;BIF DONE SENDING STRING
;
 LDA PRINT_STRINGS,X	;GET CHARACTER TO SEND
 JSR CHARACTER_OUT	;SYSTEM VECTORED CHROUT
 INX			;IN DATA
 INY			;INDEX 0..N
 BNE STRINGS_OUT	;[BRA] GO AGAIN
;
OUT:
;
 JMP CLEAR_CHANNEL
OSA_ABORT:
 RTS 
;
;
;
; HERE COME THE PATCHES
;
V_BYTE_OUT_PATCH:
 JMP (JI_BYTE_OUT_PATCH)        ;EXECUTE CHARACTER-OUT PATCH CODE (1526)
END_PRINT_PATCH:
 JMP (JI_END_PRINT_PATCH)	;EXECUTE END PATCH CODE
START_LINE_PATCH:
 JMP (JI_START_LINE_PATCH)      ;ALTER LINE-START
END_LINE_PATCH:			
 JMP (JI_END_LINE_PATCH)        ;EXECUTE END OF LINE PATCH
PAD_SPACES_PATCH:
 JMP (JI_PAD_SPACES_PATCH)	;EXECUTE CODE BEFORE SPACE PAD, CS = NO PAD
;
V_CHARACTER_OUT:
 JMP (JI_CHARACTER_OUT)		;THE VECTORED ONE
CLEAR_CHANNEL:
 JMP (JI_CLEAR_CHANNEL)		;EXECUTE SYSTEM LEVEL PATCH
CHANNEL_OUT:
 JMP (JI_CHANNEL_OUT)           ;EXECUTE SYSTEM LEVEL PATCH
OPEN_PRINTER:
 JMP (JI_OPEN_PRINTER)		;PATCHED OPEN PRINTER CODE CLC
CLOSE_PRINTER:
 JMP (JI_CLOSE_PRINTER)		;CLOSE PATCH
;
BYTE_OUT_PATCH:
 STX CHR_OUT_TEMP               ;MUST PRESERVE .X .Y
 STY CHR_OUT_TEMP+1
 JSR V_BYTE_OUT_PATCH		   ;EXECUTE SYSTEM LEVEL PATCH
; LDX CHR_OUT_TEMP
; LDY CHR_OUT_TEMP+1
; RTS
 JMP CO_REJOIN
;
CHARACTER_OUT:
 STX CHR_OUT_TEMP           ;MUST PRESERVE .X .Y
 STY CHR_OUT_TEMP+1
 JSR V_CHARACTER_OUT
CO_REJOIN:
 LDX CHR_OUT_TEMP
 LDY CHR_OUT_TEMP+1
 RTS
;
SEND_A_PT:
 TAX
.LOOP1376:
 TXA
 JSR CHARACTER_OUT          ;PRESERVES .X .Y
 JSR DEC_PT_BY_1            ;PRESERVES .X
 ORA POINTER+1
 BNE .LOOP1376
SND_A_ABORT:
 RTS
;
A_CLEAR_RASTERS:
;
 LDX #0
;
AX_CLEAR_RASTERS:
 JSR AX_INTO_PT
;
PT_CLEAR_RASTERS:
;
 JSR PT_EQ_ZERO             ;ARE THERE ANY RASTERS TO DO?
 BEQ SND_A_ABORT            ;EXIT IF NOT
;
 LDA #0
 STA CLR_RAST_TEMP          ;NUM OF RASTERS "WE" SENT
;
.LOOP1400:
 INC CLR_RAST_TEMP
 INC RASTERS_IN_PLINE
 JSR P1_PLS_RASTER_WIDTH
 LDA MATRIX_DEFINITION      ;# OF WIRES
 AND #$F
 CMP RASTERS_IN_PLINE
 BNE .PRINT_LATER
;
 JSR PUSH_PT                ;SAVE # RASTERS
;
 CMP CLR_RAST_TEMP          ;DID WE PUT IN ALL OF THOSE?
 BNE .SEND_BAND
;
 JSR NO_LINE                ;SEND IT QUICKLY
 JMP .RESET_IND 
;
.SEND_BAND:
; JSR PUSH_P3
 JSR PRINT_PLINE
; JSR POP_P3
;
.RESET_IND:
;
 JSR POP_PT                 ;RESTORE # RASTERS
 LDA #0
 STA CLR_RAST_TEMP
 JSR P1_AT_TOP_PLINE
;
.PRINT_LATER:
 JSR DEC_PT_BY_1
 ORA POINTER+1
 BNE .LOOP1400
;
.DONE:
 RTS
;
;
CLEAR_PLINE:
 JSR P1_AT_TOP_PLINE
;
 JSR W_INTO_PT
!word PLINE_PWIDTH;960
 LDA #0               ;SET TO CLEAR
 JMP FILL_PT_P1_A
;
;
EXPAND_4_BITS:
 PHA                  ;SAVE VALUE TO EXPAND
 LDA #4
 STA COUNT_DOWN    
 PLA                  ;RESTORE VALUE TO EXPAND
;
.LOOP1453:
 ASL                ;DATA (TOP) BIT TO CARRY
 PHA                  ;SAVE FOR 2ND USE
 PHP                  ;SAVE CARRY STATUS
 ROL BITROT           ;SHIFT INTO RESULT BYTE
 PLP                  ;RESTORE CARRY
 ROL BITROT           ;SHIFT INTO RESULT BYTE
 PLA                  ;RESTORE CURRENT DATA
 DEC COUNT_DOWN       ;ARE WE DONE?
 BNE .LOOP1453            ;GO DO NEXT BITS
;
 PHA                  ;SAVE NEXT-BYTE DATA
 LDA BITROT           ;EXPANDED BYTE
 STA (POINTER1),Y     ;STORE IN BAND
 PLA                  ;RESTORE NEXT-BYTE
 INY                  ;BUMP INDEX, BNE POSSIBLE
 RTS
;
GHEADER_FOOTER:
;.Y = 0 HEADER
;.Y = 100 FOOTER
;
;
 JSR PUSH_TEXT              ;SAVE CURRENT TEXT POINTER
 JSR PUSH_AX                ;SAVE TOP/BOTTOM MARGIN LENGTH
;
 JSR HEADFOOT_INTO_TEXT_Y   ;POINT TEXT AT HEADER/FOOTER DATA
;
 INC FEATUR		;0 = PRINT GRAPHIC NOW
 LDA CURRENT_FONT
 PHA
 LDA FIRST_CHARACTER_FONT
 PHA
 LDA ATTRIBUTES
 PHA
 LDA JUSTIFY_FORMAT
 PHA
 LDA FONT_LEADING
 PHA 
 LDA USER_DEFINED_LEAD
 PHA 
 LDA EXPAND_ON
 PHA
;
 JSR EXPAND_FONT_OFF        ;TURN OFF EXPANDING BITS
;
 LDA #0
 STA EXPAND_ON
 STA ATTRIBUTES
 STA MERPTR                 ;FLAGS SUBSCRIPTS PRESENT
 STA JUSTIFY_FORMAT
 JSR FIND_BIGGEST_FONT      ;SETUP BIGGEST FOR WHOLE LINE
;
 JSR POP_AX                 ;.AX = HEIGHT OF THIS THING
 CPX #1                     ;IF HB, MARGIN OK
 BCS .FITS
;
 CMP BIGGEST_FONT
 BCS .FITS
 JSR AX_INTO_PT
 JMP .BOTTOM_PORTION
;
.FITS:
;
 LDY BIGGEST_FONT           ;.AX = HEIGHT OF TOTAL MARGIN
 JSR DEC_AX_BY_Y            ;.AX - LINE HEIGHT = LEFT OVER TOP&BOTTOM
 LDY #2                     ;DIVIDE BY 2
 JSR DIV_AX_BY_Y            ;.A WILL BE REMAINDER
 JSR PUSH_PT
;
 LDX POINTER                ;"LEADING"
 STX FONT_LEADING
;
 JSR INC_PT_BY_A            ;ADD REMAINDER (IF ANY) TO PT
;
 LDA FONT_LEADING
;# IS THIS RIGHT?
 AND #$F 
 STA FONT_LEADING           ;SUPRESS TO MAXIMUM
 STA USER_DEFINED_LEAD
 JSR DEC_PT_BY_A            ;AND ADJUST DOWN TO MARGIN.
;
 JSR PT_CLEAR_RASTERS       ;TOP GETS ODD RASTER
;
 JSR PUSH_P1                ;SAVE BAND POINTER
 JSR CLEAR_LINE             ;SETUP FOR 1ST IMAGE
 JSR POP_P1                 ;RESTORE BAND POINTER
;
 LDA LEFPRT
 LDX LEFPRT+1
 JSR PUSH_AX
 LDA MARGIN
 LDX MARGIN+1
 JSR PUSH_AX
;
 JSR READ_HF_MARGINS
 BCC .NO_MARGIN_CHANGE
;
 JSR PUSH_P1
 LDA HF_LEFT_MARGIN
 JSR SET_LEFT_MARGIN 
 LDA HF_LINE_LENGTH
 JSR SET_LINE_MARGIN
 JSR POP_P1              ;RESTORE BAND POINTER
 JSR FIX_LEFT_MARGIN     ;SET NEW LM & R_D_M
;
.NO_MARGIN_CHANGE:
;
 LDY #0
;
.LOOP1563:
 LDX #0
 JSR COPYFIELD
 PHP
 TXA                     ;SET FLAG- IF 0 NO FIELD
 BEQ .NO_FIELD 
;
 LDA #RETURN
 STA EDIT_LINE+1,X
 STY .GHF_SM1
 JSR PUSH_TEXT
 LDA #<EDIT_LINE_P1
 LDX #>EDIT_LINE_P1
 JSR AX_INTO_TEXT 
 JSR PUSH_P1
;
 LDA LEFPRT
 LDX LEFPRT+1
 JSR IMAGE_LINE_AGAIN
;
 LDA SUBSCRIPTS_PRESENT
 ORA MERPTR 
 STA MERPTR 
;
 JSR POP_P1
 JSR POP_TEXT
.GHF_SM1 =  *+1
 LDY #$00 
;
.NO_FIELD: 
 INY
 INC JUSTIFY_FORMAT
 PLP
 BCC .LOOP1563
;
 LDA MERPTR
 STA SUBSCRIPTS_PRESENT
 JSR BUFFER_TO_PLINE
 JSR FINISH_SUBSCRIPTS
 JSR CLEAR_BOTTOM        ;SAVES P1
;
 JSR POP_AX
 STA MARGIN
 STX MARGIN+1
 JSR POP_AX
 STA LEFPRT
 STX LEFPRT+1
 JSR FIX_LEFT_MARGIN     ;RESET LM & R_D_M
;
 JSR POP_PT              ;RESTORE BOTTOM HEIGHT
 LDA FONT_LEADING        ;REDUCE BY LEAD USED
 JSR DEC_PT_BY_A         
;
.BOTTOM_PORTION:
 JSR PT_CLEAR_RASTERS
;
 PLA
 STA EXPAND_ON
 BPL .IS_OFF
 JSR EXPAND_FONT_ON      ;TURN THE BITS ON
;
.IS_OFF: 
 PLA
 STA USER_DEFINED_LEAD
 PLA                     ;RESTORE PARMS
 STA FONT_LEADING        
 PLA
 STA JUSTIFY_FORMAT
 PLA
 STA ATTRIBUTES
 PLA
 STA FIRST_CHARACTER_FONT
 PLA                     ;RESTORE CURRENT_FONT
;
 JSR CHANGE_TO_FONT      ;RELOAD IF NOT CURRENT FONT
;
;?NO_CHANGE:
;
 DEC FEATUR		;0 = PRINT GRAPHIC NOW
 JMP POP_TEXT
;
LOAD_PRINTER_DRIVER:
;
;
;LETTER HI BIT = $0D NORMAL  .GRF
;                $8D DRAFT   .DRF
;                $89 PREVIEW .SCN
;
 LDA LETTER_HI_BIT ;PRINTER DRIVER SELECTION
 CMP #$EA          ;CTRL-RET?
 BEQ .NRM_GRF      ;MAKE REGULAR DRIVER
;
 CMP #$0D          ;NORMAL GRAPHIC .GRF
 BEQ .NRM_GRF
 CMP #$8D          ;NOT SRET = F2, SCREEN
 BNE .SCR_PRE
 LDX #8            ;DRAFT
!byte $2C
.SCR_PRE:
.NRM_GRF:                                  
 LDX #2
;
 LDY #2
.LOOP1666:
 LDA EXTENSION_TABLE,X
 STA PRINTER_DEF_NAME+10,Y
 DEX
 DEY
 BPL .LOOP1666
;
;
 JSR LOAD_ANY_FILE		;MONSTEROUS THING IN SUPPORT.ASM
!byte >PRINTER_DEF_NAME
!byte USE_FONT_DISK
!byte 14
!byte <PRINTER_DEF_NAME
!byte >PRINT_DRIVER_START
!byte <PRINT_DRIVER_START
 BCC .OK
 RTS
;
!if  REMOVE_TEXT { 
;CONVERSION 2019, macro contents cancelled local ?OK
;; LOAD_ANY_FILE:
;; ;
;;  LDX #USE_FONT_DISK
;;  STX REGLOAD    ;USE FONT'S PATH
;; ;
;;  JSR INIDSK     ;CHECK FOR DAMN FILE
;; ;
;;  LDA #14
;;  LDX #<PRINTER_DEF_NAME
;;  LDY #>PRINTER_DEF_NAME
;;  JSR FILE_EXISTS
;;  CMP #$30
;;  BEQ ?OK
;;  JSR CLRCHN     ;CLOSE OUT THE CHANNELS
;;  SEC
;;  RTS
;; ;
;; ?OK
;;  LDA #2
;;  JSR XDEVICEN
;;  LDY #0
;;  JSR SETLFS
;; ;
;;  LDX #<PRINT_DRIVER_START
;;  LDY #>PRINT_DRIVER_START
;;  JSR LOAD          ;ALSO SETS .A 0
;;  JSR CLOSE2
} 
;
.OK:
 LDA LETTER_HI_BIT
 CMP #$EA
 BNE .NO_MIRROR
;
 LDA SPECIAL_EFFECT1
 ORA #$80                ;TURN OR MIRROR MODE
 STA SPECIAL_EFFECT1     ;WILL RE-LOAD DRIVER, THUS RESTORING
;
.NO_MIRROR:
 JSR GET_PRINT_LFS
 STY PSECOND_ADDR
 STX PDEVICE 
;
 LDA #<PRINT_WORK_SPACE
 STA VARIABLE_SPACE
 LDA #>PRINT_WORK_SPACE
 STA VARIABLE_SPACE+1	;AND IS OVERWRITTEN BY PATCH CODE FOR DATASPACE
;
 CLC
LPD_RTS:
 RTS
;
READ_LINE:
;
 LDA #<GRAPHIC_TEXT_LINE
 STA TEXT
 LDA #>GRAPHIC_TEXT_LINE
 STA TEXT+1
;
CHANNEL_IN_READWD:
 JSR CHNL2I
 JSR READWD
 JMP CLRCHN
;
;
BLANK_THE_SCREEN: 
;
 LDA BLNKSCRN
 CMP #'Y'
 BNE LPD_RTS
 JMP VIC_SCREEN_OFF      ;SHUT_DOWN SCREEN FOR SPEED
;
;
GPRINT_DRAW_BOX:
; LDA #<GPRINT_BOX
; LDX #>GPRINT_BOX
; JSR AX_INTO_MSGOUT
; JSR W_INTO_MSGOUT
; DW GPRINT_BOX
;
 LDA #11  ;CBOFFSET
 JSR PULLDN ;DRAW THE BOX
!word GPRINT_BOX
 RTS
;
LOAD_GRAPHIC_IF_NEEDED:
;
;DO NOT HARM CARRY
;
 LDA GRAPHIC_X_OFFSET           ;IS THERE A GRAPHIC?
 BMI .NO_GRAPHIC1776                ;$FF = NO, ELSE LEFT MARGIN
;
 LDA SCAN_LINES
 ORA SCAN_LINES+1
 BNE .FILE_LOADED
;
 PHP
 JSR OPEN_IMG_FILE
 PLP
;
.FILE_LOADED:
.NO_GRAPHIC1776:
 RTS
;
;
GPRINT_BOX: 
!byte 16
!byte $FF,64,14
!text "  PRINTING...  "
!text "RUN/STO",'P'-64,'T','O'-64,"END"
!byte $FF,64,14,0
;
GPRINT_WARN_BOX:
 JSR CLRBLK
; LDA #<GPRINT_WARNING
; LDX #>GPRINT_WARNING
; JSR AX_INTO_MSGOUT
; JSR W_INTO_MSGOUT
; DW GPRINT_WARNING
;
 LDA #9         ;CBOFFSET
 JSR PULLDN     ;DRAW THE BOX
!word GPRINT_WARNING
 RTS
;
GPRINT_WARNING: 
!byte 21
!byte $FF,64,19
!text " YO",'U'-64,"MUS",'T'-64,"SAV",'E'-64,"THI",'S'-64
!text "FIL",'E'-64,"BEFOR",'E'-64,"PRINTING"
!byte $FF,64,19,0
;
!eof
;
; PUBLIC BLANK_THE_SCREEN
; PUBLIC BUFFER_TO_PLINE
; PUBLIC CHANNEL_IN_READWD
; PUBLIC GPRINT_FILE
; PUBLIC GPRINT_WARN_BOX
; PUBLIC IN_GRAPHICS_PRINT
; PUBLIC PLINE_WIDTH
; PUBLIC P2INC
; PUBLIC RIGHT_DOT_MARGIN
; EXTERN SET_VMARGINS
; EXTERN ADJUST_DOTC
; EXTERN ASL_AX
; EXTERN ASL_AX_Y
; EXTERN A_MIN_CUR_PAGE_LENGTH
; EXTERN A_PLS_CUR_PAGE_LENGTH
; EXTERN ASCTYP
; EXTERN AX_INTO_CUR_PAGE_LENGTH
; EXTERN AX_INTO_MSGOUT
; EXTERN AX_INTO_PT
; EXTERN AX_INTO_P1
; EXTERN AX_INTO_P2
; EXTERN AX_INTO_P3
; EXTERN AX_INTO_P4
; EXTERN AX_INTO_TEXT
; EXTERN BAD_HEADER
; EXTERN BDRBAK
; EXTERN BIGGEST_DESCEND
; EXTERN BIGGEST_FONT
; EXTERN BIT_ON
; EXTERN BLNKSCRN
; EXTERN BOTTOM_MARGIN
; EXTERN BYTES_PER_LINE
; EXTERN CHANGE_TO_FONT
; EXTERN CHKIN
; EXTERN CHNL2I
; EXTERN CLEAR_BOTTOM
; EXTERN CLEAR_LINE
; EXTERN CLOSE2
; EXTERN CLOSE
; EXTERN CLRBLK
; EXTERN CLRCHN
; EXTERN CLOSE15
; EXTERN COPYFIELD
; EXTERN CLALL
; EXTERN DC_BY8_INTO_AX
; EXTERN DEC_AX_BY_1
; EXTERN DEC_AX_BY_PT
; EXTERN DEC_AX_BY_P2
; EXTERN DEC_AX_BY_Y
; EXTERN DEC_PT_BY_A
; EXTERN DEC_PT_BY_1
; EXTERN DEC_P2_BY_A
; EXTERN DEC_P2_BY_1
; EXTERN DIV_AX_BY_Y
; EXTERN DISPLY
; EXTERN DISPLAYOFF
; EXTERN DOCHKM
; EXTERN D_PIXELS_PER_LINE
; EXTERN EDIT_LINE
; EXTERN EDIT_LINE_P1
; EXTERN EXPAND_FONT_ON
; EXTERN EXPAND_FONT_OFF
; EXTERN EXTENSION_TABLE
; EXTERN FC_CLEAR_HOME
; EXTERN FC_DELETE_TO_EOL
; EXTERN FEATUR
; EXTERN FILE_EXISTS
; EXTERN FILE_STATUS
; EXTERN FILL_PT_P1_A
; EXTERN FIND_BIGGEST_FONT
; EXTERN FIRST_CHARACTER_FONT
; EXTERN FIRST_LINE
; EXTERN FIRST_PAGE
; EXTERN FONT_IN_FAKE_FONT
; EXTERN FONT_LEADING
; EXTERN FONT_START
; EXTERN GET_PRINT_LFS
; EXTERN GETIN1
; EXTERN GRAPHIC_EFFECT
; EXTERN GRAPHIC_TEXT_LINE
; EXTERN GRAPHIC_X_OFFSET
; EXTERN GRAPHIC_FILENAME
; EXTERN GRAPHIC_RASTER_BUFFER
; EXTERN HEADER_FOOTER_TEXT
; EXTERN HEADFOOT_INTO_TEXT_Y
; EXTERN HF_LEFT_MARGIN
; EXTERN HF_LINE_LENGTH
; EXTERN IMAGE_LINE
; EXTERN IMAGE_LINE_AGAIN
; EXTERN INCAP1
; EXTERN INC_AX_BY_1
; EXTERN INC_AX_BY_P2
; EXTERN INC_AX_BY_TEMP
; EXTERN INC_AX_BY_Y
; EXTERN INC_PT_BY_A
; EXTERN INC_PT_BY_AX
; EXTERN INC_PT_BY_P1
; EXTERN INC_P1_BY_AX
; EXTERN INC_P1_BY_A
; EXTERN INC_P2_BY_AX
; EXTERN INC_P2_BY_1
; EXTERN INC_P2_INC
; EXTERN INC_P3_BY_A
; EXTERN INC_P3_BY_AX
; EXTERN INIDSK
; EXTERN IW_INTO_AX
; EXTERN JUSTIFY_FORMAT
; EXTERN L_BUFFER_DEPTH
; EXTERN LEFPRT
; EXTERN LETTER_HI_BIT
; EXTERN LINE_BUFFER
; EXTERN LINE_BUFFER_E
; EXTERN LINE_SIZE
; EXTERN LOAD
; EXTERN LOAD_ANY_FILE
; EXTERN LOAD_FONT
; EXTERN LSR_AX
; EXTERN LSR_AX_3
; EXTERN MUL_AX_BY_Y
; EXTERN MUL_AX_PT
; EXTERN NUMBER_OF_COPIES
; EXTERN OPEN_A_DV_15
; EXTERN OPEN_IMG_FILE
; EXTERN OPEN_15_NO_NAME
; EXTERN OPEN_USER_FILE_1
; EXTERN OPEN_USER_FILE_2
; EXTERN PATTERN_BYTES
; EXTERN PAGE_FORCED
; EXTERN PAGE_LENGTH
; EXTERN PIXELS_PR_LINE
; EXTERN PLINE_BUFFER
; EXTERN P1_INTO_P2
; EXTERN P2_INTO_AX
; EXTERN P2_INTO_PT
; EXTERN P2_INTO_P1
; EXTERN P3_INTO_AX
; EXTERN P4_INTO_AX
; EXTERN PRINTER_DEF_NAME
; EXTERN PRINT_WORK_SPACE
; EXTERN PT_EQ_ZERO
; EXTERN PT_INTO_AX
; EXTERN PT_INTO_P1
; EXTERN PT_INTO_P2
; EXTERN POP_A
; EXTERN POP_AX
; EXTERN POP_AXY
; EXTERN POP_PT
; EXTERN POP_P1
; EXTERN POP_TEXT
; EXTERN POP_X
; EXTERN POP_Y
; EXTERN POP_P3
; EXTERN PUSH_P3
; EXTERN PUSH_A
; EXTERN PUSH_AX
; EXTERN PUSH_AXY
; EXTERN PUSH_PT
; EXTERN PUSH_P1
; EXTERN PUSH_TEXT
; EXTERN PUSH_X
; EXTERN PUSH_Y
; EXTERN PULLDN
; EXTERN PRTP0
; EXTERN PW_S_EJECT_PAGE
; EXTERN READWD
; EXTERN READ_HF_MARGINS
; EXTERN READ_IMG_RASTER
; EXTERN REGLOAD
; EXTERN SCAN_LINES
; EXTERN SERPPT
; EXTERN SETLFS
; EXTERN SET_AX_LM_LL
; EXTERN SETNAM
; EXTERN SET_FONT
; EXTERN SET_LEFT_MARGIN
; EXTERN SET_LINE_MARGIN
; EXTERN SETUP_RW_NO_CASE_MOD
; EXTERN STATUS
; EXTERN STATUS_DEFAULT_IN
; EXTERN GFNAME_SAVE
; EXTERN STPAGE
; EXTERN SUBSCRIPTS_PRESENT
; EXTERN TEXCF0
; EXTERN TOP_AREA
; EXTERN TOP_MARGIN
; EXTERN TXCOLR
; EXTERN USER_DEFINED_LEAD
; EXTERN W_INTO_AX
; EXTERN W_INTO_PT
; EXTERN W_INTO_P1
; EXTERN W_INTO_P2
; EXTERN W_INTO_P3
; EXTERN W_INTO_P4
; EXTERN VIC_SCREEN_OFF
; EXTERN XDEVICEN
; EXTERN W_INTO_MSGOUT
; EXTERN ZERO_INTO_CUR_PAGE_LENGTH
