;
!zone EDITLN;Edit Line Routine 6502 4/22/88 
;
!SOURCE "WWSETUP.ASM"
!SOURCE "VARIABLS.ASM"
;
;
;DUE TO INVISIBLE CODES IN THE LINES:
;   COUNT:         NUMBER OF BYTES/CHARACTERS UP TO FIRST CHARACTER ON
;   COLUMN:        PHYSICAL SCREEN POSITION 0..39 FOR CURRENT CURSOR
;   CURRENT_CHAR:  INDEX (BYTES) TO THE CHARACTER CURRENTLY BEING EDITED
;   ACTUAL_COLUMN: NUMBER OF PRINTABLE CHARACTERS UP TO AND INCLUDING
;                  CURRENT_CHAR
;   CHARS_IN_LINE: NUMBER OF BYTES IN THIS LINE
;
;
;THIS MODULE'S COMPILATION ALLEGENCE IS TO THE MINI DATABASE
;NO CALL TO THE OUTLINER MAY BE PRESENT.  DIRECT CALLS TO THE
;MINI-DATABASE MAY BE MADE ONLY WHEN IT IS KNOWN TO BE IN MEMORY.
;COMPLIATION ALLIEGENCE IS TO THE MINI DATABASE ONLY.
;
; PUBLIC FC_CLEAR_ALL_TABS
;PUBLIC FC_END_OF_RECORD
; PUBLIC FC_TOGGLE_TAB
; PUBLIC MOVE_TO_COLUMN_A
;
;
;
; EXTERN ALLSCN
; EXTERN IN_DATABASE_MODE
; EXTERN MAXIMUM_LINES_M2
; EXTERN OV_ALLOW_CURSOR_DOWN		;MINIDB,TABLED
; EXTERN OVR_SORT_FIELDS			;MINIDB,TABLED
; EXTERN PROHIBIT_RESTORE
;EXTERN TEXT_PLS_CURCAR_AT_EOT
;
MAX_TABS =  20
;
;
WK_DONE:
 RTS
;
WORK_KEY:
;
; LDX LINE_LENGTH
; STX $400
; LDX LINE_LENGTH+1
; STX $401
;*REMOVE*
;
 LDX CURRENT_CHAR
 LDY EDIT_LINE,X
 CPY #CMARK           ;IS CURRENT_CHARACTER CHECK
 BEQ .CHAR_RIGHT      ;PROTECT CHECKMARK
;
 BIT INSERTM          ;IN INSERT MODE?
 BPL .OVERSTRIKE      ;NO,BRANCH
;
 LDX CHARS_IN_LINE
 CPX #MAX_LINE_LENGTH
 BCS WK_DONE 
;
 JSR FC_INSERT_CHAR   ;PLACE A SPACE IN TEXT
;
;# DISPLAY CURRENT_LINE
;
 LDA #' '             ;AND REMOVE
 JSR DELETE_FROM_LINE ;IT'S WIDTH
;
 LDA CURRENT_KEY      ;RETRIEVE REAL CHARACTER
 JSR PLACE_CHARACTER  ;PUT THE CHARACTER IN TEXT
 LDA CURRENT_KEY      ;RETRIEVE REAL CHARACTER AGAIN
.NEXT_CHAR:
 JSR ADD_TO_LINE      ;ADD THE CHARACTER WIDTH TO THE LINE
.CHAR_RIGHT:
;
 JSR DISPLAYOFF
 LDA COUNT
 PHA
 JSR FC_CURSOR_RIGHT  ;MOVE CURSOR OVER ONE
 LDA #1
 STA EDIT_BUFFER_CHANGED
;
 LDA CURRENT_KEY
 CMP #' ' 
 BNE .NO_WRAP
;
 JSR WRAP_LINE        ;WRAP LINE IF NEEDED
 PLA
 BCS DISPLAY_ON_AND_LINE_OUT 
!byte $24;BIT ZP
;
.NO_WRAP:
 PLA
 CMP COUNT 
 BNE DISPLAY_ON_AND_LINE_OUT
;
; BCS DISPLAY_ON_AND_LINE_OUT
;
; BCC WK_DONE
;*NOTE* REMOVED 1-9-91
; LDA #$20
; STA DISPLY
; JMP ACTUAL_COLUMN_OUT
 JMP DISPLAY_ON_AND_LINE_OUT
; RTS
;
;
.OVERSTRIKE:
 LDY CURRENT_CHAR  ;COUNTS 0..N-1
 CPY #MAX_LINE_LENGTH-1
 BCS WK_DONE 
;
 INY               ;IF ONE LESS THAN TOTAL (BY EOL)
 CPY CHARS_IN_LINE ;THEN MUST ADJUST EOL  (COUNTS 1..N)
 BNE .PUT_CHAR     ;OTHERWISE, GO PLACE CHARACTER
;
;
.LENGTH_OK:
 PHA
 LDA EDIT_LINE,Y
 STA EDIT_LINE+1,Y    ;MOVE EOL
;
 LDA #' '
 STA EDIT_LINE,Y
 JSR ADD_TO_LINE
 INC CHARS_IN_LINE
 PLA
;
.PUT_CHAR:
 PHA
 PHA
 LDX CURRENT_CHAR
 LDA EDIT_LINE,X
 BPL .NOT_CODE
 PHA 
 JSR UPDATE_ATTRIBUTES_CL
 PLA  
;
.NOT_CODE: 
 JSR DELETE_FROM_LINE
 PLA
 JSR PLACE_CHARACTER
 PLA
 JMP .NEXT_CHAR
;
DISPLAY_ON_AND_LINE_OUT_R:
 JSR RESET
DISPLAY_ON_AND_LINE_OUT:
; LDA #$20
; STA DISPLY
 JSR DISPLAY_ON_NO_DISPLAY
;
DISPLAY_AND_LINE_OUT:
 JSR DISPLY
 JSR FC_LINE_OUT
 JMP ACTUAL_COLUMN_OUT
;
;
PLACE_CHARACTER:
 LDY CURRENT_CHAR
 STA EDIT_LINE,Y
 CMP #$81             ;SYSTEM MARK?
 BEQ BCC_OUT          ;DO NOT SHOW
 LDY COLUMN
 STA (SCREEN),Y
 CMP #$80
 BCC BCC_OUT
 JMP UPDATE_ATTRIBUTES_CR
;
;
BUMP_COLUMN_COUNT:
 LDY COLUMN           ;ADJUST COLUMN/COUNT UP ONE
 CPY #$25 
 BCC .INCREMENT_COLUMN
 INC COUNT 
 JMP DISPLY  ;(RTS)
;
.INCREMENT_COLUMN:
 INC COLUMN
BCC_OUT:
 RTS
;
DBUMP_COLUMN_COUNT:
 LDY COLUMN           ;ADJUST COLUMN/COUNT DOWN ONE
; BEQ ?ADJUST_COUNT
 BEQ ADJUST_COUNT
 DEC COLUMN
;?DBCC_ABT:
DCC_RTS:
 RTS
;
;?ADJUST_COUNT:
ADJUST_COUNT:
 LDA COUNT
 BEQ DCC_RTS
 DEC COUNT
 JMP DISPLY
;
SPECIAL_KEYS:
;
;
FC_INS_RETURN:
;
;#WATCH OUT!
 LDY #3
 JSR EOM_TEST_PLUS_Y           ;IF SO, ADD NEW STUFF
 BCC .SKP
 JMP LINE_OUT_AND_DISPLAY
;
.SKP:
 JSR EDIT_BUFFER_TO_TEXT       ;FLUSH TEXT TO BUFFER
 LDY CURRENT_CHAR
 BNE .NOT_FIRST_COLUMN         ;IF IN COLUMN 0, DO INSERT_LINE
 JMP FC_INSERT_LINE
;
.NOT_FIRST_COLUMN: 
 INY
 CPY CHARS_IN_LINE
 BEQ .OVERSTRIKE0541               ;OR IF AT END OF LINE
;
 TYA
 PHA
 JSR FC_BEGINNING_OF_LINE 
 JSR PUSH_TEXT
 PLA
 JSR ADDATX           ;POINT TEXT AT BREAK
 JSR MOVE_UP_ONE
 LDY #0
; LDA #RETURN
; STA (TEXT),Y
 JSR RET_AT_TEXT_Y
;# STORE RET.. STCR
 JSR POP_TEXT
 JSR TEXT_TO_EDIT_BUFFER
 JSR FC_CURSOR_DOWN
 JSR DISPLAYON
 JMP FC_WRAP_LINE
;
.OVERSTRIKE0541:
;
FC_RETURN:
;
; JSR OV_ALLOW_CURSOR_DOWN
; BCS DCC_RTS
;
 LDA MOVE_COPY_HL     ;S/B 0 OR $80
 BEQ .NORM_RETURN
;
 JMP END_SELECT
;
.NORM_RETURN:
;
 LDA LINE
 ORA PAGE
 CMP #1
 BNE .GO
;
 LDA EDIT_LINE
 CMP #CMARK
 BNE .GO
 JMP FC_CURSOR_DOWN_DSP
;
.GO:
 LDA #3
 STA EOM_SAFETY_FUDGE 
;
 JSR RET_CSDOWN_CODE
 BNE SRET1 ;NOT ON EOT, GO DO RETURN
;
FC_NEWLINE:
;
.MEM_OK:
 JSR TEXT_PLS_RETSPCEOT
 JSR INCEO1
 JSR INCEO1
 JSR INCTE1
;
SRET1:
 JSR GO_LEFT_MARGIN
;
 JSR TEXT_TO_EDIT_BUFFER
 JSR CALCULATE_LINE_LENGTH  ;SET LINE LENGTH
;
DISPLAY_INC_LINE:
 JSR SCROLL_UP_TEST
 JSR UPDATE_LINE_COUNTD
;
 LDA CHECKMARK_LINE_EDITED  ;NEED A FORMAT?
 BEQ LINE_OUT_AND_DISPLAY   ;BIF NOT FLAGGED
 LDA EDIT_LINE              ;CAN'T DO ON A CM LINE
 CMP #CMARK                 ;BIF SO
 BEQ LINE_OUT_AND_DISPLAY
 LDA #0                     ;FLAG FORMAT NOT NEEDED
 STA CHECKMARK_LINE_EDITED 
 JSR FC_REFORMAT_FROM_CURSOR;DO IT
 JSR RESET
;
LINE_OUT_AND_DISPLAY:
;
 JSR LINE_OUT
 JMP DISPLY
;
;
SUPRESS_FORMAT:
!byte $FF
;
FC_DELETE_CHAR:
 LDA ATTRIBUTES
 PHA
 LDA CURRENT_FONT
 PHA
 JSR FC_CURSOR_LEFT
 PLA
 STA CURRENT_FONT
 PLA
 STA ATTRIBUTES
;
FC_DELETE_CHAR_RT:
;
 JSR CURRENT_CHARACTER_Y
 CMP #CMARK          
 BNE .NOT_CM
 CPY #2
 BCC .ABORT 
;
.NOT_CM: 
 LDA CHARS_IN_LINE  ;IF THERE IS MORE THAN ONE CHAR
 CMP #1
 BNE .DELETE_CHAR  ;GO DO A SHIFT
;
;## MUST RE-SIZE LINE HERE (CHAR WIDTH CAN CHANGE)
 LDA #$20          ;OTHERWISE
 STA EDIT_LINE     ;TURN CURRENT CHARACTER TO SPACE
 LDY #0
 STA (SCREEN),Y
 JMP CHANGED_EDIT_BUFFER
;
.DELETE_CHAR:
 LDX CURRENT_CHAR
 LDA EDIT_LINE+1,X
 CMP #ENDT
 BCS .BESIDE_END_LINE
;
 LDA EDIT_LINE,X
 PHA
 JSR DELETE_FROM_LINE
;
 PLA
 STA CURRENT_KEY            ;CHAR WE DELETED
 BPL .DEL_LOOP
;
 JSR UPDATE_ATTRIBUTES_CL
 LDX CURRENT_CHAR
 BNE .DEL_CHAR 
 LDX CURRENT_FONT
 STX START_LINE_FONT
;
.DEL_CHAR:
 LDX CURRENT_CHAR
;
.DEL_LOOP:
;##DO NOT DEL FONT CHANGE CODE  CFC
 LDA EDIT_LINE+1,X
 STA EDIT_LINE,X
 INX
 CPX CHARS_IN_LINE
 BNE .DEL_LOOP
 DEC CHARS_IN_LINE
;
 LDX CURRENT_CHAR           ;IF CHAR WE MOVED TO IS EMB
 LDA EDIT_LINE,X            ;SET HIS STYLE!
 BPL .RE_ENTER
 JSR UPDATE_ATTRIBUTES_CR
;
.RE_ENTER:
 LDA CURRENT_KEY
 BPL .ABORT
 JSR UPDATE_CURRENT_LINE_DEPTH
 LDA SUPRESS_FORMAT
 BEQ .ABORT
 LDA CURRENT_KEY
 JSR IS_FONT_OR_BOLD
 BCC .ABORT                 ;ONLY IF FONT OR BOLD
 JSR FC_REFORMAT_FROM_CURSOR
 JSR DISPLAY_ON_AND_LINE_OUT_R
;
.ABORT:
;*NEW*
 LDA TAB_PRESENT_IN_LINE
 BEQ .NO_TAB
;
 JSR FIX_ACTUAL_COLUMN
;
.NO_TAB:
 JMP UPDATE_CURRENT_SCREEN_LINE
;
;
.BESIDE_END_LINE:
 LDA EDIT_LINE,X
 PHA
 JSR DELETE_FROM_LINE
 PLA
 STA CURRENT_KEY            ;CHAR WE DELETED
 BPL .CHANGE_TO_SPACE
 JSR UPDATE_ATTRIBUTES_CL
;
.CHANGE_TO_SPACE: 
 LDX CURRENT_CHAR
 LDA #' '
 STA EDIT_LINE,X
 JSR ADD_TO_LINE      ;ADD THE CHARACTER WIDTH TO THE LINE
 JMP .RE_ENTER
;
;
FC_CURSOR_LEFT:
 LDX CURRENT_CHAR
 BEQ CL_RTS
 LDA EDIT_LINE,X
 BPL .SKP0741
 JSR UPDATE_ATTRIBUTES_CL
.SKP0741:
 DEC CURRENT_CHAR
 JSR DEC_ACTUAL_COLUMN		;DOES NOTHING IF TAB FOUND
 JMP DBUMP_COLUMN_COUNT
CL_RTS:
 RTS
;
;
FC_CURSOR_RIGHT:
 LDY CURRENT_CHAR
 INY
 CPY CHARS_IN_LINE    ;ARE WE ONE LESS THAN EOL CHAR (DISALLOW ON EOL)
 BEQ .CHECK_EXTEND
;
.BUMP_CHAR:
 INC CURRENT_CHAR
 LDX CURRENT_CHAR
 LDA EDIT_LINE,X
 BPL .SKP0761
 JSR UPDATE_ATTRIBUTES_CR
.SKP0761:
 JSR INC_ACTUAL_COLUMN
 JSR BUMP_COLUMN_COUNT
 LDX #1               ;FLAG NOT ON EOL DEPENDS ON BEQ/BNE FLAG
.CR_ABT:
 RTS
;
.CHECK_EXTEND:
 LDX CURFLG
 BEQ .CR_ABT           ;LEAVE IF NO EXTEND ALLOWED .X = 0
;
FC_SPACE_IN_TEXT:
 LDA #' '
!byte $2C
FC_TAB_IN_TEXT:
 LDA #TABCHAR
!byte $2C
PUT_END_OF_RECORD:
 LDA #ENDREC
FC_WORK_KEY:
 STA CURRENT_KEY
 JMP WORK_KEY         ;MAKE AS IF USER PRESSED SPACE
;
;
FC_WORK_KEY_INS: 
 STA CURRENT_KEY
 LDA INSERTM
 PHA
 LDA #$80
 STA INSERTM
;
 LDA CURRENT_KEY
 JSR WORK_KEY         ;MAKE AS IF USER PRESSED SPACE
 PLA
 STA INSERTM
 RTS
;
;
FC_CURSOR_UP_DSP:
 JSR FC_CURSOR_UP
DISPLAY_AND_LINOUT:
;
 JMP DISPLAY_ON_AND_LINE_OUT
CURSU_ABT:
 RTS
;
FC_CURSOR_UP:
 JSR START_OF_TEXT          ;ARE WE ON THE FIRST LINE?
 BEQ CURSU_ABT              ;YES, EXIT
;
 JSR OV_ALLOW_CURSOR_UP
 BCC .OK
 JMP FC_PAGE_BACKWARD
.OK:
;
FC_CURSOR_UP_1:
;
 LDA #0
 STA NEW_LINE_SPACE         ;2 CU'S SHOULD CANCEL
 STA PAGE_FORCED            ;WE FOUND A DAMN 'P'
;
 JSR EDIT_BUFFER_TO_TEXT    ;STORE OFF CURRENT LINE
;
 LDA BIGGEST_POINTSIZE
 STA CU_TEMP                ;THIS LINE'S BIGGEST FONT HEIGHT
 LDA CURRENT_CHAR
 PHA                        ;AND INDEX
;
 LDA EDIT_LINE              ;GET 1ST CHAR
 STA FIRST_CHAR_F           ;FIRST CHAR LINE MOVED FROM
 CMP #CMARK                 ;CHECK MARK LINE?
 BEQ .CMARK_LINE
;
 JSR FC_BEGINNING_OF_LINE   ;KILLS DISPLAY, NO RESTORE
 LDA EDIT_LINE              ;UPDATE ATTRIBUTES IF 1ST CHAR
 BPL .SKP2                  ;MAY BE FONT/STYLE
 JSR UPDATE_ATTRIBUTES_CL
 JMP .SKP2
;
.CMARK_LINE:
;
 JSR FIND_PREV_MARGIN
;
.SKP2:
 JSR TEXT_TO_PREV_LINE
 JSR TEXT_TO_EDIT_BUFFER    ;CHARS_IN_LINE = LENGTH OF THIS LINE
;
 LDA EDIT_LINE              ;DID WE MOVE TO A CHECKMARK LINE?
 CMP #CMARK                 ;CHECK MARK LINE?
 BNE .FONT_MODE                 
;
 JSR SEARCH_BACK_THRU_CHECKS;FIND PREV \P AND SET FP FLAG
;
.FONT_MODE:
 LDX CHARS_IN_LINE
 DEX
 TXA
 STX CURRENT_CHAR
;
;IF TEXT MODE & TAB_PRESENT (ADD TO TEXTTOEDITBUFFER) THEN
;CALL CALCULATE_LINE_LENGTH, AND USE
 LDX TAB_PRESENT_IN_LINE	;IS THERE A TAB IN LINE?
 BEQ .NO_TAB_IN_LINE		;IF NOT, DO AS BEFOR
;
 LDX CURRENT_FONT		;IF IN FONT MODE
 BPL .NO_TAB_IN_LINE		;THEN DO AS BEFORE
 PHA
 JSR CALCULATE_LINE_LENGTH1
 LDX LINE_LENGTH
 PLA
 JMP .TAB_IN_LINE
;
.NO_TAB_IN_LINE:
 LDX PRINTABLE_CHARACTERS
.TAB_IN_LINE:
 STX ACTUAL_COLUMN
;
 JSR SET_CC_FROM_A
;
 JSR FC_BEGINNING_OF_LINE   ;UPDATE CURRENT_FONT/STYLE
;
 LDA EDIT_LINE
 BPL .SKP3
 CMP #TABCHAR
 BEQ .SKP3			;IF TAB, ACTUAL_COLUMN NOW SET
 JSR UPDATE_ATTRIBUTES_CR
.SKP3:
;
 JSR CALCULATE_LINE_LENGTH  ;SET LINE LENGTH
;
 PLA                        ;COLUMN WE SHOULD MOVE TO
 JSR COL_A_OR_END_LINE      ;MOVE TO COL .A OR END OF LINE
;
.AT_END:
;
 JSR SCROLL_DOWN_TEST
 JMP UPDATE_LINE_COUNTU
;
;
;
FC_CURSOR_DOWN_DSP:
 JSR FC_CURSOR_DOWN
 PHP
 JSR DISPLAY_ON_AND_LINE_OUT
 PLP
 RTS
;
;
FC_CURSOR_DOWN:
;
 LDX CHARS_IN_LINE
 LDA EDIT_LINE,X
 CMP #ENDT
 BEQ .NOT_DOWN
;
 JSR DISPLAYOFF
 JSR RET_CSDOWN_CODE        ;NEXT LINE & EOT CHECK (PROCESS MARGINS)
 BNE .SKP0920
;
.NOT_DOWN:
 SEC                        ;SEC = LAST LINE FOUND
 RTS
;
.SKP0920:
 JSR CALCULATE_LINE_LENGTH
 JSR SEARCH_COL_POSITION    ;PLACE CURSOR AT ACTUAL_COLUMN OR EOL,
;
 JSR DISPLAY_INC_LINE
;
 CLC                        ;CLC = DID MOVE DOWN
 RTS                  
;
;
FC_BEGINNING_OF_LINE_DSP:
 JSR FC_BEGINNING_OF_LINE
 JMP DISPLAY_ON_AND_LINE_OUT
;
FC_BEGINNING_OF_LINE:
 JSR DISPLAYOFF
;
.LOOP:
 JSR FC_CURSOR_LEFT
 LDA CURRENT_CHAR
 BNE .LOOP
;
.DONE:
 RTS
;
;
FC_END_OF_LINE:
 JSR DISPLAYOFF
 LDA CURFLG  ;EXTEND OR NOT
 PHA         ;SAVE STATUS
 LDA #0 
 STA CURFLG  ;DO NOT EXTEND
.BUMP_RIGHT:
 JSR FC_CURSOR_RIGHT
 BNE .BUMP_RIGHT
 PLA
 STA CURFLG  ;RESTORE PREV STATUS.
 JMP DISPLAY_ON_AND_LINE_OUT
; JMP ON_AND_REFREASH
;
;
FC_INSERT_CHAR:
;
 LDX CHARS_IN_LINE       ;IF ROOM FOR CHARACTERS
 CPX #MAX_CHARS_IN_LINE
 BCC .INSERT_CHAR        ;GO DO A SHIFT
 RTS                     ;ELSE EXIT
;
.INSERT_CHAR:
;
 LDX CHARS_IN_LINE	;GET TOTAL # OF CHARS
 INX			;CHARS_IN_LINE + 1
.INS_LOOP:
;
 DEX
 LDA EDIT_LINE,X
 STA EDIT_LINE+1,X
 CPX CURRENT_CHAR
 BNE .INS_LOOP
 LDA #' '
 STA EDIT_LINE,X
 JSR ADD_TO_LINE   ;ADD SIZE OF SPACE TO LINE
 INC CHARS_IN_LINE
;
 LDX TAB_PRESENT_IN_LINE
 BEQ UPDATE_CURRENT_SCREEN_LINE
 LDX CURRENT_FONT
 BPL UPDATE_CURRENT_SCREEN_LINE
;
;THERE IS A TAB IN THE LINE, AND WE ARE IN TEXT MODE
 STY .Y_TEMP
 LDY CURRENT_CHAR
 STY CLL_INTERRUPT_POINT
;
 JSR CALCULATE_LINE_LENGTH
 LDY CUR_LEFT_FLAG_RESULT1
 STY ACTUAL_COLUMN
 LDY #$FF
 STY CLL_INTERRUPT_POINT
 JSR ACTUAL_COLUMN_OUT
 JSR FC_WRAP_LINE
;
!byte $A0;LDY #
.Y_TEMP:
!byte $FF
;
UPDATE_CURRENT_SCREEN_LINE:
 INC EDIT_BUFFER_CHANGED
 JMP SHOW_CURRENT_LINE
;
;
FC_HOME_CURSOR:
 JSR FC_BEGINNING_OF_LINE   ;KILLS DISPLAY, NO RESTORE
 JSR EDIT_BUFFER_TO_TEXT
;
 LDA CURRENT_SCREEN_LINE
 BNE .PART_SCREEN
;
;CURSOR IS ALREADY HOME, MOVE UP 1/2 SCREEN LINES
;*NOTE* REWRITE TO SAVE SPACE
; LDX SCREEN_SECTION         ;0 OR 1 FOR SPLIT-SCREEN
; LDA END_SCREEN,X           ;ARE WE AT THE END OF THIS SECTION?
; CLC
; ADC #1
; LDA MAXIMUM_LINES		;LINES ON SCREEN (CARDFILE/REGULAR)
; CMP #23
; BEQ ?PART_SCREEN
; LDA #1
 LDA IN_DATABASE_MODE		;1 LINE IN DATABASE MODE
 BNE .PART_SCREEN  
 LDA #23			;23 LINES NORMAL
;
.PART_SCREEN:
 JSR REPEAT_NODISPLAY       ;SET COUNTDOWN .A AND OFF DISPLAY
;
.LOOP1041:
 JSR FC_CURSOR_UP
 DEC COUNT_DOWN
 BNE .LOOP1041
;
 JMP ON_AND_REFREASH
;
;
FC_CLEAR_HOME_DSP:
 JSR FC_CLEAR_HOME
 JMP ON_AND_REFREASH
;
FC_CLEAR_HOME:
 JSR EDIT_BUFFER_TO_TEXT
 BCC FC_CLEAR_HOME_NT
;WATCH CC HERE
;
FC_CLEAR_HOME_NTND: 
 JSR DISPLAYOFF
;
FC_CLEAR_HOME_NT:
 LDA STTEXT
 STA TEXPAG
 STA TEXT
 LDA STTEXT+1 
 STA TEXPAG+1
 STA TEXT+1
 LDX #1
 STX PAGE
 JSR TEXCF0           ;GET 1ST BYTE TEXT
 CMP #CMARK
 BNE .LINE_ONE  
;
 DEX                  ;[0]
.LINE_ONE: 
 STX LINE             ;0 OR 1
 LDX #0               		;[0]
 STX CURRENT_SCREEN_LINE
 STX ATTRIBUTES
 STX JUSTIFY_FORMAT		;SET TO LEFT JUSTIFICATION
;
 JSR BIGGEST_AND_CURRENT        ;IF TEXT MODE SET TO 1
 LDA CURRENT_FONT     		;IS IT "TEXT"?
 BMI .NO_FONT_CHANGE
;
;
 JSR SET_START_OF_TEXT_FONT
; TXA                  ;FONT 0
; JSR SET_FONT
;
; JSR TEXCF0		;GET 1ST BYTE OF TEXT
; JSR CHECK_SET_FONT	;REVISE IF 1ST CHAR IS A FONT
;
.NO_FONT_CHANGE:
 JSR GO_LEFT_MARGIN
 JSR SETSCN           ;0 SCREEN LINE, SET SCREEN, SCRNMO
 JSR SET_MARGIN
;
 JSR TEXT_TO_EDIT_BUFFER
 JSR CALCULATE_LINE_LENGTH
;
 LDA #0
 LDX EDIT_LINE
 CPX #CMARK
 BEQ .NO_LEN
 LDA BIGGEST_POINTSIZE
.NO_LEN:
 LDX #0
 JSR AX_INTO_CUR_PAGE_LENGTH
 LDA EDIT_LINE
 BPL .SKP1111
 JMP UPDATE_ATTRIBUTES_CR
.SKP1111:
 RTS
;
;
FC_INSERT_CHECKMARK:
;
;*NOTE* WATCH ON VALID-CHECK - ON CHECK (2ND LINE)
 LDY #5
 JSR EOM_TEST_PLUS_Y        ;IF SO, ADD NEW STUFF
 BCS .EXIT
;
;*NOTE* WHAT ABOUT FIRST LINE?
 JSR FC_BEGINNING_OF_LINE
 JSR EDIT_BUFFER_TO_TEXT
;
 LDA PAGE
 ORA LINE                       ;IF L1 P1 OR L0 P1 THEN
 CMP #2
 BCS .NOT_FIRST_LINE
;
 JSR ZERO_INTO_CUR_PAGE_LENGTH  ;PGLEN = 0
 STA LINE
 JSR FC_INSERT_LINE1            ;BEGINNING AND NEW LINE
 JMP .SET_CHECK
;
.NOT_FIRST_LINE:
 JSR FC_CURSOR_UP
;
 JSR TEXT_TO_NEXTLINE
 JSR FC_INSERT_LINE1            ;BEGINNING AND NEW LINE
 JSR AD28SC                     ;KEEP SCREEN LINE
 INC CURRENT_SCREEN_LINE        ;THE SAME
 JSR TEXT_TO_EDIT_BUFFER
;
 DEC TEXT+1             ;SET CR ON LINE BEFORE THIS ONE
 LDA #RETURN            ;TO A HARD RETURN
 TAY                    ;HOPEFULLY, THE SILLY USER WILL
 STA (TEXT),Y           ;NOT CHANGE IT, ALLOWING FORMAT
 INC TEXT+1             ;TO EAT THE CHECKMARK
;
.SET_CHECK:
 LDA #CMARK
 STA FIRST_CHAR
 JSR FC_WORK_KEY
 JSR SEARCH_BACK_THRU_CHECKS    ;FIND PREV \P AND SET FP FLAG
;
.EXIT:
;
 JMP FULL_SCREEN
;
;
;
FC_FCURSOR_DOWN:
 JSR SIX_CALLS
CD_CURSOR_DOWNS:
.LOOP1168:
 JSR FC_CURSOR_DOWN
 DEC COUNT_DOWN
 BNE .LOOP1168
 JMP ON_AND_REFREASH
;
;
FC_FCURSOR_UP:
 JSR SIX_CALLS
CD_CURSOR_UPS:
.LOOP1178:
 JSR FC_CURSOR_UP
 DEC COUNT_DOWN
 BNE .LOOP1178
 JMP ON_AND_REFREASH
;
;
!if  REMOVE_TEXT { 
FC_PAGE_FORWARD_NT:
 JSR FC_BEGINNING_OF_LINE   ;KILLS DISPLAY, NO RESTORE
;
.START:
 LDA LINE			;IF ON LEADING CHECKMARK
 BNE .LOOP1191			;LINE WILL BE ZERO
 JSR FC_CURSOR_DOWN		;BUMP A COUPLE
 BCC .START
; JSR FC_CURSOR_DOWN		;OF LINES FOR A CHEAT
;
.LOOP1191:
 JSR FC_CURSOR_DOWN
 BCS FPF_ABORT
 LDA LINE
 CMP #1
 BNE .LOOP1191
FPF_ABORT:
 RTS
} 
;
;
FC_PAGE_FORWARD_NT:
 JSR FC_BEGINNING_OF_LINE   	;KILLS DISPLAY, NO RESTORE
 LDA PAGE			;CURRENT PAGE #
.START1210:
 PHA 
;
;?START:
; LDA LINE			;IF ON LEADING CHECKMARK
; BNE ?LOOP			;LINE WILL BE ZERO
; JSR FC_CURSOR_DOWN		;BUMP A COUPLE
; BCC ?START
; JSR FC_CURSOR_DOWN		;OF LINES FOR A CHEAT
;
.LOOP1220:
 JSR FC_CURSOR_DOWN
 PLA
 BCS FPF_ABORT
 CMP PAGE
 BEQ .START1210 
;
FPF_ABORT:
 RTS
;
;
FC_PAGE_FORWARD:
 JSR FC_PAGE_FORWARD_NT
;
DISPLAY_ON_LINE_OUT:
 JSR DISPLAYON
 JMP FC_LINE_OUT
;
;
FC_PAGE_BACKWARD:
 JSR START_OF_TEXT          	;ARE WE ON THE FIRST LINE?
 BEQ FPF_ABORT
;
 JSR FC_BEGINNING_OF_LINE   	;KILLS DISPLAY, NO RESTORE
; BRK
; LDA IN_DATABASE_MODE		;IN MINI-DB?
; BEQ ?MOVE_TO_LINE_ONE		;IF NOT, AS NORMAL
;
; LDA LINE		    ;LINE ONE/ZERO?
; CMP #2
; BCS ?MOVE_TO_LINE_ONE
; JSR FC_CURSOR_UP_1         ;DO NOT TEST FOR START
; JMP ?OUT
;
.MOVE_TO_LINE_ONE:
 JSR FC_CURSOR_UP_1         ;DO NOT TEST FOR START
;
 LDA LINE
 CMP #2
 BCS .MOVE_TO_LINE_ONE
;
; JMP DISPLAY_AND_LINOUT
;?OUT:
 JSR OV_SET_TO_TOP_PAGE			;MINIDB,TABLED
 JMP DISPLAY_ON_LINE_OUT
;
;
FC_FORCE_FORMAT:
;
; LDX OUTMODE
; BEQ ?NORMAL
; JMP FC_OUTLINE_REFORMAT
; JMP OV_OUTLINE_REFORMAT	;COMPILATION ALLEGENCE TO OUTLN
;
;?NORMAL:
 INC PARAGRAPH_FORMAT    ;DO A WHOLE PARAGRAPH
 JSR FC_WRAP_LINE
 LDA #0
 STA PARAGRAPH_FORMAT 
 JMP DISPLY
;
;
;
FC_TAB_FORWARD_NORMAL:
;
 JSR FC_TAB_IN_TEXT
 JSR FIX_ACTUAL_COLUMN
 JMP FC_REFORMAT_FROM_CURSOR
;JMP FC_WRAP_LINE
;
!if  REMOVE_TEXT { 
.IN_OUTLINER:
 LDX #$FF
 LDA ACTUAL_COLUMN 
.LOOP1294:
 INX
; CMP TAB_TABLE,X
 CMP TABPOS,X		;LOOK AT OUTLINER TAB TABLE
 BCS .LOOP1294 
;
; LDA TAB_TABLE,X
 LDA TABPOS,X
 CMP #$FF
 BEQ .TAB_ABORT
;
 BIT INSERTM
 BPL MOVE_TO_COLUMN_A
 SEC
 SBC ACTUAL_COLUMN ;.A HOLDS # COLUMNS TO MOVE
;
 STA COUNT_DOWN
;
.LOOP1:
 LDA #' '
 JSR FC_WORK_KEY
 DEC COUNT_DOWN
 BNE .LOOP1
.TAB_ABORT:
FTF_ABORT:
 RTS
;
;
;*NOTE* THIS IS USED ONLY BY THE OUTLINER NOW!!
;
MOVE_TO_COLUMN_A:
 STA COUNT_DOWN
 INC CURFLG              ;ALLOW EXTEND
;
.LOOP2:
 JSR FC_CURSOR_RIGHT
 LDA ACTUAL_COLUMN
 CMP COUNT_DOWN
 BNE .LOOP2
;
 LDA #0
 STA CURFLG              ;DISALLOW EXTEND
 JMP CHANGED_EDIT_BUFFER
} 
;
;
!if  REMOVE_TEXT { 
FC_TOGGLE_TAB:
 LDA #TABCHAR
 JMP FC_WORK_KEY_INS
;
;
 LDA ACTUAL_COLUMN
; STA TEMP
 JSR IN_TAB_TABLE       ;IS THIS COLUMN IN TAB TABLE?
 BCS .ADD_TAB
;
;DELETE TAB .X POINTS AT NUMBER
;
.LOOP11353:
 LDA TAB_TABLE+1,X
 STA TAB_TABLE,X
 INX
;# MAX_TABS
 CPX #20
 BCC .LOOP11353
;
 LDX #53
 JMP SERPP0
;
.ADD_TAB:
 LDY #0               ;LOOK THRU TABLE FOR SPOT
.LOOP1366:
 CMP TAB_TABLE,Y      ;IS NEW TAB > CURRENT TAB?
 BCC .SET_TAB
 INY
 CPY #MAX_TABS-1
 BCC .LOOP1366 
;
.SET_TAB:
 LDX TAB_TABLE,Y      ;PICK UP CURRENT SPOT
 STA TAB_TABLE,Y      ;PLACE NEW TAB IN TABLE
 TXA                  ;READY OLD TAB TO MOVE UP
 INY
 CPY #MAX_TABS-1
 BCC .SET_TAB 
;
 LDX #52
 JMP SERPP0
} ;REMOVE_TEXT
;
;
FC_EMBEDDED_STYLES:
; LDX IN_DATABASE_MODE
; BNE ?NO_MEM
;
 LDX #16           	;ALLOW ONLY EXTRA KEYS IF IN OUTLINER
 LDA OUTMODE       	;OR IN THE MINI-DATABASE
 ORA IN_DATABASE_MODE
 BNE .JOIN
;
 JSR EOM_TEST_PLUS_0
 BCS .NO_MEM
;
; LDA CURRENT_KEY
 LDX #0            ;RESET TO 0
.JOIN:
 LDA CURRENT_KEY
.LOOP1402:
 CMP COMM_KEYS,X
 BEQ .SET_CODE
 INX
 CPX #16+7
 BCC .LOOP1402
;
.NO_MEM:
 RTS
;
.SET_CODE:
 LDA EMBEDDED_CODES,X
MAKE_FONT_CODE:
 JSR FC_WORK_KEY_INS
;
 LDA CURRENT_FONT           ;IF TEXT MODE NO FORMAT
 BMI .NO_FORMAT
 LDA CURRENT_KEY            ;WAS THIS BOLD?
;
 JSR IS_BOLD
 BCC .NO_FORMAT
;
.FORCE_FORMAT:
 JSR FC_REFORMAT_FROM_CURSOR
 JMP DISPLAY_ON_AND_LINE_OUT_R
;
.NO_FORMAT:
 RTS
;
;
EMBEDDED_CODES:
!byte 'U'+$80,'U'-'@'+$80;0..1
!byte 'B'+$80,'B'-'@'+$80;2..3
!byte 'I'+$80,'I'-'@'+$80;4..5
!byte $DB,$AB
!byte $C0,$AD
!byte 'W'+$80,'W'-'@'+$80;
!byte 'X'+$80,'X'-'@'+$80;
!byte 'Y'+$80,'Y'-'@'+$80;
;
;7 EXTRA 'UNDEFINED' CHARACTERS
EXTENDED_CODES:
;     {    |    }    ~    \    _    '
!byte $6D,$5D,$7D,$68,$7F,$64,$7C
!byte $80,$81;2 MARKS
;
SCREEN_CODE_SUBST:
;     {    |    }    ~    \    _    '
!byte $5B,$5C,$5D,$5E,$1C,$1F,$40
;
;
COMM_KEYS:
;     U       B       I
!byte $15,$B8,$02,$BF,$09,$A2
;     +       -       W
!byte $F8,$A6,$FB,$DC,$17,$B3
;     X       Y
!byte $18,$BD,$19,$B7
;
;
;    [:   ^   ];  *   ?   =   @
!byte $1B,$F1,$F6,$F3,$F4,$F5,$F2;7 EXTRA CODES
;
;
FC_INSERT_LINE:			;DOUBLESHOT, OVR_FC_INSERT_LINE
 LDY #3
 JSR EOM_TEST_PLUS_Y     ;IF SO, ADD NEW STUFF
 BCS INST_LINE_OUT
;
 INC DOCUMENT_ALTERED    ;THIS CHANGES TO DOCUMENT
;
 LDA EDIT_LINE
 CMP #CMARK
; BEQ INST_LINE_OUT
 BNE .NOT_CHECK
;
 JSR FC_CURSOR_UP
 JSR PUSH_TEXT
 JSR TEXT_TO_NEXTLINE
 JSR FC_INSERT_LINE2
 JSR POP_TEXT
 JSR TEXT_TO_EDIT_BUFFER
 JMP FC_CURSOR_DOWN_DSP
;
.NOT_CHECK:
; LDY #3
; JSR EOM_TEST_PLUS_Y     ;IF SO, ADD NEW STUFF
; BCS INST_LINE_OUT
;
; INC DOCUMENT_ALTERED    ;THIS CHANGES TO DOCUMENT
;
 JSR BP_MIN_CUR_PAGE_LENGTH
 JSR FC_BEGINNING_OF_LINE
 JSR FIND_PREV_FONT
 LDA CURRENT_POINTSIZE
 STA BIGGEST_POINTSIZE
 JSR FC_INSERT_LINE1
 JSR CALCULATE_LINE_LENGTH
;
BP_PLUS_AND_DISPLAY:
 JSR BP_PLS_CUR_PAGE_LENGTH
INST_LINE_OUT:
 JMP DISPLAYON
;
FC_INSERT_LINE1:
 JSR STORE_BEGIN_LINE        ;EDITBUFFERTOTEXT + GO_LEFT_MARGIN
FC_INSERT_LINE2:
 LDY #2
 JSR MOVE_UP_Y
 LDY #0
 LDA #' '
 STA (TEXT),Y 
 LDA #RETURN
 INY
 STA (TEXT),Y
 JMP TEXT_TO_EDIT_BUFFER
;
;
FC_TOGGLE_HRET:
;
 LDY OLD_CHARS_IN_LINE	;IS THERE
 INY			;A CHECKMARK
 LDA #CMARK		;ON THE NEXT LINE?
 CMP (TEXT),Y		
 BEQ CEB_RTS		;IF YES, EXIT
;
 LDX CHARS_IN_LINE
 CMP EDIT_LINE		;CHECK MARK THIS LINE?
 BEQ CEB_RTS       	;IF YES, EXIT
;
 LDA EDIT_LINE,X
 CMP #ENDT
 BEQ TOGGLE_HRET_ABORT
;
 CMP #SRETRN
 BEQ .TO_HRET
 LDA #SRETRN ;RETURN
!byte $2C
.TO_HRET:
 LDA #RETURN
 STA EDIT_LINE,X
 JSR FC_EDIT_BUFFER_TO_TEXT
 JSR FC_WRAP_LINE
;
TOGGLE_HRET_ABORT:
BUFFER_CHANGED_DISPLAY:
 JSR DISPLY
CHANGED_EDIT_BUFFER:
 LDA #1
 STA EDIT_BUFFER_CHANGED
CEB_RTS:
 RTS
;
;
FC_DELETE_LINE:		;MOVED TO OUTLN/MINIDB, DOUBLESHOT
;
 LDA CURRENT_CHAR
 BEQ DEL_WHOLE_LINE
;
 LDY CHARS_IN_LINE
 LDA EDIT_LINE,Y         ;KEEP SAME RETURN TYPE
 LDY CURRENT_CHAR
 INY
 STY CHARS_IN_LINE       ;AND READY TO BLAST IT
 STA EDIT_LINE,Y
;
 LDX OUTMODE
 BEQ .FC_UPDATE
 JMP BUFFER_CHANGED_DISPLAY
;
.FC_UPDATE:
 JMP FORMAT_AND_DISPLAY
;
DEL_WHOLE_LINE:
;
 INC DOCUMENT_ALTERED    ;THIS CHANGES TO DOCUMENT
;
 LDY OLD_CHARS_IN_LINE
 JSR LDA_TEXT_Y          
 BEQ FC_DELETE_TO_EOL    ;AND OFF WE GO
 INY                     ;0..N -> 1..N+1
 TYA                     ;FULL LINE LENGTH INCLUDING RETURN
 JSR REMOVE_A_BYTES      ;DELETE THE LINE, ADJUST EOT
;
 LDA EDIT_LINE           ;WAS OLD LINE A CMARK LINE?
 CMP #CMARK 
 BEQ .MARGINS 
;
 PHA
 JSR CALCULATE_LINE_LENGTH  ;SET LINE LENGTH
 JSR BP_MIN_CUR_PAGE_LENGTH
;
 PLA
 BPL COPY_AND_DISPLAY
 JSR IS_STYLE_CODE
 BCS COPY_AND_DISPLAY
 JSR FIND_PREV_STYLE
 JMP COPY_AND_DISPLAY
;
.MARGINS:
 JSR TEXCF0              ;GET 1ST CHAR NEW LINE
 CMP #CMARK              ;IS NEW LINE CMARK?
 BEQ .SKP1604                ;IF SO LINE COUNTER STAYS SAME
 JSR INC_LINE
 BNE .SKP1
;
.SKP1604:
 LDA LINE
 BEQ .SKP1
 JSR DEC_LINE
;
.SKP1: 
 JSR FIND_PREV_MARGIN    ;RE-SET MARGIN IF THIS WAS ANY KIND OF CM
;
COPY_AND_DISPLAY:
 JSR TEXT_TO_EDIT_BUFFER
;
 INC CURRENT_CHAR        ;[0->1]
 JSR FIND_PREV_FONT      ;FORCE TO FIND CURRENT FONT
 DEC CURRENT_CHAR        ;RESET
;
 LDA EDIT_LINE
 BPL .SKP1624
 JSR UPDATE_ATTRIBUTES_CR
;
.SKP1624:
 JSR CALCULATE_LINE_LENGTH  ;SET LINE LENGTH
;
 JSR FC_LINE_OUT
 LDA EDIT_LINE
 CMP #CMARK 
; BEQ FORMAT_AND_DISPLAY ;?FORMAT_IT ;REDRAW_SCR
 BEQ .START_W_CHECK
 JSR BP_PLUS_AND_DISPLAY
 JMP FORMAT_AND_DISPLAY
.START_W_CHECK:
 JSR FC_END_OF_LINE
;
FORMAT_AND_DISPLAY:
; JSR FC_REFORMAT_DOC
 JSR FC_REFORMAT_DOC_NOT_ON_CHECK
;
 JMP DISPLAY_ON_AND_LINE_OUT_R
;
;
FC_DELETE_TO_EOL:
 LDA #ENDT               ;PLACE ENDT
 LDY CURRENT_CHAR        ;ONE TO THE RIGHT OF THE CURRENT CHAR
 INY                     ;WHICH MUST BE EOL OR TEXT
 STY CHARS_IN_LINE       ;SAFETY
 STA EDIT_LINE,Y          
 LDA #' '
 STA EDIT_LINE 
 JSR EOT_EQ_TEXT_PLS_Y   ;SET NEW EOT AT
 JSR COPY_LINE_TO_TEXT   ;JUST MOVE EDIT_BUFFER TO TEXT
 JSR CALCULATE_LINE_LENGTH
REDRAW_SCR:
 JMP REFREASH_ALL_SCREEN ;SHOW NEW END
;
FC_DELETE_WORD:
;
;DELETE THE WORD UNDER THE CURSOR
;
 JSR CURRENT_CHARACTER_Y
 BMI DEL_WOR_OUT
 CMP #' '
 BEQ DEL_WOR_OUT
;
 JSR DISPLAYOFF
 JSR MOVE_TO_START_OF_WORD
;
 JSR MOVE_TO_END_OF_WORD
;
 JSR MOVE_TO_START_OF_WORD
;
; LDA TEMP
.LOOP3:
 JSR CURRENT_CHARACTER_Y
 BMI .NO_DEL                ;DON'T DELETE EMB CODES
;
 JSR FC_DELETE_CHAR_RT
.NO_DEL:
 DEC TEMP
 BNE .LOOP3
;
;
.SKP1688:
;CAUTION--DELETE WORD TURNS DISPLAY ON
 JSR FIX_ACTUAL_COLUMN_IF_TABLINE
 JMP ON_AND_REFREASH
;
FORCE_BUFFER_DISPLAY:
 JSR FC_EDIT_BUFFER_TO_TEXT 
DEL_WOR_OUT:
 JMP DISPLY              ;TEXT TO EDIT BUFFER AND DISPLAY
;
;
FC_MACRO_RECORD:
 LDA RECORD_PLAY        ;IF NOT RECORDING,
 BEQ START_RECORD       ;GO BEGIN RECORD
; BMI END_PLAY           ;IF PLAYING NOW, END PLAY
;
;TERMINATE RECORDING
.CLOSE_RECORD:
; LDX KEY_RECORD_INDEX
; STX KEY_RECORD_END
;
END_PLAY:
 LDX #0
; STX KEY_RECORD_INDEX
 STX RECORD_PLAY
; PHA
 LDX #51
 JSR SERPP0
; PLA
 LDA #$FF                ;RETURN NO KEY
 RTS
;
START_RECORD:
; INC RECORD_PLAY         ;START RECORDING
; STA KEY_RECORD_INDEX    ;AT BEGINNING [0]
.GET_KEY:
 LDX #50
 JSR PRKECY 
 CMP #'1'               ;IS THIS MACRO ONE?
 BEQ .MAC_ONE
 CMP #'2'
 BNE .GET_KEY
;
.MAC_ONE:
 AND #2 
 STA WHICH_MACRO 
 INC RECORD_PLAY         ;START RECORDING
;
; LDA WHICH_MACRO        ;GET INDEX TO THIS MACRO [0-2]
 EOR #$02               ;MAKE IT INDEX FOR OTHER MACRO [2-0]
 TAX 
 LDA MACRO_1_START,X    ;GET OTHER MACRO'S START
 TAY 
 DEY 
 BPL .OK1742
 LDY #119               ;ONE LESS THAN IT'S START
.OK1742:
 STY MACRO_LIMIT        ;IS LIMIT OF THIS MACRO'S RECORDING RANGE
;
 LDA MACRO_1_END,X      ;GET END OF OTHER MACRO
 TAX
 JSR MACRO_FIX_X        ;PLUS 1 (CAN WRAP)
 LDY WHICH_MACRO        ;POINT TO THIS MACRO
 TXA
 STA MACRO_1_START,Y    ;SET NEW START AND END
 STA MACRO_1_END,Y      ;SET NEW START AND END
;
; RTS
 JMP HEADER
;
FC_PLAY_MACRO_TWO:
 LDA #2                 ;SECOND MACRO
!byte $2C;SKIP 2
;
FC_MACRO_PLAY:
;
 LDA #0                 ;FIRST MACRO
;
 LDX RECORD_PLAY
 BNE .IGNORE
;
 STA WHICH_MACRO 
;
 LDY WHICH_MACRO        ;PLAY WHICH MACRO?
 LDA MACRO_1_START,Y    ;GET STARTING POSITION
 STA MACRO_LIMIT        ;THIS WILL STEP THRU PLAY...
;
 LDA #$FF
 STA RECORD_PLAY
.IGNORE:
 RTS
;
;
FC_END_OF_DOCUMENT:
 JSR DISPLAYOFF      ;SHUT DOWN FOR SPEED
.LOOP1783: 
 LDA PAGE
 CMP #$FF		;LAST PAGE?
 BEQ .DONE1786
 JSR FC_CURSOR_DOWN   	;DO A CURSOR_DOWN
 BCC .LOOP1783
.DONE1786:
 JMP ON_AND_REFREASH
;
;
FC_BOTTOM_OF_SCREEN:
 LDA CURRENT_SCREEN_LINE
 CMP #$14
 BEQ .FULL_SCREEN
;
; SEC
 CLC
 LDA MAXIMUM_LINES	;SCREEN DEPTH
 SBC CURRENT_SCREEN_LINE
 BNE .SKP1802
 LDA IN_DATABASE_MODE
; BEQ ?FULL_SCREEN
; JMP FC_PAGE_FORWARD
 BNE .SKP1802
;
.FULL_SCREEN:
 LDA #23
.SKP1802:
 JSR REPEAT_NODISPLAY 
 JMP CD_CURSOR_DOWNS
;
;
!if  REMOVE_TEXT { 
FC_CLEAR_ALL_TABS:
 LDX #58              ;'CLEAR TABS?'
 JSR PRKECY
 BEQ .CLEAR           ;'TABS CLEARED'
 JMP HEADER           ;CLEAN UP
;
; JSR HEADER           ;CLEAN UP
.CLEAR:
;
 LDX #MAX_TABS
 LDA #$FF
.LOOP1827:
 STA TAB_TABLE,X
 DEX
 BPL .LOOP1827
.OUT:
 JSR HEADER
 LDX #54
 JMP SERPP0
} 
;
;
FC_TOGGLE_TEXT_GRAPHICS:
 JSR IS_FONT_PRINTING    ;ARE WE PRINTING FONTS?
 LDA PRINT_GRAPHICS      ;0=NO, 1 = YES
 BEQ CHANGE_TO_GRAPHICS
;
CHANGE_TO_TEXT:
 LDA #'6'
 TAX
 JSR AX_INTO_PG_LENGTH
;
 LDA #'N'
 STA PW_S_PRINT_GRAPHICS
;
 JSR SET_BIG_AND_CURRENT	;SET TO 1
;
 LDX #0
 STX USER_DEFINED_LEAD
 STX FONT_LEADING
 STX PRINT_GRAPHICS
 STX EXPAND_ON
 DEX                     ;[$FF]
 STX CURRENT_FONT
;
CHANGE_TO_END:
 JSR SET_VMARGINS
 JMP REFORMAT_DOC
;
CHANGE_TO_GRAPHICS:
 LDA #'L'
 LDX #'T'
 JSR AX_INTO_PG_LENGTH
;
 LDA #'Y'
 STA PW_S_PRINT_GRAPHICS
 LDX #1
 STX PRINT_GRAPHICS
 DEX                     ;[0]
 STX CURRENT_FONT
 JMP CHANGE_TO_END
;
;
SET_TO_TEXT_OR_GRAPHICS:
 JSR IS_FONT_PRINTING
 LDA PRINT_GRAPHICS
 BEQ CHANGE_TO_TEXT
 BNE CHANGE_TO_GRAPHICS
;
;
FC_PRINT_FILE:
 LDA BLKSET		;SECOND DOC ACTIVE?
 BNE .ABORT1888	 
;
 JSR FC_BEGINNING_OF_LINE
 JSR EDIT_BUFFER_TO_TEXT
;
 JSR GET_PRINT_PARAMETERS
 BCC .PRINTER_PRESENT
;
 LDX #09                ;DEVICE NOT PRESENT
 STX MERPTR
 BNE .ABORT1888             ;ERROR MESSAGE
;
.PRINTER_PRESENT:
 LDA BIGGEST_POINTSIZE
 STA SAVE_SPACING
;
 BIT PREVIEW            ;IF PREVIEW ON
 BMI .TEXTP             ;GO DO TEXT PRINT
 LDA PRINT_GRAPHICS     ;IF FONT MODE
 BNE .PRINT_WITH_FONTS  ;GO PRINT FONTS
 BEQ .NORMAL_FILE
;
.TEXTP:
;
 LDA #1
 STA BIGGEST_POINTSIZE
;
.NORMAL_FILE:
 JSR SET_MARGIN         ;SET DEFAULTS 10,60 (IN CASE NO CM)
 LDA JUSTIFY_FORMAT
 PHA
 LDA ATTRIBUTES
 PHA 
 JSR TPRINT_FILE
 PLA
 STA ATTRIBUTES
 PLA
 STA JUSTIFY_FORMAT
;
;?NO_PRINTER:
 LDA #1
 STA ACTUAL_COLUMN
 LDA TEMP5		;WERE WE MAIL-MERGING?
 BEQ .NOT_MERGE
;
 JSR FC_CLEAR_HOME_NT   ;MERGE NAMES ALWAYS STOPS AT BEGINNING
;
.NOT_MERGE:
 JSR UPDATE_BUFFER_AND_LINEL
 JSR FIX_ACTUAL_COLUMN_IF_TABLINE
 JMP FULL_SCREEN        ;DISPLAYON
;
;
.PRINT_WITH_FONTS:
;
 LDA DOCUMENT_ALTERED 
 ORA EDIT_BUFFER_CHANGED
 BEQ .OK_TO_PRINT
;
 JSR RESET_AND_DISPLAY
 JSR GPRINT_WARN_BOX
 LDX #44                    ;ERASES MEMORY.
 JSR SAVE_DOCUMENT_1        ;USE FULL PROMPT
 LDA MERPTR
 BEQ .ABORT1888
;
.OK_TO_PRINT: 
;
 JSR FC_CLEAR_HOME_NT
 JSR HEADER
 JSR GPRINT_FILE
 STX MERPTR                 ;SAVE ERROR FLAG
 JSR VIC_SCREEN_ON          ;.X UNHARMED
 TXA                        ;IS .X NZ?
 BNE .ABORT1888                 ;TRY TO PRESERVE FILE IF ERROR
;
 JSR INITIL
.ABORT1888:
 JSR FC_CLEAR_HOME_NT
 JSR FULL_SCREEN
 LDX MERPTR
 BEQ .OUT1969 
 JMP SERPP0
.OUT1969:
 RTS
;
;
FC_REFORMAT_DOC:
;
 LDA EDIT_LINE
 CMP #CMARK
 BEQ REFORMAT_DOC
;
FC_REFORMAT_DOC_NOT_ON_CHECK:
;
 JSR SET_SYSTEM_MARK
 JSR FC_CLEAR_HOME
 JMP REFORMAT_ALL_MAINTAIN_POSITION
;
FC_REFORMAT_FROM_CURSOR:
;
;ASSUMES NOT ON CMARK LINE!
 JSR SET_SYSTEM_MARK
 JSR FC_BEGINNING_OF_LINE
;
REFORMAT_ALL_MAINTAIN_POSITION:
 JSR REFORMAT_LOOP
;
REFORMAT_END:
;
 JSR GOTO_SYSTEM_MARK
 LDA #0
 STA SUPRESS_FORMAT 
 JSR FC_DELETE_CHAR_RT
;
 DEC SUPRESS_FORMAT      ;SET TO $FF
 JSR HEADER
 JMP DISPLAY_ON_AND_LINE_OUT_R
; JMP HEADER
;
REFORMAT_DOC:
;
 JSR FC_CLEAR_HOME
 JSR DISPLAYOFF
 JSR REFORMAT_LOOP
 JMP FULL_SCREEN
;
REFORMAT_LOOP:
;
 JSR HEADER
 LDX #3
 JSR SERPP0              ;'WORKING...'
 INC PARAGRAPH_FORMAT    ;DO A WHOLE PARAGRAPH
;
.LOOP2022:
 JSR FC_WRAP_LINE
.END_OF_PARA:
 LDX CHARS_IN_LINE
 LDA EDIT_LINE,X
 CMP #SRETRN
 BEQ .WITHIN_PARAGRAPH
;HRET OR EOT
 JSR FC_CURSOR_DOWN 
 BCC .LOOP2022
;
.DONE2033:
 LDA #0
 STA PARAGRAPH_FORMAT
;
 JMP FC_CLEAR_HOME_NT
;
.WITHIN_PARAGRAPH:
 JSR FC_CURSOR_DOWN
 JMP .END_OF_PARA
;
;
FC_SHOW_STATUS:
;1234567890123456789012345678901234567890
;IN TEXT MODE: UL BD IT SP SB U1 U2 U3 00
;IN TEXT MODE: ALIGN:X U B I + - 1 2 3 00
 LDA IN_DATABASE_MODE
 BEQ .TEXT_FONT_MODE
 JMP SET_DB_FIELD_NAME
;
.TEXT_FONT_MODE:
 LDX #57 
 JSR SERPP0 ;DISPLAY
;
 LDX #0
 LDY #0
.LOOP2058:
 LDA ATTRIBUTES
 AND ATT_ON_TABLE,X
 BEQ .SKP2061
 LDA VIDEO+20+40,Y
 ORA #$80
 STA VIDEO+20+40,Y
; LDA VIDEO+15+40,Y
; ORA #$80
; STA VIDEO+15+40,Y
.SKP2061:
 INY
 INY
; INY
 INX
 CPX #8
 BCC .LOOP2058
;
 LDX JUSTIFY_FORMAT	;GET JUSTIFY TYPE
 LDA JUSTIFY_TABLE,X	;GET CHARACTER LRCJ FROM TABLE
; ORA #$C0		;FORCE TO HILIGHT UPPERCASE
 ORA #$40		;FORCE TO UPPERCASE
 STA VIDEO+40+15	;STORE RIGHT AFTER FONTNAME
;
 LDX CURRENT_FONT
 BMI SHOW_STATUS_OUT
;
.FONTS:
 TXA
 ASL
 TAX
 JSR FONT_TABLE_X_INTO_PT   ;POINTER = FONT_TABLE,X .Y = NAME
 LDY #$6E
;
.JOIN2092:
 LDX #11 
.LOOP12094:
 LDA (POINTER),Y
 STA VIDEO+40,X
 DEY
 DEX
 BPL .LOOP12094
;
.SHOW_LEADING:
 LDA FONT_LEADING
 JSR AXASCII
 STX VIDEO+40+36
 STA VIDEO+40+37
;
SHOW_STATUS_OUT:
 RTS
;
;
FC_EXIT_OR_RESET:
;
 JSR TELL_DOCUMENT_ALTERED	;WARN ABOUT CHANGES
;
.NO_CHANGES:
 LDX #4
 JSR PRKECY     ;EXIT TO BASIC OR QUIT
 CMP #'Q'       ;Q
 BNE .TRY_RESET
;
;NOW DO GEOS STUFF
 LDA GEOSFL     ;DO WE GO TO GEOS
 BNE .GONE      ;NO,
.DLOOP:
 LDX #8
 JSR PRKECY     ;'INSERT GEOS DISK AND PRESS ANY KEY'
 CMP #$0D
 BNE .DLOOP
;
 JSR INIDSK     ;CHECK FOR DAMN GEOS DISK
 LDA #9
 LDX #<GEOSMG
 LDY #>GEOSMG
 JSR FILE_EXISTS
 BEQ .OK2135
 JMP CLALL      ;CLOSE OUT THE CHANNELS
;
.OK2135:
 LDA #0
 LDX #8
 LDY #1
 JSR SETLFS
 LDA #2
 LDX #<GEOFIL
 LDY #>GEOFIL
 JSR SETNAM
 JSR GLOAD
.GONE:
 JMP BYEBYE
;
.TRY_RESET:
;
 CMP #'N'
 BNE FEOR_EXIT
;
 LDA IN_DATABASE_MODE
 BEQ .DO_NORMAL_DOC
 JMP ENTER_DB_FIELDS		;MINIDB, DIRECT CALL
;
.DO_NORMAL_DOC:
;
KILL_DOC:
 JSR FC_CLEAR_HOME_NT
 JSR DISPLAY_ON_NO_DISPLAY
 JMP MNLINE			;MNLINE CANNOT BE JSR'ED TO
;
FEOR_EXIT:
 JMP HEADER
;
;
BLOCK_OPERATION:
!byte 0
;
;
FC_SET_BLOCK:
 LDA MOVE_COPY_HL     ;S/B 0 OR $80
 BEQ START_SELECT
SB_RTS:
 RTS
;
START_SELECT:
;
 JSR ON_LAST_LINE
 BEQ SB_RTS
;
 LDX #16              ;'CRSR TO SELECT, RETURN TO DELETE'
 JSR SERPP0
 STY MESSAGE_ON       ;TELL WW THERE IS NO MESSAGE TO CLEAR
 LDA CURRENT_KEY      ;IS THIS MOVE OR COPY?
 STA BLOCK_OPERATION
 CMP #$81             ;COMM-1 MOVE
 BEQ .MOVE_MSG
 CMP #$95             ;COMM-2 COPY
 BNE .MESSAGE_DONE
;
 LDX #11
!byte $2C
.MOVE_MSG:
 LDX #5 
 LDY #5
.LOOP2201:
 LDA END_MC_MESSAGE,X  
 STA VIDEO+40+26,Y
 DEX
 DEY
 BPL .LOOP2201
;
.MESSAGE_DONE:
 LDA #$80
 STA MOVE_COPY_HL
;
 JSR EDIT_BUFFER_TO_TEXT
 JSR TEXT_PLS_CURCAR_INTO_AX
;
AX_INTO_START_BLOCK: 
 STA START_BLOCK
 STX START_BLOCK+1 
;
 LDA EDIT_LINE
 STA START_BLK_1ST_LINE_CHAR
;
 RTS
;
BLOCK_TOO_BIG:
 DEC EOT+1
; DEC EOT+1
; LDX #36
; JMP SERPPT              ;'TOO LARGE TO PROCESS'
 JSR KILL_BLOCK
 JMP NOT_ENOUGH_MEMORY   ;'NOT ENOUGH MEMORY-PRESS F1'
;
END_MC_MESSAGE:
!text "MOVE",119,119
!text "COPY",119,119
;
END_SELECT:
;
 LDA MOVE_COPY_HL        ;ARE WE IN ROVE MODE?
 CMP #$FF                ;IF SO, THIS MUST BE MOVE OR COPY, NOW!
 BEQ FC_MOVE_COPY        ;GO DO IT
;
 LDA BLOCK_OPERATION     ;IF DELETE, DO SO, ELSE GO ROVE
 CMP #$96                ;DELETE COMM-3?
 BNE .MV_CPY
 JMP FC_DELETE_BLOCK
;
.MV_CPY:
 LDX #19
 JSR SERPP0
 STY MESSAGE_ON       ;TELL WW THERE IS NO MESSAGE TO CLEAR
;
SB_DISPLAY_BLOCK:
 LDA #$FF  
 STA MOVE_COPY_HL 
 RTS 
;
;
FC_MOVE_COPY:
;
;CAN BLOCK FIT?
;IS ENDRAM - (END_BLOCK-START_BLOCK) > EOT+$100
;
;
 JSR CURSOR_IN_BLOCK
 BEQ MC_OUT_OF_BLOCK
;
CURSOR_IN_RANGE_ERR:
 JSR HEADER
 LDX #14
 JMP SERPP0
;
MC_OUT_OF_BLOCK:
;
;
.MOVE_OR_COPY:
;
;
 LDA BLOCK_OPERATION
 CMP #$95             ;COMM-2 COPY
 BEQ .NOT_END_LINE
;
 LDA END_BLOCK
 LDX END_BLOCK+1
 JSR AX_INTO_P2
 LDY #1
 LDA (POINTER2),Y
 CMP #RETURN
 BNE .NOT_END_LINE
;
 INC END_BLOCK
 BNE .NOT_END_LINE
 INC END_BLOCK+1
;
.NOT_END_LINE: 
;
 JSR EB_MIN_SB_INTO_P2
;
 LDA #<ENDRAM_M1
 LDX #>ENDRAM_M1         ;LDAX #ENDRAM-1
;
 JSR DEC_AX_BY_P2        ;.A.X IS DESTINATION ADDRESS FOR BLOCK
 INC EOT+1
;
 CPX EOT+1		   
 BNE .SKP2305			   
 CMP EOT     		 ;IS .A.X > EOT?
.SKP2305:
 BEQ BLOCK_TOO_BIG
 BCC BLOCK_TOO_BIG
;
 DEC EOT+1               ;BLOCK FITS IN EOT+$100..ENDRAM
;
; INC PROHIBIT_RESTORE	;DISALLOW RESTORE
;
;MOVE FROM STARTBLOCK, ENDBLOCK TO .A,.X
 SEC               ;.A.X = ENDRAM-BLKSIZE
 SBC START_BLOCK   ;MINUS STARTBLOCK = DISTANCE TO MOVE
 TAY               ;.Y LB DISTANCE
 TXA               ;HB ENDRAM-BLKSIZE
 SBC START_BLOCK+1 
 TAX               ;.X HB DISTANCE
;
 JSR PUSH_TEXT
 JSR PUSH_EOT
;
 LDA START_BLOCK
 STA TEXT
 LDA START_BLOCK+1
 STA TEXT+1
;
 LDA END_BLOCK
 STA EOT
 LDA END_BLOCK+1
 STA EOT+1
 JSR MOVEUP
;
 JSR POP_EOT
 JSR POP_TEXT         ;TEXT HAS BEEN COPIED TO HI MEMORY
;
 JSR DISPLAYOFF
;
 JSR TEXT_PLS_CURCAR_INTO_AX
; JSR DEC_AX_BY_1
; JSR SET_SYSTEM_MARK_DIRECT ;ENTER SYSTEM MARK DIRECTLY IN TEXT
 JSR SET_SYSTEM_MARK_M1_DIRECT
;
.COPY_FUN:
;
 LDA BLOCK_OPERATION
;
 CMP #$95             ;COMM-2 COPY
 BEQ .DO_COPY
;
 JSR TEXT_PLS_CURCAR_INTO_AX
 CPX END_BLOCK+1      ;IS CURSOR BEFORE BLOCK?
 BNE .HI_TEST         ;IF SO, SYSTEM_MARK BUMPS BLOCK
 CMP END_BLOCK
.HI_TEST:
 BCS .PAST_BLOCK
;
 INC START_BLOCK
 BNE .BMP
 INC START_BLOCK+1
;
.BMP:
 INC END_BLOCK
 BNE .PAST_BLOCK
 INC END_BLOCK+1
;
.PAST_BLOCK:
 JSR DELETE_BLOCK     ;DO IT, NO PROMPT, NO FORMAT.
;
.DO_COPY:
 JSR GOTO_SYSTEM_MARK
;
.NO_MARK:
 LDY CURRENT_CHAR     ;INDEX TO CHARACTER IN LINE (MARK)
 INY                  ;MOVE 1 PAST MARK (SO WE CAN FIND OUR PLACE)
 JSR ADDYTX           ;ADJUST TEXT POINTER
;
 LDY POINTER2
 LDX POINTER2+1       ;DISTANCE TO MOVE
 INY
 BNE .SKP12384
 INX                  ;PLUS ONE FOR BASE 1
.SKP12384:
;
 JSR MOVEUP 
 BCS MC_END_STUFF
;
 LDX POINTER2
 LDY POINTER2+1       ;DISTANCE TO COPY FROM HI-RAM
;
 SEC
 LDA #<ENDRAM_M1
 SBC POINTER2
 STA POINTER2
 LDA #>ENDRAM_M1
 SBC POINTER2+1
 STA POINTER2+1       ;POINTS AT BEGINNING OF HI TEXT
;
 JSR P2_TO_TEXT_X_Y   ;MOVE .X.Y FROM P2 TO TEXT
;
MC_END_STUFF:
;
 JSR REMOVE_BLOCK
;
MC_FORM_MARK_END:
 JSR REFORMAT_DOC
 JSR GOTO_SYSTEM_MARK
 JSR FC_DELETE_CHAR_RT
 JMP DISPLAY_ON_AND_LINE_OUT_R
;
;
FC_DELETE_BLOCK:
;
 JSR SB_DISPLAY_BLOCK    ;ALLOW CURSOR W/O SELECT
;
 LDA END_BLOCK
 LDX END_BLOCK+1
;
 JSR SET_SYSTEM_MARK_DIRECT ;ENTER SYSTEM MARK DIRECTLY IN TEXT
 JSR DELETE_BLOCK
 JMP MC_END_STUFF
;
;
DELETE_BLOCK:
 LDA START_BLOCK
 STA MOVELO
 LDA START_BLOCK+1
 STA MOVELO+1
;
 LDA END_BLOCK
 STA MOVEHI
 LDA END_BLOCK+1
 STA MOVEHI+1
 INC MOVEHI
 BNE .SKP2438
 INC MOVEHI+1               ;END_BLOCK +=1 FOR ALL
.SKP2438:  
 JSR COPYDN
 JSR EB_MIN_SB_INTO_P2
 CLC                        ;CLC INSTEAD TO FORCE 1 LESS
 LDA EOT
 SBC POINTER2
 STA EOT
 LDA EOT+1
 SBC POINTER2+1
 STA EOT+1
DEL_BLK_ABORT:
 RTS
;
;_______________________________________________
;
IN_TAB_TABLE:
;
;IS .A IN TAB_TABLE?
;# MAX TABS
 LDX #MAX_TABS
.LOOP2460:
 CMP TAB_TABLE,X
 BEQ CLC_RTS
 DEX
 BPL .LOOP2460
SEC_RTS:
 SEC
 RTS
CLC_RTS:
 CLC
 RTS
;
SIX_CALLS:
 LDA #6
REPEAT_NODISPLAY:
 STA COUNT_DOWN
 JMP DISPLAYOFF
;
;
RET_CSDOWN_CODE:
;
 LDA EDIT_BUFFER_CHANGED    ;DID ANYTHING CHANGE?
 PHA                        
;
 JSR EDIT_BUFFER_TO_TEXT    ;SAVE OFF LINE AND
 PLA
;
 TAY                        ;EDIT_BUFFER_CHANGED
 LDA EDIT_LINE
 STA FIRST_CHAR_P           ;FIRST CHAR, PRECEEDING LINE
 CMP #CMARK                 ;CHECKMARK LINES CAN HAVE NO ATT
 BNE .SEND_ATTS
;
 LDA EDIT_LINE+1            ;FORCE REFORMAT FOR
 AND #$3F
;
;*NEW* SHOULD WATCH TAB LINE EDITED
;
 CMP #'M'-64                ;CHECK-M OR
 BEQ .MAYBE_REFORMAT
 CMP #'E'-64		    ;CHECK-E
 BNE .NO_REFORM
;
.MAYBE_REFORMAT: 
 TYA               
 BEQ .NO_REFORM             ;AND IF IT WAS CHANGED
 INC CHECKMARK_LINE_EDITED  ;IF 0, NOT CHANGED
;
.NO_REFORM:
 JSR PROCESS_MARGINS_1          ;SET NEW MARGIN TYPE
;
 JMP .ATTRS_DONE
;
.SEND_ATTS:
 LDY CURRENT_CHAR
.LOOP2515:
 LDA EDIT_LINE,Y
 BPL .SKP2517
;
 STY EDIT_TEMP              ;SAVE .Y TEMP
 JSR UPDATE_ATTRIBUTES_CR
;
 LDY EDIT_TEMP              ;RESTORE .Y
.SKP2517:
 INY
 CPY CHARS_IN_LINE
 BCC .LOOP2515
;
.ATTRS_DONE:
 JSR TEXT_TO_NEXTLINE       ;MOVE TO START OF NEXT LINE
 JSR TEXCF0                 ;LAST LINE (FOR RETURN?)
 BEQ .LAST_LINE
;
 JSR TEXT_TO_EDIT_BUFFER
;
.NO_NEW_LINE:
 LDA EDIT_LINE
 JSR UPDATE_ATTRIBUTES_CR
;
 LDA EDIT_LINE
 CMP #ENDT                  ;FORCE BNE
.LAST_LINE:
 RTS                        ;RTS BNE/BEQ
;
SCROLL_UP_TEST:
;
; LDX SCREEN_SECTION         ;0 OR 1 FOR SPLIT-SCREEN
 LDA IN_DATABASE_MODE		;1 = DB, 0 = NOT
 BNE .NO_SCROLL			;SCROLLING IS NOT ALLOWED IN THE DB
;
 LDA CURRENT_SCREEN_LINE
; CMP END_SCREEN,X           ;ARE WE AT THE END OF THIS SECTION?
 CMP #20			;MAXIMUM_LINES_M2
 BCC .NO_SCROLL
;
 JSR FDNETP
; JSR INC_LINE_PAGE
;# DO WE WANT TO DISPLAY HERE?
 RTS
; JMP DISPLY
;
.NO_SCROLL:
 INC CURRENT_SCREEN_LINE
 JMP AD28SC
;
;
SCROLL_DOWN_TEST:
;*NOTE* REWORK--SAVE SPACE
; LDX SCREEN_SECTION
 LDA CURRENT_SCREEN_LINE
; CMP END_SCREEN+2,X
; CMP END_SCREEN+2
 BEQ .SCROLL
;
 DEC CURRENT_SCREEN_LINE
 JMP DEC_SCREEN_28 
;
.SCROLL:
;
; JSR FDLATP
; JMP DISPLY
 JMP FDLATP
;
;SCREEN_SECTION:
; DB 0
;
;END_SCREEN:
;#UNIMPLEMENTED SPLIT-SCREEN FEATURE
; DB 20, 22
; DB 0,  0
;*PUT BACK*
;
ADD_TO_LINE:
;.A IS CHARACTER TO ADD TO LINE LENGTH
 CMP #$80
 BCS ADD_T_ABORT
;
LL_PLUS_FONTB_A:
 LDY CURRENT_FONT     ;$FF = NO FONT (TEXT)
 BMI INC_LL_BY_1
;
 CMP #$5D             ;EXTENDED CHAR
 BCC .NOT_EXT
;
 JSR SCREEN_CODE_TO_WIDTH
;
.NOT_EXT:
 TAY
;
LL_PLUS_FONTB_Y:
!byte $B9;OPCODE FOR LDA $FFFF,Y
FONT_BASE_SM1:
!word $ABCD;EFFECTIVLY LDA $FONT_BASE,Y
;
 BIT ATTRIBUTES          ;CHECK FOR BOLD
 BPL TEST_EXPAND         ;NO, NOT BOLD
 CLC
 ADC #1 
;
TEST_EXPAND:
 BIT EXPAND_ON
 BPL LL_PLUS_A
 ASL                   ;DOUBLE IT
;
LL_PLUS_A:
 CLC
LL_PLUS_A1:
 ADC LINE_LENGTH
 STA LINE_LENGTH
 BCC ADD_T_ABORT
 INC LINE_LENGTH+1
ADD_T_ABORT:
 RTS
;
INC_LL_BY_1:
;
 INC LINE_LENGTH
 BNE .SKP2637
 INC LINE_LENGTH+1
.SKP2637:
 RTS
;
INC_LL_LB_ONLY: 
 INC LINE_LENGTH
 RTS
;
LL_PLUS_FONTBX_A:
 LDX CURRENT_FONT     ;$FF = NO FONT (TEXT)
; BMI INC_LL_BY_1
 BMI INC_LL_LB_ONLY
;
 CMP #$5D             ;EXTENDED CHAR
 BCC .NOT_EXT2652
;
 JSR SCREEN_CODE_TO_WIDTH   ;.Y, .X UNHARMED
;
.NOT_EXT2652:
;
 TAX
;
LL_PLUS_FONTB_X:
!byte $BD;OPCODE FOR LDA $FFFF,X
FONT_BASE_SM2:
!word $ABCD;EFFECTIVLY LDA $FONT_BASE,X
;
 BIT ATTRIBUTES          ;CHECK FOR BOLD
 BPL .TEST_EXPAND        ;NO, NOT BOLD
 CLC
 ADC #1 
;
.TEST_EXPAND:
 BIT EXPAND_ON
 BPL .LL_PLUS_A
 ASL                   ;DOUBLE IT
;
.LL_PLUS_A:
 CLC
.LL_PLUS_A1:
 ADC LINE_LENGTH
 STA LINE_LENGTH
 BCC .ADD_T_ABORT
 INC LINE_LENGTH+1
.ADD_T_ABORT:
 RTS
;
;
DELETE_FROM_LINE:
;.X UNHARMED
;
 CMP #$80
 BCS ADD_T_ABORT
;
 LDY CURRENT_FONT              ;IS THIS TEXT MODE?
 BMI LL_MINUS_ONE              ;IF SO BRANCH
;
 TAY
;
LL_MINUS_FONTB_Y:
 LDA (FONT_BASE),Y             ;GET WIDTH OF CHAR
 BIT ATTRIBUTES                ;ARE WE BOLDFACING?
 BPL LL_MINUS_A                ;BRANCH IF NOT
 CLC
 BCC LL_MINUS_A1               ;SUBTRACT CC (+1)
;
LL_MINUS_ONE:
 LDA #1
LL_MINUS_A:
 SEC
LL_MINUS_A1:
 EOR #$FF
 ADC LINE_LENGTH
 STA LINE_LENGTH
 BCS .SKP2712
 DEC LINE_LENGTH+1
.SKP2712:
 RTS
;
;
UPDATE_LINE_COUNTU:
;
;
 LDA FIRST_CHAR_F       ;DID WE COME FROM A NORMAL LINE?
 CMP #CMARK
 BEQ .UPD_LINE          ;IF NO, PROCESS CAME FROM CHECK...
;
 LDA LINE               ;IF ON LINE 1 PAGE 1 OR
 ORA PAGE               ;   ON LINE 0 PAGE 1
 CMP #1
 BNE .NOT_FIRST_PAGE
 LDA EDIT_LINE          ;MOVE TO A CHECK?
 CMP #CMARK
 BNE .NOT_FIRST_PAGE
 LDA #0
 STA LINE
 JMP ZERO_INTO_CUR_PAGE_LENGTH
;
;
.NOT_FIRST_PAGE:
 LDA LINE               ;IS THIS THE FIRST LINE OF A PAGE?
 CMP #2                 ;IF NOT,
 BCS .NOT_FIRST_LINE2740    ;GO ON TO DECREMENT
;
 LDA EDIT_LINE          ;IF SO, IS THE LINE WE MOVED TO A CHECK?
 CMP #CMARK             ;IF NOT, THEN GO ON TO DECREMENT
 BEQ .SUBTR             ;IF SO, THEN SKIP LINE DEC, BUT DO CUR PAGE
;
.NOT_FIRST_LINE2740:
 JSR DEC_LINE           ;DECREMENT LINE MODALLY
;*NEW*
;
.SUBTR:
;
 LDA CU_TEMP            ;IS BIGGEST POINSIZE 1-3 IF TEXT
 BIT EXPAND_ON
 BPL .NOEXP 
 ASL 
.NOEXP: 
 JSR A_AND_LEAD_MIN_CUR_PAGE    ;CC DONE IN FUNCTION
;
;
.NOT_CHECK2760:
 LDA CUR_PAGE_LENGTH+1
 CMP #$FF                ;DID PAGE LENGTH GO BELOW ZERO?
 BEQ .PREV_PAGE          ;IF SO, FLIP PAGE BACK
;
.TST_LO:
 ORA CUR_PAGE_LENGTH     ;IF PAGE LENGTH IS > ZERO,
 BNE .OUT2767                ;JUST BUMP LINE
;
.PREV_PAGE:
;
 DEC PAGE
 LDX PAGE
;
;*NEW*
 JSR OV_DB_PREV_PAGE
 BCS .DB_MODE_REENTRY
;
; LDA IN_DATABASE_MODE
; BEQ ?NOT_DB
;
; LDA MAXIMUM_LINES
; STA CUR_PAGE_LENGTH
; STA LINE
; LDA #0
; STA CUR_PAGE_LENGTH+1
; BEQ ?DB_MODE_REENTRY
;
.NOT_DB:
 LDA PAGE_TABLE,X
 STA LINE
;
 LDA PAGE_LENGTH_LO,X
 STA CUR_PAGE_LENGTH
 LDA PAGE_LENGTH_HI,X
 STA CUR_PAGE_LENGTH+1  ;GRAPHIC FP NOW REQUIRES WHOLE DEPTH
;
.DB_MODE_REENTRY:
 JSR PAGOUT
;
.UPD_LINE:
 LDA EDIT_LINE           ;CAME FROM CHECKMARK, DID WE
 CMP #CMARK              ;GO TO CHECKMARK?
 BEQ .OUT2767                ;IF SO, EXIT
;
 LDA #1
 CMP PAGE                ;WAS IT PAGE 1?
 BEQ .OUT2767
 LDA CUR_PAGE_LENGTH
 ORA CUR_PAGE_LENGTH+1
 BEQ .PREV_PAGE
;
.OUT2767:
 JMP LINE_OUT
;
;
UPDATE_LINE_COUNTD:
;
 LDA FIRST_CHAR_P       ;DID WE MOVE FROM A CHECKMARK LINE?
 CMP #CMARK
 BNE .NORMAL_LINE       ;IF NO, GO PROCESS MOVE FROM NORMAL LINE
;
;;*REMOVE*
; LDA CUR_PAGE_LENGTH    ;ARE WE ON LINE ONE, "BEFORE THE PAGE?"
; ORA CUR_PAGE_LENGTH+1
; BNE ?NOT_FIRST_LINE
;;
; LDX NEW_LINE_SPACE     ;ARE WE IN TM WITH A /S COMMAND?
; BEQ ?NOT_FIRST_LINE    ;IF NOT, EXIT
;; DEX                    ;MINUS 1
; STX CUR_PAGE_LENGTH    ;TM ONLY, FIRST PAGE ONLY
;
;?NOT_FIRST_LINE:
 LDA EDIT_LINE          ;FROM A CHECK TO A CHECK?
 CMP #CMARK             ;IF SO, NO CHANGE!
 BEQ .OUT2835 
;
.NO_INC_LINE: 
 JMP BUMP_LINE_PAGE
.OUT2835:
 RTS                  ;IF SO, EXIT
;
.NORMAL_LINE:
 LDA EDIT_LINE
 CMP #CMARK           ;DID WE MOVE TO A NORMAL LINE?
 BEQ .OUT2835             ;IF NOT, LEAVE HERE
;
 JSR BUMP_LINE_PAGE
;(FT)
;
LINE_OUT:
 LDA DISPLY
 CMP #$60
 BEQ JUST_RETURN	;LINE_OUT_OUT
;
FC_LINE_OUT:
 JMP LINOUT
;
;
;
DEC_ACTUAL_COLUMN:
;
 LDX CURRENT_CHAR
 LDA CURRENT_FONT	;FONT MODE?
 BPL .NO_TAB_STUFF 
 LDA EDIT_LINE+1,X	;DID WE JUST COME FROM A
 CMP #TABCHAR		;TAB CHARACTER?
 BEQ JUST_RETURN	;IF SO, ACTUAL COLUMN MUST BE SET.
;
.NO_TAB_STUFF:
 LDA EDIT_LINE,X      	;IS THIS A REAL CHARACTER?
 BMI JUST_RETURN      	;BIF NO
 DEC ACTUAL_COLUMN
SHOW_COLUMN:
 JMP ACTUAL_COLUMN_OUT       ;DISPLAY COLUMN
JUST_RETURN:
 RTS
;
;
INC_ACTUAL_COLUMN:
;ASSUME CURRENT_CHAR POINTS AT CURRENT CHAR, (CURSOR RIGHT CALLS)
 LDX CURRENT_CHAR
 LDA JUSTIFY_FORMAT
 BNE .NO_TAB_STUFF2883
;
 LDA CURRENT_FONT
 BPL .NO_TAB_STUFF2883
;
 LDA EDIT_LINE,X	;ARE WE ON A TAB CHARACTER
 CMP #TABCHAR
 BEQ SHOW_COLUMN
.NO_TAB_STUFF2883:
 DEX
 LDA EDIT_LINE,X      	;IS THIS A REAL CHARACTER?
 BMI JUST_RETURN        ;BIF NO
;
 INC ACTUAL_COLUMN
 BNE SHOW_COLUMN	;BRA
;
;
LINE_ERROR_PANIC:
;
 JSR END_PLAY               ;KILL MACRO
 JSR NOT_ENOUGH_MEMORY      ;USER ACKNOWLEDGE
;
; LDX CHARS_IN_LINE
; LDA EDIT_LINE,X
; CMP #ENDT
; BNE ?NORMAL
;
; LDA CURRENT_KEY
; CMP #$91
; BNE ?NORMAL
;
; BK
; BK
;
.NORMAL:
 JSR TO_LEFT_MARGIN
 JSR TEXT_TO_EDIT_BUFFER
 JSR CALCULATE_LINE_LENGTH  ;SET LINE LENGTH
 JSR DISPLAYON
 LDX #$FF
 TXS
 JMP PROCESS_LINE
;
;
FC_EDIT_BUFFER_TO_TEXT:
 LDA #1
 STA EDIT_BUFFER_CHANGED
;
EDIT_BUFFER_TO_TEXT:
;
 LDA EDIT_LINE
 STA FIRST_CHAR
;
 LDA EDIT_BUFFER_CHANGED
 BEQ NO_CHANGE_IN_LINE
;
 STA DOCUMENT_ALTERED    ;SHOW THE DOCUMENT HAS CHANGED
;
 LDY OLD_CHARS_IN_LINE
 CPY CHARS_IN_LINE    
 BEQ CHECK_LENGTH        ;IF .Y = CHARS IN LINE JUST COPY IN
 BCS LINE_LENGTH_DEL     ;IF .Y > CHARS IN LINE REMOVE DIFFERENCE
;
 INY
;
 LDX CHARS_IN_LINE
 INX                     ;Y < CHARS_IN_LINE, INCREASE BY CHARS_IN_LINE - Y
 TXA                     ;.X = HI BYTE OF LENGTH TO INSERT
 SEC                  
 STY TEMP
 SBC TEMP
 TAY                     ;.Y = LO BYTE OF LENGTH
;
 JSR EOM_TEST_PLUS_Y
 BCS LINE_ERROR_PANIC
;
 JSR MOVE_UP_Y
 JMP COPY_LINE_TO_TEXT
;
LINE_LENGTH_DEL:
;
 TYA                     ;Y > CHARS_IN_LINE, DECREASE BY Y - CHARS_IN_LINE
 SEC
 SBC CHARS_IN_LINE
 JSR REMOVE_A_BYTES      ;DELETE .A BYTES FROM TEXT
 JMP COPY_LINE_TO_TEXT
;
CHECK_LENGTH:
;
 JSR NO_CHANGE_IN_LINE   ;ARE THERE 4 EXTRA FREE?
;
COPY_LINE_TO_TEXT:
;ENTRY FOR DEL-EOT
;
 LDY CHARS_IN_LINE
 STY OLD_CHARS_IN_LINE   ;AFTER COPY, SET FOR "ALL NORMAL"
;
.LOOP2980:
 LDA EDIT_LINE,Y
 STA (TEXT),Y
 DEY
 BNE .LOOP2980
;
 LDA EDIT_LINE
 STA (TEXT),Y
;
COPY_OUT_CLEAR:
 STY EDIT_BUFFER_CHANGED
;
COPY_OUT:
 CLC
 RTS
;
NO_CHANGE_IN_LINE: 
 LDY #0                  ;IS THERE PLENTY OF MEMORY?
Y_BYTES_FREE:
 JSR EOM_TEST_PLUS_Y     ;IF SO, ADD NEW STUFF
; BCC ?MEM_OK
 BCS LINE_ERROR_PANIC
;
.MEM_OK3003:
 RTS                     ;CC, RTS
;
;--------------------
;
TEXT_TO_EDIT_BUFFER:
 LDY #0
 STY PRINTABLE_CHARACTERS
 STY EDIT_BUFFER_CHANGED
 STY TAB_PRESENT_IN_LINE
 DEY
;
.LOOP3015:
 INY
 INC PRINTABLE_CHARACTERS
 LDA (TEXT),Y
 STA EDIT_LINE,Y
 BPL .LOOP3015
 DEC PRINTABLE_CHARACTERS
 CMP #TABCHAR
 BNE .LINE_END
 LDA JUSTIFY_FORMAT		;ARE WE IN LEFT JUSTIFY?
 BNE .LOOP3015			;IF NOT, GO TO LOOP, ELSE ADD
 INC TAB_PRESENT_IN_LINE	;1 TAB AND FALL THRU (.AC = 0..3)
;
.LINE_END: 
 CMP #ENDT                  ;ARE WE DONE?
 BCC .LOOP3015                  ;NO, DO NEXT
 STA END_LINE_TYPE
 STY CHARS_IN_LINE
 STY OLD_CHARS_IN_LINE
 RTS
;
;--------------------
;
UPDATE_BUFFER_AND_LINEL:
;
 JSR TEXT_TO_EDIT_BUFFER
;
;(FT)
CALCULATE_LINE_LENGTH:
;
;THIS ENTRY FOR START OF LINE ONLY, SETS START ATTS
;
 LDA ATTRIBUTES
 STA START_LINE_ATTRIBUTES  ;SET 1ST CHAR ATTRIBUTES
;
 LDA CURRENT_FONT
 STA START_LINE_FONT        ;SET 1ST CHAR FONT
;
CALCULATE_LINE_LENGTH1:
;
;THIS ENTRY FOR MID LINE
;
 LDA ATTRIBUTES             ;MAY CHANGE BF
 PHA                        ;DURING ROUTINE
 LDA CURRENT_FONT           ;MAY CHANGE FONT BASE
 PHA                        ;AS WELL
;
 LDA START_LINE_FONT
 JSR POINT_AXPT_UPDATE_FBASE   ;UPDATE FONT AND CURRENT PTS
;
 LDA CURRENT_POINTSIZE
 STA BIGGEST_POINTSIZE
;
 LDY #0
 STY SKIP_NEXT_CHAR_TM
;*NOTE* DESERVES ZP STATUS
 STY LINE_LENGTH
 STY LINE_LENGTH+1
;
CLL_LOOP:
 LDA EDIT_LINE,Y            ;GET CHAR FROM LINE
 BMI CLL_FONT_STYLE_END        ;IF FONT/STYLE OR END BRANCH
 BIT SKIP_NEXT_CHAR_TM
 BPL .ADD_TO_LINE
 LDA #0
 STA SKIP_NEXT_CHAR_TM
 BEQ CLL_LOOP_INC
;
.ADD_TO_LINE: 
 JSR LL_PLUS_FONTBX_A       ;ADD TO LINE LENGTH
;
CLL_LOOP_INC:
;
!byte $C0;CPY # OPCODE
CLL_INTERRUPT_POINT:
!byte $FF;AT THIS POINT, IF TM, WE NEED TO SAVE LL
 BNE .LOOP_AGAIN
;
 LDA LINE_LENGTH		;SHOULD GET HERE IN TEXT MODE ONLY
 STA CUR_LEFT_FLAG_RESULT1	;
;
.LOOP_AGAIN:
 INY
 BNE CLL_LOOP                  ;DO IT AGAIN
;
CLL_FONT_STYLE_END: 
 CMP #ENDT                  ;END OF THE LINE?
 BCS .END_ALL               ;YES, QUIT
;
 CMP #TABCHAR			;IS THIS A TAB CHARACTER?
 BNE .CHECK_FONT_MODE
;
 LDX JUSTIFY_FORMAT		;ARE WE LEFT ALIGNING?
 BNE CLL_LOOP_INC              	;IF SO, SKIP IT
;
 JSR PUSH_AX			;BE SAFE
 STY .STOREY_SM1
;
 LDA LINE_LENGTH
 STA TAB_LINE_LEN
 LDA LINE_LENGTH+1
 STA TAB_LINE_LEN+1		;WANT NEXT TAB BIGGER THAN THIS
;
 LDY #0
 JSR FIND_TAB_GT_TLL
 BCC .NO_TAB3120			;CC = NO TAB FOUND, CS TAB FOUND
;*NOTE* WHAT ABOUT TAB > MARGIN HERE?
;
 STA LINE_LENGTH
 STX LINE_LENGTH+1
 LDA CURRENT_FONT		;WHAT FONT?
 BPL .NO_TAB3120			;IF FONT MODE, SKIP
 STA SKIP_NEXT_CHAR_TM		;[FF] SET FLAG TO SKIP
;
.NO_TAB3120:
 JSR POP_AX
!byte $A0;LDY #
.STOREY_SM1:
!byte 0
 JMP CLL_LOOP_INC
;
.CHECK_FONT_MODE:
 LDX CURRENT_FONT           ;ARE WE IN TEXT MODE?
 BMI CLL_LOOP_INC              ;IF SO, SKIP IT
;
 JSR SET_UNSET_BOLD
 BEQ CLL_LOOP_INC              ;BEQ MEANS BOLD WAS HANDLED
;
.FONT_CODE:
 JSR IS_FONT_CODE           ;FONT?
 BCC CLL_LOOP_INC              ;IF NOT
 SBC #'1'+$80               ;MAKE FONT #
 BPL .FNT10
 LDA #9 
.FNT10: 
 STY FONT_WORK
;
 JSR POINT_AXPT_UPDATE_FBASE ;UPDATE FONT AND CURRENT PTS .A PTS
;
 LDY FONT_WORK
 CMP BIGGEST_POINTSIZE
 BCC CLL_LOOP_INC              ;NEXT CHARACTER
;
 STA BIGGEST_POINTSIZE      ;BIGGEST POINTSIZE THIS LINE
;?SKP1:
; JMP ?LOOP_INC
;*NEW* WAS JMP
 BCS CLL_LOOP_INC			;BRA
;
.END_ALL: 
 PLA
 STA CURRENT_FONT           ;RESTOR FONT
 JSR POINT_AXPT_UPDATE_FBASE   ;UPDATE FONT AND CURRENT PTS
;
 PLA 
 STA ATTRIBUTES
 RTS
;
;
FULL_SCREEN:
 JSR CLR_BACKGROUND
;
ON_AND_REFREASH:
;
; LDA #$20
; STA DISPLY
 JSR DISPLAY_ON_NO_DISPLAY
REFREASH_ALL_SCREEN:
 JSR RESET
DISPLAY_SCREEN_AND_HEADER:
 JSR DISPLY
 JSR HEADER
 LDX BLKSET
 BNE .SKP3188
 RTS
.SKP3188:
 LDX #21
 JMP SERPP0
;
;
STORE_BEGIN_LINE:
 JSR EDIT_BUFFER_TO_TEXT
;FT
GO_LEFT_MARGIN:
;
 LDX #0
 STX COLUMN
 STX COUNT
 STX CURRENT_CHAR
 INX               ;[1]
 STX ACTUAL_COLUMN ;COUNTS 1..N
 JMP ACTUAL_COLUMN_OUT
;
;
TO_LEFT_MARGIN:
;
 LDX #1
 STX ACTUAL_COLUMN
 DEX
 STX CURRENT_CHAR
 TXA
;
SET_CC_FROM_A:
;
 CMP #$25
 BCS .SOME_COUNT
 STA COLUMN
 LDA #0
 STA COUNT
 RTS
;
.SOME_COUNT:
 PHA               ;# CHARACTERS IN THIS LINE
;CLC
 SBC #$24          ; MINUS SCREEN SIZE
 STA COUNT
 PLA
 SEC
 SBC COUNT
 STA COLUMN
 RTS
;
;
DISPLAY_ON_NO_DISPLAY:
 LDA #$20
 STA DISPLY
 RTS
;
SEARCH_COL_POSITION:
;MOVE CURSOR TO END-OF-LINE OR CURRENT COLUMN, WHICHEVER
;COMES FIRST.  ADJUST COUNT AND COLUMN AS YOU GO.
;
 LDA CURRENT_CHAR
 PHA
 JSR GO_LEFT_MARGIN
;
 LDA EDIT_LINE
 CMP #TABCHAR
 BNE .TAB_NOT_FIRST_CHAR
;
 LDA JUSTIFY_FORMAT		;ONLY IN LEFT JUSTIFY MODE
 BNE .TAB_NOT_FIRST_CHAR
;
 LDA CURRENT_FONT		;AND IN FONT MODE?
 BPL .TAB_NOT_FIRST_CHAR	;IF SO, LEAVE
;
 LDA TAB_TABLE			;GET 1ST TAB POS
 CMP #$FF			;WATCH OUT FOR NO SUCH
 BEQ .TAB_NOT_FIRST_CHAR	
 STA ACTUAL_COLUMN		;MAKE ACTUAL COLUMN FIRST COLUMN
;
.TAB_NOT_FIRST_CHAR: 
 PLA
;
;(FT)
COL_A_OR_END_LINE:
;
 STA TEMP3                  ;STORE OF # TO MOVE
 TAX
 BEQ .ABORT3274                 ;IF ZERO AT END
 LDX CHARS_IN_LINE          ;HOW MANY CHARS IN LINE?
 DEX 
 BEQ .ABORT3274                 ;IF ZERO, DONE
 CPX TEMP3                  ;IS CHARS_IN_LINE < LAST COLUMN?
 BCS .LOOP3279                  ;IF NOT MOVE BY LAST COLUMN POS
;
 STX TEMP3                  ;ELSE MOVE BY # CHARS
.LOOP3279:
 JSR FC_CURSOR_RIGHT
 DEC TEMP3      
 BNE .LOOP3279
.ABORT3274:
 RTS
;
;
;
UPDATE_CURRENT_LINE_DEPTH: 
;
 JSR BP_MIN_CUR_PAGE_LENGTH
 JSR CALCULATE_LINE_LENGTH1
 JMP BP_PLS_CUR_PAGE_LENGTH
;
;
SKIP_NEXT_CHAR_TM:
!byte 0
TAB_PRESENT_IN_LINE:
!byte 0
NEW_LINE_SPACE:
!byte 0
PAGE_FORCED:
!byte 0
CHECKMARK_LINE_EDITED:
!byte 0
START_LINE_ATTRIBUTES:
!byte 0
START_LINE_FONT:
!byte 0
CU_TEMP:
!byte 0
EDIT_LINE:
!fill  240, $FF
EDIT_LINE_P1 =  EDIT_LINE+1
;EDIT_BUFFER_CHANGED:     DB 0
OLD_CHARS_IN_LINE:
!byte 0;(TO SPEED UP EB TO TEXT)
;DOCUMENT_ALTERED:        DB 0
;
;
;
!eof
;
; PUBLIC AX_INTO_START_BLOCK
; PUBLIC BUMP_COLUMN_COUNT
; PUBLIC ACTUAL_COLUMN
; PUBLIC CALCULATE_LINE_LENGTH
; PUBLIC CALCULATE_LINE_LENGTH1
; PUBLIC CD_CURSOR_UPS
; PUBLIC CHANGED_EDIT_BUFFER
; PUBLIC CHANGE_TO_GRAPHICS
; PUBLIC CHANGE_TO_TEXT
; PUBLIC CHARS_IN_LINE
; PUBLIC CLL_INTERRUPT_POINT
; PUBLIC DBUMP_COLUMN_COUNT
; PUBLIC DEL_WHOLE_LINE
; PUBLIC DELETE_BLOCK
; PUBLIC DELETE_FROM_LINE
; PUBLIC DISPLAY_AND_LINE_OUT
; PUBLIC DISPLAY_ON_NO_DISPLAY
; PUBLIC DISPLAY_ON_AND_LINE_OUT
; PUBLIC DISPLAY_ON_AND_LINE_OUT_R
; PUBLIC DISPLAY_SCREEN_AND_HEADER
; PUBLIC EDIT_BUFFER_TO_TEXT
; PUBLIC EDIT_LINE
; PUBLIC EDIT_LINE_P1
; PUBLIC EMBEDDED_CODES
; PUBLIC END_PLAY
; PUBLIC EXTENDED_CODES
; PUBLIC FC_CURSOR_DOWN_DSP
; PUBLIC FC_CURSOR_UP_DSP
; PUBLIC FC_FCURSOR_DOWN
; PUBLIC FC_FCURSOR_UP
; PUBLIC FC_DELETE_BLOCK
; PUBLIC FC_DELETE_LINE
; PUBLIC FC_DELETE_CHAR
; PUBLIC FC_DELETE_CHAR_RT
; PUBLIC FC_DELETE_WORD
; PUBLIC FC_DELETE_TO_EOL
; PUBLIC FC_EMBEDDED_STYLES
; PUBLIC FC_END_OF_LINE
; PUBLIC FC_BEGINNING_OF_LINE_DSP
; PUBLIC FC_HOME_CURSOR
; PUBLIC FC_INS_RETURN
; PUBLIC FC_MOVE_COPY
; PUBLIC FC_PAGE_FORWARD
; PUBLIC FC_PAGE_FORWARD_NT
; PUBLIC FC_PAGE_BACKWARD
; PUBLIC FC_BOTTOM_OF_SCREEN
; PUBLIC FC_BEGINNING_OF_LINE
; PUBLIC FC_CLEAR_HOME
; PUBLIC FC_CLEAR_HOME_DSP
; PUBLIC FC_CLEAR_HOME_NT
; PUBLIC FC_CLEAR_HOME_NTND
; PUBLIC FC_CURSOR_UP
; PUBLIC FC_CURSOR_DOWN
; PUBLIC FC_CURSOR_LEFT
; PUBLIC FC_CURSOR_RIGHT
; PUBLIC FC_EDIT_BUFFER_TO_TEXT
; PUBLIC FC_END_OF_DOCUMENT
; PUBLIC FC_EXIT_OR_RESET
; PUBLIC FC_RETURN
; PUBLIC FC_INSERT_LINE
; PUBLIC FC_INSERT_LINE1
; PUBLIC FC_TAB_FORWARD_NORMAL
; PUBLIC FC_SHOW_STATUS
; PUBLIC FC_FORCE_FORMAT
; PUBLIC FC_INSERT_CHECKMARK
; PUBLIC FC_LINE_OUT
; PUBLIC FC_MACRO_RECORD
; PUBLIC FC_MACRO_PLAY
; PUBLIC FC_PLAY_MACRO_TWO
; PUBLIC FC_PRINT_FILE
; PUBLIC FC_REFORMAT_DOC
; PUBLIC FC_REFORMAT_FROM_CURSOR
; PUBLIC FC_SET_BLOCK
; PUBLIC FC_TOGGLE_HRET
; PUBLIC FC_TOGGLE_TEXT_GRAPHICS
; PUBLIC FC_INSERT_CHAR
; PUBLIC FC_WORK_KEY
; PUBLIC FC_WORK_KEY_INS
; PUBLIC FONT_BASE_SM1
; PUBLIC FONT_BASE_SM2
; PUBLIC FULL_SCREEN
; PUBLIC GO_LEFT_MARGIN
; PUBLIC KILL_DOC
; PUBLIC LINE_OUT
; PUBLIC LL_MINUS_A
; PUBLIC LL_PLUS_A
; PUBLIC LL_PLUS_FONTB_A
; PUBLIC LL_PLUS_FONTBX_A
; PUBLIC MC_FORM_MARK_END
; PUBLIC NEW_LINE_SPACE
; PUBLIC OLD_CHARS_IN_LINE
; PUBLIC ON_AND_REFREASH
; PUBLIC PAGE_FORCED
; PUBLIC PLACE_CHARACTER
; PUBLIC PUT_END_OF_RECORD
; PUBLIC REFREASH_ALL_SCREEN
; PUBLIC REFORMAT_DOC
; PUBLIC SCREEN_CODE_SUBST
; PUBLIC SET_TO_TEXT_OR_GRAPHICS
; PUBLIC START_LINE_ATTRIBUTES
; PUBLIC START_LINE_FONT
; PUBLIC STORE_BEGIN_LINE
; PUBLIC TAB_PRESENT_IN_LINE
; PUBLIC TEXT_TO_EDIT_BUFFER
; PUBLIC WORK_KEY
; EXTERN FONT_ONE
; EXTERN A_AND_LEAD_MIN_CUR_PAGE
; EXTERN A_MIN_CUR_PAGE_LENGTH
; EXTERN A_PLS_CUR_PAGE_LENGTH
; EXTERN AX_INTO_EOT
; EXTERN AX_INTO_P2
; EXTERN AX_INTO_PG_LENGTH
; EXTERN ACTUAL_COLUMN_OUT
; EXTERN ADDATX
; EXTERN ADDYTX
; EXTERN AD28SC
; EXTERN ATT_ON_TABLE
; EXTERN AXASCII
; EXTERN AX_INTO_CUR_PAGE_LENGTH
; EXTERN AX_INTO_PT
; EXTERN AX_INTO_TEXT
; EXTERN BIGGEST_AND_CURRENT
; EXTERN BLKSET
; EXTERN BP_AND_LEAD_INTO_A
; EXTERN BP_AND_2LEAD_INTO_A
; EXTERN BP_MIN_CUR_PAGE_LENGTH
; EXTERN BP_PLS_CUR_PAGE_LENGTH
; EXTERN BUFSCN
; EXTERN BUMP_LINE_PAGE
; EXTERN BYEBYE
; EXTERN CHARACTERS_IN_LINE
; EXTERN CHECK_SET_FONT
; EXTERN CLALL
; EXTERN CLEAR_P1
; EXTERN CLINOT
; EXTERN CLRBLK
; EXTERN CLR_BACKGROUND
; EXTERN COPYDN
; EXTERN CUR_LEFT_FLAG
; EXTERN CUR_LEFT_FLAG_RESULT
; EXTERN CUR_LEFT_FLAG_RESULT1
; EXTERN CURSOR_IN_BLOCK
; EXTERN CURRENT_CHARACTER_Y
; EXTERN DECEOA
; EXTERN DEC_AX_BY_P2
; EXTERN DEC_AX_BY_1
; EXTERN DEC_LINE
; EXTERN DEC_SCREEN_28
; EXTERN DISPLY
; EXTERN DISPLAYOFF
; EXTERN DISPLAYON
; EXTERN DIV_AX_BY_Y
; EXTERN EB_MIN_SB_INTO_P2
; EXTERN END_BLOCK
; EXTERN END_LINE_TYPE
; EXTERN ENTER_DB_FIELDS
; EXTERN EOM_SAFETY_FUDGE
; EXTERN EOM_TEST_PLUS_Y
; EXTERN EOM_TEST_PLUS_0
; EXTERN EOT_INTO_AX
; EXTERN EOT_EQ_TEXT_PLS_Y
; EXTERN FC_OUTLINE_REFORMAT
; EXTERN FC_WRAP_LINE
; EXTERN FDLATP
; EXTERN FDNETP
; EXTERN FIND_PREV_FONT
; EXTERN FIND_PREV_MARGIN
; EXTERN FIND_PREV_STYLE
; EXTERN FILE_EXISTS
; EXTERN FIND_TAB_GT_TLL
; EXTERN FIX_ACTUAL_COLUMN
; EXTERN FIX_ACTUAL_COLUMN_IF_TABLINE
; EXTERN FONT_BYTES
; EXTERN FONT_LEADING
; EXTERN FONT_TABLE
; EXTERN FONT_TABLE_X_INTO_PT
; EXTERN GETIN
; EXTERN GET_PRINT_PARAMETERS
; EXTERN GPRINT_FILE
; EXTERN GEOFIL
; EXTERN GEOSMG
; EXTERN GLOAD
; EXTERN GOTO_SYSTEM_MARK
; EXTERN GPRINT_WARN_BOX
; EXTERN HEADER
; EXTERN HEADAT
; EXTERN IMAGE_LINE
; EXTERN INC1P1
; EXTERN INCEO1
; EXTERN INCREMENT_P1
; EXTERN INCTE1
; EXTERN INC_LINE
; EXTERN INC_PT_BY_1
; EXTERN INIDSK
; EXTERN INITIL
; EXTERN INIT_BLOCK_TWO
; EXTERN INSERTM
; EXTERN IS_BOLD
; EXTERN IS_FONT_CODE
; EXTERN IS_FONT_OR_BOLD
; EXTERN IS_FONT_PRINTING
; EXTERN IS_STYLE_CODE
; EXTERN IW_INTO_AX
; EXTERN JUSTIFY_FORMAT
; EXTERN JUSTIFY_TABLE
; EXTERN KEYBRD
; EXTERN KEY_RECORD_END
; EXTERN KEY_RECORD_INDEX
; EXTERN KILL_BLOCK
; EXTERN LDA_TEXT_Y
; EXTERN LETTER_OR_NUMBER
; EXTERN LINOUT
; EXTERN MACRO_1_END
; EXTERN MACRO_1_START
; EXTERN MACRO_FIX_X
; EXTERN MACRO_LIMIT
; EXTERN MAXIMUM_LINES
; EXTERN MESSAGE_ON
; EXTERN MNLINE
; EXTERN MOVEUP
; EXTERN MOVE_UP_ONE
; EXTERN MOVE_UP_Y
; EXTERN MOVE_TO_END_OF_WORD
; EXTERN MOVE_TO_START_OF_WORD
; EXTERN MH_EQ_MV_A
; EXTERN NEW_LINES_PAGE
; EXTERN NOT_ENOUGH_MEMORY
; EXTERN ON_LAST_LINE
; EXTERN OPNDIC
; EXTERN OUTMODE
; EXTERN OVERLAY_IN_MEMORY
; EXTERN OV_ALLOW_CURSOR_UP
; EXTERN OV_DB_PREV_PAGE
; EXTERN OV_SET_TO_TOP_PAGE
; EXTERN OV_OUTLINE_REFORMAT
; EXTERN PAGE_LENGTH
; EXTERN PAGE_LENGTH_LO
; EXTERN PAGE_LENGTH_HI
; EXTERN PAGE_TABLE
; EXTERN PAGOUT
; EXTERN PARAGRAPH_FORMAT
; EXTERN PRKECY
; EXTERN PUSH_AX
; EXTERN PUSH_AXY
; EXTERN PUSH_EOT
; EXTERN PUSH_TEXT
; EXTERN POINT_AXPT_AT_FONT
; EXTERN POINT_AXPT_UPDATE_FBASE
; EXTERN POP_AXY
; EXTERN POP_AX
; EXTERN POP_EOT
; EXTERN POP_TEXT
; EXTERN PRINT_GRAPHICS
; EXTERN PROCESS_LINE
; EXTERN PROCESS_MARGINS
; EXTERN PROCESS_MARGINS_1
; EXTERN PTCTRL
; EXTERN PW_S_PRINT_GRAPHICS
; EXTERN P2_TO_TEXT_X_Y
; EXTERN RECORD_PLAY
; EXTERN REMOVE_A_BYTES
; EXTERN REMOVE_BLOCK
; EXTERN RESET
; EXTERN RESET_AND_DISPLAY
; EXTERN RET_AT_TEXT_Y
; EXTERN SAVE_DOCUMENT
; EXTERN SAVE_DOCUMENT_1
; EXTERN SAVE_SPACING
; EXTERN SEARCH_BACK_THRU_CHECKS
; EXTERN SETLFS
; EXTERN SETSCN
; EXTERN SETNAM
; EXTERN SET_TO_TOP_PAGE
; EXTERN SERPPT
; EXTERN SERPP0
; EXTERN SET_BIG_AND_CURRENT
; EXTERN SET_DB_FIELD_NAME
; EXTERN SET_FONT
; EXTERN SET_MARGIN
; EXTERN SET_START_OF_TEXT_FONT
; EXTERN SET_SYSTEM_MARK
; EXTERN SET_SYSTEM_MARK_DIRECT
; EXTERN SET_SYSTEM_MARK_M1_DIRECT
; EXTERN SET_UNSET_BOLD
; EXTERN SET_VMARGINS
; EXTERN SCREEN_CODE_TO_WIDTH
; EXTERN SHIFT
; EXTERN SHOW_CURRENT_LINE
; EXTERN SPKEYS
; EXTERN START_BLOCK
; EXTERN START_BLK_1ST_LINE_CHAR
; EXTERN STARTLINE
; EXTERN START_OF_TEXT
; EXTERN STATUS
; EXTERN SWPBLK
; EXTERN TABPOS
; EXTERN TAB_TABLE
; EXTERN TAB_LINE_LEN
; EXTERN TELL_DOCUMENT_ALTERED
; EXTERN TEXCF0
; EXTERN TEXCFE
; EXTERN TEXT_MINUS_A
; EXTERN TEXT_MODE_STRING
; EXTERN TEXT_PLS_CURCAR_INTO_AX
; EXTERN TEXT_PLS_RETSPCEOT
; EXTERN TEXT_TO_PREV_LINE
; EXTERN TEXT_TO_NEXTLINE
; EXTERN TPRINT_FILE
; EXTERN D_TOTAL_VERTICAL_PIXELS
; EXTERN UPDATE_ATTRIBUTES_CR
; EXTERN UPDATE_ATTRIBUTES_CL
; EXTERN USER_DEFINED_LEAD
; EXTERN VIC_SCREEN_ON
; EXTERN WHICH_MACRO
; EXTERN WRAP_LINE
; EXTERN W_INTO_AX
; EXTERN W_INTO_PT
; EXTERN ZERO_INTO_CUR_PAGE_LENGTH
