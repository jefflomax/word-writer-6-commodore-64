;  
 PW 94 
;
 TITLE THESAURUS REX
;
;BE SURE CLSNUM IS ZERO  
;CALL ROUTINE WITH APPROPRIATE POINTER TO WORD
;IF (CS) THEN THE WORD WAS NOT FOUND  
;IF (CC) THEN  
;   PROGRAM WILL RETURN WITH WORD IN WORD BUFFER .X = CLUSTER NUMBER
;   
;MAKE REPEATED CALLS UNTIL (CS) INDICATING LAST WORD XMITTED.       
;WATCH .X CAREFULLY FOR CLUSTER NUMBER CHANGES 
;  DURING CALLS, NEVER HARM:               
;      MAXWOR   LINDEX   DEVICE   NUMLET 
;      TEMPOR+1 LEN
;
;NEEDS:
;* CHECK ERROR FLAG (CS) AFTER ALL INBITS/INLETT      
;* CHECK IF DISKETTE IS T-DISK, AFTER OPENS    
;* COMPRESS WORD LENGTH S/B 1 LESS
;  
;
; THESAURUS EQUATES/VARIABLES 
;
CSIZE  EQU 12 ;NUMBER OF BITS IN A CLUSTER NUMBER             
WPLEN  EQU 17 ;NUMBER OF BITS IN A POINTER TO CLUSTER        
BC     EQU 17 ;LARGEST POSSIBLE CLUSTER SIZE
;
;VARIABLES
;
WORD   EQU $30 ;POINTER TO WORD TO LOOK UP
P1     EQU $32
P2     EQU $34
P3     EQU $36
P4     EQU $38
T1     EQU $3A ;TEMPOROARY USED FNDLT1,INBITS,
NUMLET EQU $3B ;LENGTH OF WORD, NUMBER OF CLUSTERS
DEVICE EQU $3C ;DEVICE NUMBER TO USE FOR THSDATA
LEN    EQU $3D ;
SO     EQU $3E ;{ SECTOR OFFSET
PO     EQU $40 ;} POSITION IN SECTOR  
TRACK  EQU $41 ;ACTUAL TRACK OF DRIVE
SECTOR EQU $42 ;ACTUAL SECTOR OF DRIVE
MAXWOR EQU $43 ;NUMBER OF WORDS/CLUSTER THIS REGION        
MP1    EQU $44 ;THREE BYTE VALUE FOR MATH #1 (2 SIG)
;
MP2    EQU $47 ;ONE BYTE POINTER FOR MATH #2   
;
;FREE  EQU $48 ;
LINDEX EQU $49 ;POINTS TO NEXT LETTER'S SO,PO IN LETTER
;
TEMPOR EQU $4A ;THREE BYTE TEMPORARY FOR MATH     
BIIIT  EQU $4D ;BIT OFFSET IN SECTOR    
T2     EQU $4F ;TEMPORARY USED INBITS,
RESULT EQU $51 ;MORE THREE BYTE MATH STUFF
WSO    EQU $54 ;{ SO OF CURRENT WORD POINTING TO
WPO    EQU $56 ;} PO OF CURRENT WORD POINTING TO                       
T3     EQU $57 ;TEMPORARY USED SENDASC,
T4     EQU $58 ;TEMPORARY USED SENDASC,  
T5     EQU $59 ;TEMPORARY USED SENDASC,
;
;SYSTEM EQUATES/VARIABLES       
;
CHKIN  EQU $FFC6
CHKOUT EQU $FFC9
GETIN  EQU $FFE4
CHROUT EQU $FFD2
CLALL  EQU $FFE7
CLOSE  EQU $FFC3
CLRCHN EQU $FFCC 
OPEN   EQU $FFC0
PRIMM  EQU $FF7D
SETLFS EQU $FFBA
SETNAM EQU $FFBD 
STATUS EQU $90
;
VIDEO  EQU $400  
VIDEO1 EQU VIDEO+40  
VIDEO2 EQU VIDEO1+40   
VIDEO3 EQU VIDEO2+40
VIDEO4 EQU VIDEO3+40     
VIDEO5 EQU VIDEO4+40
VIDEO6 EQU VIDEO5+40
VIDEO7 EQU VIDEO6+40
;
 PAGE
 CODE
 ORG $2000
;
XWORD:
 DB 'FAMOUS',0
EWORD:
;
 DS $2100-$    
;
;EXAMPLE CALL MODULE
;
 LDX #0
 STX $1300
GETWW: 
 JSR GETIN
 BEQ GETWW
 LDX $1300
 STA XWORD,X
 CMP #$5F
 BEQ FFF   
 JSR CHROUT
 INC $1300
 JMP GETWW
FFF:
 LDA #0
 STA XWORD,X
;
 LDA #0
 STA CLSNUM ;START OFF ON 1ST CLUSTER
;
NWD:
 JSR START
 BCS DONE  
 STX VIDEO1-1
 LDA TRACK
 STA VIDEO1
 LDA SECTOR
 STA VIDEO1+1
 LDX #9
FDYY:
 JSR DELAY
 DEX
 BPL FDYY
;
;DEBUG
 LDA #'-' 
 LDY #$10  
FDXX:
 STA $400,Y
 DEY
 BPL FDXX
 LDA #0
 STA WNDX ;CLEAR POINTER     
;
 JMP NWD
DONE:
 JSR CLEARF
 RTS ;RETURN TO BASIC
;
;
START:
 LDA #00
 STA $FF00
;
 LDA #14    
 JSR CHROUT
 LDA #0   
 STA WORD
 JSR FLUSH ;CLEAR BITBIN
 LDA #$07
 STA $D506 ;PUT FILENAMES IN COMMON RAM 
 LDA #$04
 STA WORD+1   
;
; GO OFF TO PRESENT WORD IF ALREADY IN LOOKUP MODE   
 LDA CLSNUM
 BEQ LOOKUP ;LOOK UP THE WORD OR     
 JMP PRESENT ;PRESENT WORDS   
;
LOOKUP: 
 LDY #0
DRAWTW:
 LDA XWORD,Y
 STA (WORD),Y      
 BEQ DRAWT1  
 INY
 BNE DRAWTW
DRAWT1:      
 STY LEN   
;
;
 JSR WSTARTT ;SET START OF TRACK FOR WORD FILE
;
 LDA #$8
 STA DEVICE ;SET DEVICE NUMBER BEFORE CALLING
;
 LDY LEN
SMALLIT:
 LDA (WORD),Y ;PUT DOWN IN CASE
 AND #191     ;DOWN SHE GOES
 STA (WORD),Y ;AND STORE IT
 DEY 
 BPL SMALLIT
;         
 JSR CLALL    
 LDA #$F              
 LDX DEVICE
 TAY
 JSR SETLFS
 LDA #2
 LDX #<IODRIVE
 LDY #>IODRIVE
 JSR SETNAM
 JSR OPEN ; OPEN 15,8,15,"I0"
;
 LDA #2
 LDX DEVICE
 TAY
 JSR SETLFS
 LDA #1
 LDX #<CHANNEL
 LDY #>CHANNEL
 JSR SETNAM
 JSR OPEN ;OPEN 2,8,2,"#"   
;
 LDY #0
 LDA (WORD),Y ;RETRIEVE FIRST CHARACTER 1..26 (ASSUME "PERFECT" WORD)       
 SEC
 SBC #1 ;IF 1..26 -> 0..25              
 STA T1  
 ASL A ;.A * 2
 ADC T1
;
 TAX ;X CONTAINS INDEX TO LETTER TABLE (SO,PO)   
;
;LOOK UP EITHER BY 1ST LETTER IF ?..?N OR FROM ?O..?Z 
;
 INY ;[1]
 LDA (WORD),Y
 BNE SECNDOK
 JMP WNF ;IF SECOND LETTER IS END, WE QUIT!   
SECNDOK:
 CMP #'O'-64 
 BCC USEFRS ;USE FIRST LETTER, ?A..?N          
;THIS IS ?O..?Z WE WILL USE LETTEO TABLE      
 LDA LETTEO,X 
 STA SO
 INX 
;
 LDA LETTEO,X
 STA SO+1
 INX 
;
 LDA LETTEO,X ;LOCATE SO, PO AT START OF LETTER       
 STA PO
 JMP USEDSEC
;
USEFRS:
;USE ?A..?N TO FIND WORD (LETTER)
 LDA LETTER,X 
 STA SO
 INX 
;
 LDA LETTER,X
 STA SO+1
 INX 
;
 LDA LETTER,X ;LOCATE SO, PO AT START OF LETTER       
 STA PO
;
USEDSEC:
 INX
 STX LINDEX
;
 JSR READSEC ;USE U1 TO READ SECTOR 
 JSR POSITON ;SET BUFFER POINTER FOR WORD
;          
SEARCHW:
 LDA SO
 STA WSO 
 LDA SO+1
 STA WSO+1
 LDA PO
 STA WPO ;HOLD POSITION OF CURRENT WORD
;
 LDX LINDEX ;GET LETTER INDEX
 LDA SO   
 CMP LETTER,X 
 BNE SEARCH1 ;OK, DO SEARCH  
 LDA SO+1
 CMP LETTER+1,X 
 BNE SEARCH1 ;SO'S DIFFERENT, DO SEARCH   
 LDA PO ;CHECK PO
 CMP LETTER+2,X ;DIFFERENT?
 BNE SEARCH1 ;YES, GO DO SEARCH!
;
;DEBUG
 LDA #$C1   
 JMP TEXIT
;
;BEQ WNF ;NO! THE WORD IS NOT FOUND 
;
;DEBUG
SEARCH1:
 LDX #$7
 LDA #' '   
XX:  
 STA VIDEO1+5,X 
 DEX
 BPL XX
;
 LDA #4 ;SIZE OF [WORDLEN]
 JSR INBITS ;READ 4 BITS FROM INPUT CHANNEL
 TAX
; .X = NUMBER OF CHARACTERS -1 IN WORD
; 0 = 1 CHAR, WITH 1ST LETTER OMITTED, TOTALS 2.   
; INX ;0=1 TO READ
; S/B COMPRESSED FOR 1 LESS ON LENGTH
;
 STX NUMLET ;NUMBER OF LETTERS
 LDY #1 ;SET UP TO 2ND CHAR AND THRU WORD    
;
NXTCHR:
;DEBUG
 DB 234,234,234
; JSR DELAY 
;
 JSR INLETT ;READ 2ND LETTER
;
 STA VIDEO1+5,Y
;
; HANDLE DOUBLETS/SPACE/QU    
;
 BNE NXTCHR1 ;IF THIS IS ZERO, SUBSTITUTE
 LDA #' ' ;A SPACE AND CHECK
 CMP (WORD),Y
 BEQ SAMECR
 BNE WLESS
;
NXTCHR1: 
 CMP #'Q'-64 ;IS THE Q (QU)?
 BNE NXTCHR2
;
 LDA #5 ;QU FLAG  
 BNE NXTCHR3 ;TREAT AS DOUBLET     
;
NXTCHR2:
 CMP #27 ;IS THIS 1..26
 BCC NXTCHR4 ;TREAT AS NORMAL LETTER
 SBC #27 ;MAKE # 0..4 FOR DOUBLETS  
NXTCHR3: 
 JMP TLETVER ;VERIFY APPROPRIATE TWO LETTER 
;
NXTCHR4:
;DEBUG
 STA $1FFE
 PHA
 LDA (WORD),Y
 STA $1FFF
 PLA
;
 CMP (WORD),Y
 BEQ SAMECR
 BCC WLESS ;TARGET WORD < DISK DATA  
;TARGET WORD > DISK DATA
;
; WORD NOT FOUND             
;                        
WNF: 
 INC $D020
 LDA #2
 JMP TEXIT
;SHOULD BE JSR CLOSEAL
 SEC ;EXIT WITH CARRY SET.
 RTS
;
SAMECR:
 DEC NUMLET
 LDA NUMLET
 BEQ DSKOUT ;THE DISK IS OUT OF CHARACTERS             
 INY        ;MOVE TO NEXT MEMORY CHAR
 LDA (WORD),Y
 BEQ MEMOUT ;THE MEMORY IS OUT OF CHARACTERS
 BNE NXTCHR ;GO TRY THE NEXT CHARACTER
; RE-ORDER BRANCH    
MEMOUT:
; THE MEMORY IS OUT OF CHARACTERS, THE DISK IS NOT.
; THIS MEANS THE WORDS DO NOT MATCH HERE.  WE CAN ASK
; THE USER IF THIS WORD IS OK, OR WE CAN TRY SOME SUFFIX
; ANALYSIS/DELETION.
; 
 LDA #3
 JMP TEXIT 
 JMP WNF ;FOR NOW, WORD NOT FOUND 
;
DSKOUT:
; THE DISK DRIVE HAS RUN OUT OF CHARACTERS IN THIS WORD.
; IS THE MEMORY ALSO OUT?
 INY
 LDA (WORD),Y
 BNE MEMCHR ;NO THE MEMORY STILL HAS CHARACTERS.
;
; THE DISK AND THE MEMORY ARE BOTH OUT OF CHARACTERS
; WE HAVE A WINNER!!!
;
 JMP EVALCL ;WORD IS FOUND!!!
;
MEMCHR:
; THE DRIVE IS OUT OF WORD AND THE MEMORY IS NOT
; GO TO NEXT WORD.
 JMP NXTWORD                
;
WLESS:
; THE TARGET WORD IS GREATER THAN THE DISK WORD
; GO TO THE NEXT WORD.
 JMP NXTWORD
;      
NXTWORD:
;
NXTWORD1:
;MAY EMPLOY FAST NEXT WORD ROUTINE TO ALLOW FOR BYTE
;READ (AFTER CURRENT BIT-BUFFER IS DEPLETED)            
;FOR NOW, SIMPLE INBITS.
;
 DEC NUMLET 
 LDA NUMLET
 BMI NXTW2 ;JUST BE SAFE, DO NOT PULL MILLIONS       
 BEQ NXTW2 ;THERE ARE NO MORE DISK LETTERS
;DEBUG   
 LDA #0   
 STA DEB1 ;VARIABLE FOR DEBUG ONLY  
 BEQ NXTW1
DEB1 DB 0      
NXTW1:  
;
 JSR INLETT ;READ A LETTER
;
;DEBUG
 LDX DEB1 ;MORE DEBUG    
 INC DEB1
 STA VIDEO5+7,X
;
 DEC NUMLET         
 BNE NXTW1    
;
NXTW2:
 LDA #4
 JSR INBITS
 STA VIDEO5
;
 STA NUMLET ;NUMBER OF CLUSTERS.
 INC NUMLET ;0..15 -> 1..16
NXTW3:
 LDA #CSIZE  
 JSR INBITS
 DEC NUMLET
 BNE NXTW3  
;        
 LDA BIIT ;THESE ARE EXACTLY THE        
 BEQ NXTW4         
;NUMBER OF BITS IN THE BUFFER.  
 JSR INBITS
NXTW4:
;
;IT WOULD BE FASTER HERE TO SIMPLY ZERO
;BIIT AND CALL THE APPROPRIATE ROUTINES TO 
;BUMP UP PO    
;   
 JMP SEARCHW ;GO LOOK AT THE NEXT WORD THEN
;
CPFIL1:
 LDA #4
 JMP TEXIT
;
EVALCL:
;WORD FOUND, FILL TABLE OF CLUSTER POINTERS                         
;DEBUG 
 LDX #$5
WEWON:
 JSR DELAY
 INC $D020
 DEX
 BNE WEWON
;
;EVALUATE THE CLUSTER INFORMATION  
;
;
 LDA #4
 JSR INBITS ;RETRIEVE # OF CLUSTERS
;
 TAX
 INX ;0..15 -> 1..16 (MIN 1 S/B 2..17)                       
 STX NUMLET ;NUMLET = NUMBER OF CLUSTERS
 STX LEN ;SAVE #CLUSTERS IN PO
;
 LDA #0 ;CLEAR TEMPOR FOR
 STA TEMPOR ;INDEX TO POINTER TABLE    
;
CPFILL:
 LDA #CSIZE ;SIZE IS 13 (S/B 12) BITS    
 JSR INBITS
 BCS CPFIL1 ;ERROR ON READ
;
 LDX TEMPOR           
 STA CDATA,X
 STA VIDEO3,X
 LDA RETRNA+1
 INX
 STA CDATA,X
 STA VIDEO3,X
 INX
 STX TEMPOR 
; 
 DEC LEN ;LEN = NUMLET DEC TO FILL TABLE
 BNE CPFILL ;FILL UP CDATA TABLE     
;
;LDA #$33
;JMP TEXIT
;
;
;BEGIN LOOP TO:
;1) CALCULATE POINTER POSITIONS      
;2) FILL POINTER TABLES AND
;3) PRESENT WORDS
;   (NUMLET COUNTS DOWN) 
;
 LDA #0 
 STA LEN ;SET INDEX TO START OF CDATA TABLE
;
 LDA #'-' 
 LDY #$10                    
GDXX:
 STA $400,Y
 DEY
 BPL GDXX
;
MAINCL: 
;MAIN CLUSTER/WORD PRESENTATION LOOP
;
 LDX CLSNUM
 CPX NUMLET
;BEQ MAINCL1       
 BCC MAINCL1 ;NOT DONE
;[CS]     
 LDX #0
 RTS ;ALL DONE !!!!
;
;
MAINCL1:
 LDX LEN  
 LDA CDATA,X 
 STA P1    
 STA VIDEO7
 INX
 LDA CDATA,X
 STA P1+1
 STA VIDEO7+1
 INX
 STX LEN ;WHICH CLUSTER # TO LOOP ON             
;
 INC CLSNUM ;CLUSTER # [1..N] BEING PRESENTED                             
;
 JSR FINDLOC ;RETURN SEEK CLUSTER, MAXWOR = #CHARS
;
;
 LDX #0 
 STX TEMPOR ;BUMP UP BY TWO'S THRU SO TABLE
;
WPFILL:
;FILL UP SO,PO TABLES OF WORDS FOR THIS CLUSTER     
 LDA #9
 JSR INBITS ;.X IS SAFE THRU
 LDY TEMPOR  
 STA PSODATA,Y ;SO OF XTH WORD      
 INY
 LDA RETRNA+1
 STA PSODATA,Y ;SO (HI) OF XTH WORD
 INY
 STY TEMPOR ;SET TO NEXT POSITION
;
 LDA #8
 JSR INBITS
;
 STA PPODATA,X ;PO OF XTH WORD
 INX ;0..(MAXWOR-1)
 CPX MAXWOR
 BCC WPFILL ;FILL WORD POINTER TABLE
;
;SEND 1ST WORD TO WORD,Y
;
 LDY #0   
 STY TEMPOR ;INIT 1ST PASS   
;
PRESENT: 
;WORD-LOOP FROM JUMP
;
 LDA TEMPOR
 PHA
 TAX
 LDA PSODATA,X
 STA SO 
 INX                                          
 LDA PSODATA,X 
 STA SO+1
 INX
 STX TEMPOR
 PLA
 LSR A ;INDEX FOR OTHER TABLE  
 TAX
 LDA PPODATA,X
 STA PO ;GET WORD POSITION F/TABLE  
;
;
 CPX MAXWOR       
;BEQ WPFILE0
 BCC WPFILE0
;
 JMP MAINCL ;PRESENT THE REST OF THE CLUSTERS             
;
;
;SET SO, PO
WPFILE0:
;
 JSR FND1LT ;WHAT IS 1ST LETTER?
 JSR PUTCHAR ;PLACE CHAR IN WORD BUFFER
;        
 JSR FLUSH ;CLEAN OUT BITBIN FOR NEXT READ
;
 JSR WSTARTT ;SET TRACK, SECTOR ON START OF WORD FILE
;
 JSR READSEC ;READ SECTOR SO TO FIND WORD
;
 JSR POSITON ;POSITION AT WORD (LENGTH,FIELD...)
;
 LDA #4
 JSR INBITS
 STA TEMPOR+1 ;TEMPOR+1 IS LENGTH    
; 
WPFILE1:
 JSR INLETT ;GET A LETTER FROM DISK
 BNE WPFILE2 ;            
 LDA #' ' ;WE HAVE A SPACE! 
 BNE WPFILE4 ;DO NOT FALL THRU, WILL BE "DOUBLET"  
;
WPFILE2: 
 CMP #'Q'-64 ;IS THIS Q CODE?  
 BNE WPFILE3
 JSR PUTCHAR ;PUT OUT THE Q
 LDA #'U'-64
;
WPFILE3:
 CMP #27   
 BCC WPFILE4 ;NORMAL LETTER 
 SBC #27 
 ASL A ;MAKE INDEX TO DOUBLET TABLE
 TAX        
 LDA DOUBLETS,X
 JSR PUTCHAR 
 LDA DOUBLETS+1,X
;
WPFILE4: 
 JSR PUTCHAR
;
 DEC TEMPOR+1
 BNE WPFILE1
;
 LDX CLSNUM
 CLC
 RTS
;
;
FINDLOC: 
;GIVEN CLUSTER NUMBER 0..8192 RETURN SO, PO, BIT           
; CREATE #POINTERS DISTANCE INTO FILE IN MP1
; MULTIPLY BY WPLEN FOR NUMBER OF BITS IN FILE 
; #BITS / 2048 = SECTOR OFFSET
; #BITS - (SO * 2048) = BITSINSECTOR
; BITSINSECTOR / 8 = POSITION
; BITSINSECTOR AND 111 = BIT OFFSET 
; MAXWOR = # WORDS IN CLUSTER   
;
;INDEX :     CTOTALS   CNUMPTRS  
; 16   :        0         00
; 15   :        X        16*NC
; 14   :       X+Y    16*NC+15*NC
; ...  :       ...        ...
;  1   :        N         
;
;ASSUME P1 = CLUSTER NUMBER
; 
 LDA #BC ;SILLY SPECIAL CASE FOR 1 17 ENTRY CLUSTER
 STA MAXWOR
;
 JSR CLRMP1 ;MP1 = 000
;
 LDA P1
 ORA P1+1
 CMP #0
 BEQ ABSSTR ;ABSOLUTE BEGINNING,         
;
 LDX #BC+2 ;MAXIMUM WORDS/CLUSTER (BC) S/B LARGER 3..N
 STX MAXWOR ;COUNT DOWN
 LDX #$FE ;-2
FLOOP: 
 INX
 INX ;0..2..4..6..
 DEC MAXWOR ;18..1 
;
 LDA P1+1
 CMP CTOTALS+1,X
 BEQ FLOO1 ;TEST LO BYTES
 BCS FLOOP ;P1 > #TOTALS ENTRY, NEXT REGION!
 BCC FIRSTR ;P1 < #TOTALS, THIS REGION!  
;
FLOO1:
 LDA P1
 CMP CTOTALS,X
 BEQ FLOFIR ;1ST CLUSTER IN REGION, FORCE ZERO                      
;THEN WE ARE DONE
 BCS FLOOP ;P1 > #TOTALS ENTRY, TRY NEXT REGION
 BCC FIRSTR ;IN PREVIOUS REGION
;
;IF THIS WERE 1ST ELEMENT OF 1ST REGION, PROCESS SEPERATELY                                                   
FLOFIR:
;ONLY FOR 1ST ELEMENT IN A REGION 
 DEC MAXWOR ;ONE MORE DOWN BECAUSE ON SAME REGION,NOT PAST
 JMP MP1ISF ;AND COMPUTE
;
FIRSTR:
;
;ADJUST .X (2..4..6..8) TO POINT TO PREVIOUS
;REGION.  NOTE THAT 0 IS NOT POSSIBLE DUE TO PREVIOUS
;CHECK FOR P1=0, AND ANY OTHER NUMBER IS OBVIOUSLY 
;GREATER.
 DEX
 DEX
 STX VIDEO6+2 
;
;CALCULATE NUMBER OF POINTERS THIS REGION
;ACTUAL CLUSTER NUMBER(P1) - TOTAL ENTRIES TO HERE CTOTALS             
 SEC 
 LDA P1
 SBC CTOTALS,X 
 STA MP1
 LDA P1+1
 SBC CTOTALS+1,X
 STA MP1+1 ;MP1 = NUMBER OF ENTRIES FROM START OF REGION
;
 LDA MP1
 ORA MP1+1
 CMP #0
 BNE MP1ISF ;(DEBUG) MP1 IS NEVER TO BE ZERO!     
 LDA #$8  
 JMP TEXIT ;EXIT FLAGGING MP1=1    
;
MP1ISF:
;JSR DEC1MP1 ;MP1 = MP1-1 (COUNT TOTALS FROM 0) NO,CLUSTERS
;COUNT FROM 0..N
;
 LDA MAXWOR
 STA MP2
 JSR MP1XMP2 ;MP1 = MP1 * MP2 (16*8)-> (24)
;
;MP1 NOW HOLDS NUMBER OF POINTERS FROM START OF REGION
;
;NOW ADD NUMPTRS TOTAL FROM PREVIOUS REGIONS                
 CLC
 LDA CNUMPTRS,X
 ADC MP1
 STA MP1
 LDA CNUMPTRS+1,X    
 ADC MP1+1
 STA MP1+1
 LDA CNUMPTRS+2,X
 ADC MP1+2
 STA MP1+2
;
;NOW MP1 CONTAINS TOTAL NUMBER OF POINTERS FROM START OF FILE
;     
 LDA #WPLEN      
 STA MP2 ;MP2 = # BITS IN EACH POINTER
;
 JSR MP1XMP2 ;MP1 = MP1 * MP2
;MP1 NOW HOLDS TOTAL NUMBER OF BITS FROM START OF FILE      
;
ABSSTR:
;GOOD PLACE FOR ABSOLUTE START (1ST WORD) ENTRY
;
 JSR MP1TTMP ;MOVE MP1 TO TEMPOR      
;
 LDA #11
 JSR MP1ROL ; MP1 = MP1 / 2048 BY SHIFTING
 LDA MP1 ;S/B UNNECCESSARY  
 STA SO ;HERE IS THE BLOODY SECTOR OFFSET!
 LDA #0  
 STA SO+1 ;ASSUME POINTER FILE < 256 SECTORS 
;
 LDA #11  
 JSR MP1ASL ;MP1 = MP1 * 2048 BY SHIFTING   
; NOW MP1 CONTAINS NUMBER BITS IN ALL SECTORS UP TO ACTUAL
; SUBTRACT THIS FROM TEMPOR TO CREATE BITS IN SECTOR
 SEC
 LDA TEMPOR
 SBC MP1
 STA MP1
 AND #$7 ;CHECK THIS   
 STA BIIIT ;TO CREATE ACTUAL BIT POSITION
 LDA TEMPOR+1
 SBC MP1+1
 STA MP1+1
 LDA #0
 STA MP1+2 ;MP1 = BITS IN SECTOR
;
 LDA #3
 JSR MP1ROL ;MP1 = MP1 / 8 BY SHIFTING
 LDA MP1
 STA PO ;POSITION IN SECTOR
 STA VIDEO6+8
;
; CONVERT SO,PO,BIIT INTO TRACK,SECTOR,POS   
 LDA #0
 STA SO   
 STA SO+1
 STA PO
 STA BIIIT
 INC DEBUG
;DEBUG 
;
 JSR FLUSH ;CLEAR OUT BITBIN FOR FRESH DATA        
;
 JSR PSTARTT ;SET TRACK, SECTOR START FOR PFILE  
;
 JSR READSEC ;READ SECTOR WITH SO OF CLUSTER INFORMATION    
;
 LDA PO
 STA $1300
;
 JSR POSITON ;SET POINTER TO BYTE CONTAINING POINTER
;
 LDA BIIIT
 BEQ FIRST1 
 JSR INBITS ;STRIP AWAY THE "GARBAGE" BITS
;
FIRST1:
;DEC MAXWOR ;MAKE MAXWOR 1..N NUMBER OF WORDS 
 RTS ;NOW POSITIONED AT POINTER
;   
;
TLETVER:
;VERIFY A TWO LETTER COMBINATION.
;.A IS NUMBER 1..N (WILL BE ZERO..N)
;
;DEC NUMLET ;!!!!! REMOVE THIS !!!!! AS SOON AS COMPRESSOR
;KNOWS ENOUGH TO COUNT DOUBLED CHARACTERS ONCE!         
;
 STA VIDEO4
 ASL A ;A = A * 2          
 TAX 
 STA VIDEO4+1
;
 LDA (WORD),Y  
 STA VIDEO4+2 ;DEBUG ONLY
;   
 LDA DOUBLETS,X
 STA VIDEO4+3
 CMP (WORD),Y     
 BNE DOUBAD
;
 INY
 LDA (WORD),Y 
 BNE TLETVE1
 JMP MEMOUT ;MEMORY IS OUT OF CHARACTERS...
;
TLETVE1:
 LDA (WORD),Y  
 STA VIDEO3+3 ;DEBUG ONLY! 
;
 LDA DOUBLETS+1,X ;TEST AGAINST SECOND LETTER OF DOUBLET
 STA VIDEO3+4         
 CMP (WORD),Y
;  
 BEQ DSC ;THIS DOUBLET IS OK 
DOUBAD:     
 BCC DWLESS ;TARGET WORD < DISK DATA   
 BCS DWNF   ;TARGET WORD > DISK DATA 
;
DSC:
 JMP SAMECR ;DOUBLET VERIFIED
DWNF:
;DEBUG 
 LDA #$C1
 JMP TEXIT
 JMP WNF
DWLESS:
 JMP WLESS    
;
;
INTRKSEC:
; ADD 1 TO SECTOR, IF RANGE OVERFLOWED, THEN ADD 1 TO TRACK
; USES A,Y 
; UNHARMED .X     
 INC SECTOR 
 LDA SECTOR
 CMP #12 ;AT LEAST 12 SECTORS ON ANY TRACK    
 BCC SECOK
;
;SECTORS/TRACK = 20 + 2* (T>17) + (T>24) + (T>30)   
;
 LDA TRACK
 LDY #20  
 CMP #18 ; IF X > 17 THEN DEY,DEY        
 BCC TCHK1 ;T = 0..17
 DEY
 DEY
TCHK1:
 CMP #25
 BCC TCHK2 ;T = 0..24
 DEY
TCHK2:  
 CMP #31
 BCC TCHK3 ; T = 0..34 
 DEY
TCHK3:
 CPY SECTOR ;.Y = NUMBER SECTORS THIS REGION 0..N
 BEQ SECOK
 BCS SECOK
 INC TRACK
;
 LDA TRACK
 CMP #18 ;DOS STUFF?
 BNE TCHK4 ;NO, REGULAR START
 LDA #2      
 DB $2C
TCHK4:
 LDA #0
 STA SECTOR
SECOK:
 RTS
;
; INC SECTOR
; LDX SECTOR
; LDA SECTAB,X 
; CMP SECTOR 
;THIS METHOD PLUS A TABLE COULD VORK FASTER
;
TERROR:
;DEBUG
 LDA #$1E 
 JMP TEXIT ;WE HAVE A TRACK ERROR 
;
INCPOS:
;WATCH FOR END OF BUFFER, ADVANCE TO NEXT TRACK,
;SECTOR IF SO.  INCREMENT SO FOR FINAL WORD (TO
;AVOID) LOCATION.
 INC PO 
 BNE INCPOS1 ;WE ARE NOT OUT OF BYTES YET
;            
 STA $453
;
 JSR INTRKSEC ;BUMP UP NEXT TRACK/SECTOR
 LDA #0 ;CLEAR NEW PO
 STA PO
 JSR INCWSO ;SO = SO + 1
;
 JMP RSECTOR ;READ SECTOR FROM EXISTING TRACK, SECTOR
INCPOS1:
 RTS
;
READSEC:
;BE SURE TRACK AND SECTOR ARE SET TO ABSOLUTE
;"START OF FILE" BEFORE CALLING
 LDA SO 
 STA P1 
 LDA SO+1
 STA P1+1 ;MOVE SO(SECTOR OFFSET) TO P1
;
FUCK:
 LDA P1+1
 ORA P1
 CMP #0
 BEQ RSECTOR ;IF AT START, THEN SKIP BUMP ROUTINE
;
BUMPFD:   
 JSR INTRKSEC ;INCREMENT SECTOR AND TRACK BY 1
 JSR DECWP1
 JMP FUCK
; BNE BUMPFD
;
;READ FROM EXISTING TRACK, SECTOR    
;
RSECTOR:
;UNHARMED .X
 TXA      
 PHA
 JSR CLRCHN
 LDX #$F
 JSR CHKOUT
;
 LDX #UMSGE-UMSG-1
SENDU1:
 LDA UMSG,X
 JSR CHROUT
 DEX 
 BPL SENDU1 ;'U1:2 0 '
;         
 LDA #'T'  
 STA $438
 LDA TRACK
 STA $439
 JSR SENDASC 
 LDA #' '
 JSR CHROUT
 LDA #'S'
 STA $43A
 LDA SECTOR
 STA $43B
 JSR SENDASC
 JSR CLRCHN
 LDX #$2
 JSR CHKIN ;CHANNEL 2 IS INPUT  
 PLA
 TAX
HRTS:
 RTS
;
POSITON: 
;
 LDA PO
 BEQ HRTS 
;DEBUG WATCH OUT FOR THIS SHIT!!!    
 JSR CLRCHN ;CLEAR CHANNEL 2 
 LDX #$0F
 JSR CHKOUT
;
 LDX #PMSGE-PMSG-1
POSITO1:
 LDA PMSG,X ;'B-P:2,'
 JSR CHROUT
 DEX
 BPL POSITO1
 LDA #'P'
 STA $43C
;
 LDA PO
 STA $43D
 JSR SENDASC
;
;JSR CRLF
 JSR CLRCHN ;CLOSE CHANNEL 15
 LDX #$2
 JMP CHKIN
;   
INCWSO:
 INC SO
 BNE INCWSO1
 INC SO+1
INCWSO1:
 RTS
; 
CLRMP1:
 LDA #0
 STA MP1
 STA MP1+1
 STA MP1+2
 RTS
;
CRLF:
 LDA #$D
 JMP CHROUT
;
SENDASC:
;SEND .AC IN ASCII (0..255) TO CHROUT
; UNHARMED .X 
; WILL SEND MINIMUM (0, NOT 000) TO DISK   
 STX T4 ;SAVE .X    
;
 LDX #'0' 
 LDY #'0'
SEHUND:
 CMP #100
 BCC SETENS 
 SBC #100
 INX ;ONE HUNDRED
 BNE SEHUND ;ANOTHER HUNDRED?                 
SETENS:
 CMP #10
 BCC ONES
 SBC #10
 INY
 BNE SETENS
ONES:
 ADC #'0'
 STA T3
 CPX #'0' ;IS HUNDREDS PLACE 0? 
 BEQ LODID ;IF SO, DO NOT SEND, CHECK 10'S
;
 TXA ;.A = HUNDREDS PLACE  
 STY T5 ;IN CASE CHROUT SHOULD HARM .Y
 JSR CHROUT ;HUNDREDS PLACE
 LDA T5 ;A = Y (ALWAYS SEND TENS HERE)
 BNE LODID1 ;BRA
;
LODID:
 CPY #'0' ;IS TENS PLACE 0?
 BEQ LODID2 ;IF SO, SKIP & SEND ONES   
;
 TYA ;TENS IS NOT ZERO, SEND   
LODID1:
 JSR CHROUT ;TENS PLACE 
LODID2:
 LDA T3
 JSR CHROUT ;ONES PLACE
 LDX T4 ;RESTORE X 
 RTS
;                    
MP1XMP2:
;16 * 8 MULTIPLY WITH 24 BIT RESULT
;USES AC,RESULT,MP1,MP2
;UNHARMED .X,.Y
;
 TXA
 PHA ;SAVE .X
 LDX #8 ;NUMBER OF BITS TO SHIFT THRU
 LDA #0
 STA RESULT
 STA RESULT+1
;
MSHIFT:
 ASL RESULT
 ROL RESULT+1
 ROL RESULT+2 ;PRODUCT = 2 * PRODUCT
;
 ASL MP2 ;BYTE-MULTIPLIER * 2
 BCC MNOADD
;
 CLC
 LDA RESULT
 ADC MP1 ;MULTIPLICAND-WORD
 STA RESULT
 LDA RESULT+1
 ADC MP1+1
 STA RESULT+1
 LDA RESULT+2
 ADC #0
 STA RESULT+2
;
MNOADD:
 DEX
 BNE MSHIFT
;       
 LDA RESULT+2
 STA MP1+2
 LDA RESULT+1
 STA MP1+1
;
 PLA
 TAX ;RESTORE .X
;
 LDA RESULT
 STA MP1           
 RTS
;
MP1TTMP:
 LDA MP1
 STA TEMPOR
 LDA MP1+1
 STA TEMPOR+1
 LDA MP1+2
 STA TEMPOR+2   
 RTS ;MOVE MP1 TO TEMPORARY      
;
;MP1T:
; RTS ;MOVE TEMPORARY TO MP1
;
FND1LT:
;FIND FIRST LETTER OF WORD 
;SO, PO OF WORD ONLY INPUT
; USES X,A,T1
; UNHARMED Y 
;
 LDX #2
FND1L1:
 LDA SO,X
 CMP WSO,X    
 BNE FND1L2 ;NOT DUPLICATE OF CALLING WORD
 DEX 
 BPL FND1L1
;
 SEC
;RTS ;CS = THIS IS SAME AS CALLED WORD      
;REMOVE FOR NOW TO ALLOW ALL WORDS
;
FND1L2:
;
 LDX #0 
 STX T1 ;LETTER A..Z 
 BEQ FND1L4
;      
FND1L3:
 INX
 INX
 INX
FND1L4: 
 INC T1 ;LETTER A..Z   
;
 LDA LETTER+1,X 
 CMP SO+1
 BEQ FND1L5
 BCS FND1L7 ;LETTER > SO, LAST LETTER IS LETTER
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN. 
;
FND1L5:  
 LDA LETTER,X  
 CMP SO
 BEQ FND1L6 
 BCS FND1L7 
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN. 
;
;
FND1L6:
 LDA LETTER+2,X ;POSITION   
 CMP PO
 BEQ FND1L8 ;ON EXACT BOUNDRY,NO DEC 
 BCC FND1L3 ;LETTER < PO, BUMP UP TABLE, TRY AGAIN.  
; 
FND1L7:
 DEC T1
FND1L8:
 LDA T1
 CLC
 RTS
;
WSTARTT:
 LDA #2 
 DB $2C
PSTARTT:         
 LDA #23
 STA TRACK
 LDA #0
 STA SECTOR
 RTS
;
MP1ROL:
 STA BITROT ;# OF BITS TO SHIFT    
MP1RL1:
 LSR MP1+2
 ROR MP1+1 
 ROR MP1   
 DEC BITROT
 BNE MP1RL1 
 RTS
;
MP1ASL:
 STA BITROT ;# OF BITS TO SHIFT    
MP1AS1:
 ASL MP1
 ROL MP1+1
 ROL MP1+2
 DEC BITROT
 BNE MP1AS1
 RTS    
;
DECWP1:
 LDA P1
 BNE DECWP11
 DEC P1+1
DECWP11:
 DEC P1
 RTS
;
DEC1MP1:
 LDA MP1 ;MP1 = MP1-1 (16 BIT ONLY!!!)
 BNE DECMP11
 DEC MP1+1
DECMP11:
 DEC MP1
 RTS
;
INLETT:
;SET FOR LETTER READ AND FALL IN INBITS      
 LDA #5
;
INBITS:   
; PEEL .A BYTES FROM INPUT CHANNEL
;
; USES .A,.X,.Y,T1,T2,SO,PO,BIIT,BITBIN,BITROT  
; RETURNS .A, RETRNA  
;
STRIP:
 STA BITROT  ;NUMBER OF BITS
 LDA #0
 STA RETRNA
 STA RETRNA+1 ;CLEAR OUT RETURNED VALUE 
STRIP0:
 LDA BIIT
 BEQ STRIP2 ;NO BITS LEFT IN BIN
STRIP3:
 ASL BITBIN
 ROL RETRNA
 ROL RETRNA+1 ;SLIDE NEW BIT INTO RETURN WORD         
 DEC BIIT
 DEC BITROT
 BNE STRIP0
 JSR STRIPBUG ;DEGUBBING ONLY
 LDA RETRNA
 CLC
 RTS
;
STRIP2:
 STY T1   
 STX T2
 JSR GETIN
;DEBUG 
 PHP
 PHA
 LDA DEBUG
 BEQ DEGG
 PLA
 PHA
SMOD:
 STA $4000 
 INC SMOD+1
 BNE DEGG
 INC SMOD+2
DEGG:
 PLA
 PLP  
;
 BCS BEXIT
 STA $451
;
;HANDLE TRACK/SECTOR BUFFERING
 PHA 
 LDA PO
 STA $453
;
 JSR INCPOS ;BUMP UP POSITION AND STREAM FILE IF NEEDED
 PLA
;
POSOK:
 STA BITBIN
 LDY T1
 LDX STATUS
 BNE BEXIT ;GET OUT
 LDX T2
 LDA #8
 STA BIIT
 BNE STRIP3 ;BRA   
;
FLUSH: 
;CLEAR OUT BITBIN FOR NEW STRIP
 LDA #0
 STA BIIT
 RTS
;
BEXIT: 
;DEBUG 
 LDA #$DE ;DISK ERROR!
 JMP TEXIT
;
 SEC    
 RTS   
;
WNDX:  
 DB 0 
 DB 0
PUTCHAR:
;PUT A CHAR FROM WORD INTO BUFF
 STY WNDX+1 ;SAVE .Y
 LDY WNDX
 STA $400,Y
 INC WNDX
 LDY WNDX+1 ;RESTORE .Y 
 RTS
;
DEBUG DB 0 ;FLAG TO KEEP DISK LOG OR NOT  
STRIPBUG:
;FOR DEBUGGING PURPOSES ONLY  
 LDA DEBUG
 BEQ STRIPB2 ;DO NOT DEBUG NOW  
;
 LDA RETRNA         
 JSR STRIPB1
 LDA RETRNA+1
 JSR STRIPB1
 RTS
STRIPB1:
 STA $3000   
 INC STRIPB1+1
 BNE STRIPB2
 INC STRIPB1+2
STRIPB2:
 RTS
;      
CLSNUM: ;0 OR CLUSTER NUMBER TO PRESENT                                              
 DB 0 ;INIT TO ZERO
;
IODRIVE:
 DB 'I0'
;
UMSG:
 DB ' 0 2:1U'
UMSGE:     
;   
PMSG:
 DB ' 2:P-B'
PMSGE:  
;
CHANNEL:
 DB '#'
;
CTOTALS:
; TOTALS (BY SECTION) FOR THESAURUS 
 DW 0000,0001,0075,0132,0235,0378,0567,0787,1083,1359
 DW 1641,1934,2274,2745,3183,3341,0000     
;*NEVER* CHANGE THIS TABLE W/O REFLECTING IN CNUMPTRS!!!        
;
;
CNUMPTRS:
; TABLE OF WORDS OF TOTALS FOR NUMBER OF POINTERS/REGION (CUMULATIVE)
; *NEVER* CHANGE THIS TABLE W/O REFLECTING IN CTOTALS!!!  
V1  EQU BC*0001
V1X EQU BC*0074-01*0074 
V2  VAR V1+V1X
V2X EQU BC*0057-02*0057
V3  VAR V2+V2X
V3X EQU BC*0103-03*0103
V4  VAR V3+V3X
V4X EQU BC*0143-04*0143
V5  VAR V4+V4X
V5X EQU BC*0189-05*0189
V6  VAR V5+V5X
V6X EQU BC*0220-06*0220
V7  VAR V6+V6X
V7X EQU BC*0296-07*0296
V8  VAR V7+V7X
V8X EQU BC*0276-08*0276
V9  VAR V8+V8X
V9X EQU BC*0282-09*0282   
V10 VAR V9+V9X
V10X EQU BC*0293-10*0293
V11 VAR V10+V10X
V11X EQU BC*0340-11*0340
V12 VAR V11+V11X
V12X EQU BC*0471-12*0471
V13 VAR V12+V12X 
V13X EQU BC*0438-13*0438
V14 VAR V13+V13X
V14X EQU BC*0158-14*0158
V15 VAR V14+V14X
;
;
 DW 0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15 
;
LETTER:
;TABLE OF STARTING SO,PO FOR EACH LETTER A..Z
;A
 DW 0
 DB 0
;B
 DW 29
 DB 098
;C
 DW 48
 DB 027
;D
 DW 84
 DB 222
;E
 DW 114
 DB 146
;F
 DW 135
 DB 249
;G
 DW 157
 DB 163
;H
 DW 169
 DB 103
;I
 DW 180
 DB 220
;J
 DW 205
 DB 232
;K
 DW 208
 DB 186
;L
 DW 210
 DB 061
;M
 DW 223
 DB 244
;N
 DW 242
 DB 123
;O
 DW 248
 DB 054
;P
 DW 258
 DB 068
;Q
 DW 293
 DB 243
;R
 DW 295
 DB 161
;S
 DW 321
 DB 015
;T
 DW 364
 DB 227
;U
 DW 384
 DB 033
;V
 DW 397
 DB 211
;W
 DW 406
 DB 000
;X
 DW 416
 DB 036
;Y           
 DW 416
 DB 026
;Z
 DW 417
 DB 012
;END OF ALL (FOR USE BY SO,PO COMPARITOR)    
 DW 417
 DB 0
;
LETTEO:
;TABLE OF STARTING SO,PO FOR EACH WORD AO..ZO
;AO
 DW 18
 DB 187
;BO
 DW 40
 DB 120
;CO
 DW 60
 DB 130
;DO
 DW 109
 DB 114
;EO
 DW 125
 DB 112
;FO
 DW 148
 DB 207
;GO
 DW 163
 DB 017
;HO
 DW 176
 DB 098
;IO
 DW 104
 DB 168
;JO
 DW 206
 DB 210
;KO
 DW 210
 DB 056
;LO
 DW 219
 DB 191
;MO
 DW 236
 DB 235
;NO
 DW 245
 DB 189
;OO
 DW 252
 DB 106
;PO
 DW 273
 DB 077
;QO WATCH OUT HERE, S/B SAME AS ORIG
 DW 293
 DB 243
;RO
 DW 317
 DB 204
;SO
 DW 341
 DB 049
;TO
 DW 374
 DB 100
;UO
 DW 396
 DB 044
;VO
 DW 404
 DB 160
;WO
 DW 413
 DB 122
;XO AGAIN SAME
 DW 416
 DB 036
;YO          
 DW 416
 DB 204
;ZO
 DW 417
 DB 078
;
; DOUBLET TABLES
;
DOUBLETS:
 DB 'E'-64,'R'-64 ;ER 0
 DB 'O'-64,'N'-64 ;ON 1
 DB 'T'-64,'I'-64 ;TI 2
 DB 'A'-64,'T'-64 ;AT 3
 DB 'T'-64,'E'-64 ;TE 4
;
 DB 'Q'-64,'U'-64 ;QU 5 (SPECIAL CASE, REPLACE Q CODE)               
;
PSODATA:
;STORAGE FOR EACH CLUSTER'S ENTRIES
;SO POSITIONS 
 DW 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20   
PPODATA: 
;PO POSITIONS        
 DB 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;
CDATA:
;ACTUAL CLUSTER #'S PICKED UP TO REFERENCE    
 DW 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17     
;
;SOME VARIABLES FOR STRIP (S/B ZP)
;
RETRNA  DW 0 ;RETURN VALUE FOR STRIP (WORD)
BIIT    DB 0
BITBIN  DB 0
BITROT  DB 0
;
; TEST CODE ONLY... DELETE THIS SHIT  
UGH DW 0 
;
FTEST:
 LDA #0
 STA UGH
;
 INC DEBUG ;TURN ON DISK LOG
FUCKW: 
 LDA #16
 JSR INBITS         
 DEC UGH
 BNE FUCKW
 LDA #$DE
 JMP TEXIT 
;
DELAY:
 PHA
 STX $1300
 LDX #$80
DELAY2:
 LDA #$00
DELAY1:
 SEC
 SBC #$01
 BNE DELAY1
 DEX
 BPL DELAY2
 LDX $1300
 PLA
 RTS
;       
TEXIT:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)   
ENDPOS:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
 LDA #$2
 JSR CLOSE
 JSR $FFE7
 BRK
 BRK
 BRK  
;
CLEARF:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)   
ENDPOO:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
 LDA #$2
 JSR CLOSE
 JMP CLALL
;
 DB 0,0,0 ;SAFETY   
 END
; 