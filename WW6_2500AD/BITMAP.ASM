;
 TITLE BITMAP
 PAGE
 PW 92
;
.LIST OFF
 INCLUDE WWSETUP.ASM
 INCLUDE VARIABLS.ASM
;
 EXTERN ACTIVE_STYLE
 EXTERN AX_INTO_P1
 EXTERN BDRBAK
 EXTERN COPYDN
 EXTERN GETIN
 EXTERN INC_P1_BY_AX
 EXTERN INC_P2_BY_A         ;P2 += .A 
 EXTERN IN_ACTIVE_STYLE
 EXTERN IOINIT
 EXTERN MUL_AX_PT           ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
 EXTERN POP_EOT         ;RETRIEVE EOT
 EXTERN PUSH_EOT        ;SAVE EOT
 EXTERN PRESS_ANY_KEY_CHROUT
 EXTERN PT_INTO_AX
 EXTERN PT_INTO_P1
 EXTERN P1_INTO_P2
 EXTERN P2_INTO_AX
 EXTERN P2_INTO_P1
;
 EXTERN PETASC
 EXTERN TXCOLR
 EXTERN W_INTO_PT
 EXTERN W_INTO_P1
 EXTERN W_INTO_P2
;
 PUBLIC INITILIZE80
 PUBLIC INITILIZE40
 PUBLIC DRAWCHAR
;  
;
;THIS MODULE INITS 80 COLUMN HI-RES MODE ON A COMMODORE 64 AND
;WILL PREFORM A TEXT DISPLAY OF PETASCII CHARACTERS.
;
;PRIMITIVE CALLS: 
;
;INITILIZE80
;  SETS UP AND CLEARS THE 80 COLUMN SCREEN.  COLORS NOT PRESERVED.
;  RESIDES AS $E000
;
;INITILIZE40
;  SETS UP NORMAL SYSTEM 40 COLUMN SCREEN
;
;DRAWCHAR
;  PLACES PETASCII CHARACTER (IF VALID) AT CURSOR, INCREMENTS
;  CURSOR
;
;SETATTRIB
;  SETS ATTRIBUTE OF UNDERLINED, REVERSED, OR NORMAL
;
;
BITMAP:    EQU $E000
BITCURSOR: EQU POINTER2
;
;BITCOLUMN: DB 0   
BITCOLUMN: EQU POINTER4
MASK:      DB 0    ;MASK FOR SETTING ON SCREEN F0 0F
;T1:        DB 0    ;TEMPORARY: DRAWCR,MAKE3X8,INIT80
T1: EQU POINTER4+1
RESULT:    DB 0    ;RETURN VALUE FROM 3X8
XYTEMP     DW 0    ;SAVE X & Y IN DRAWCR
BITROW     DB 0    ;
;
.LIST ON
;
INITILIZE80:
;
 LDA #$D8
 STA POINTER1+1
 STA POINTER3+1
 LDY #$00
 STY POINTER1
 STY POINTER3
;
 LDX #5
 STX T1
;
; LDY #0
MOVECR:
;COPY SECTION OF CHARACTER SET TO $D800 FOR USE
;
 LDX #%00110011 ;ENABLE CHAR ROM
 STX $1
 LDA (POINTER1),Y
 LDX #%00111000 ;ALL RAM
 STX $1
 STA (POINTER3),Y
 DEY
 BNE MOVECR
;
 INC POINTER1+1
 INC POINTER3+1
;
 DEC T1 ;4 PAGES FROM CSET TO $D800
 BNE MOVECR
;
 LDA #0
 STA PRTFEATURE ;SET DRAWING ATTRIBUTE TO NORMAL
 STA BITCOLUMN ;HOME POSITION
 STA BITROW 
;
 JSR CLEARBM ;AND FILL BITMAP W/0 (CLEAR)
;
;.Y [$00]
 LDA TXCOLR
 ASL A
 ASL A
 ASL A
 ASL A
 ORA BDRBAK
CLEARSCRN:
 STA $DC00,Y
 STA $DD00,Y
 STA $DE00,Y
 STA $DF00,Y
 DEY
 BNE CLEARSCRN
;
 LDA #%00110111    ;RESTORE "NORMAL" CONFIG
 STA $1            ;TO SET UP VIC
;
 LDA #63
 STA 56578 ;BE SURE OUTPUTS FOR VICII BANK
;
 LDA #148
 STA 56576 ;SET TO BANK 3
;
 LDA #59
 STA 53265 ;TURN ON BITMAP MODE
;
 LDA #%01111111 ;SCREEN IN $DC00
 STA 53272 ;& BITMAP IN SECOND 8 K
;
;P2 = BITCURSOR
;
SETBC:
; LDA #<BITMAP
; STA BITCURSOR
; LDA #>BITMAP
; STA BITCURSOR+1
 JSR W_INTO_P2
 DW BITMAP
;
ALLRAM:
;
 LDX #%00111000 ;ALL RAM
 STX $1
 RTS
;
;
INITILIZE40:
;
 SEI
 LDA #%00110111 ;RESTORE "NORMAL" CONFIG
 STA $1 ;TO SET UP VIC
;
 LDA #63
 STA 56578 ;BE SURE OUTPUTS FOR VICII BANK
;
 LDA #199
 STA 56576 ;SET TO BANK 3
;
 LDA #155
 STA 53265 ;TURN ON BITMAP MODE
;
 LDA #23       
 STA 53272 ;IN SECOND 8 K
;
; JMP IOINIT
 BNE ALLRAM ;BRA RTS
;
;
CLEARBM:
;SET BITMAP TO .A
 PHA
 JSR W_INTO_P1
 DW BITMAP-64   ;MOVE VALUE TO MISS "VECTORS"
 PLA
; 
 LDY #$00
 LDX #32 ;NUMBER OF PAGES
CLEARB1:
 STA (POINTER1),Y
 DEY
 BNE CLEARB1
;
 INC POINTER1+1
 DEX
 BNE CLEARB1 ;REST PAGES
;
 RTS  
;
MAKE3X8:
;MAKE THIS CHARACTER 3X8
;DO NOT HARM .Y
;DATA IN .A
;RESULT IN RESULT
 LDX #0
 STX RESULT
 LDX HOLDSHIT ;#CMASK1
 STX T1 
 LDX #3 ;NUMBER OF BITS TO ROTATE IN
; 
MAKE3X82:
 ASL T1               ;IS THIS A BIT ROW TO KEEP?
 BCC MAKE3X83         ;NO, CC
 ASL A
 ROL RESULT           ;SET BIT IN RESULT
 DEX
 BNE MAKE3X82
 CLC                  ;ALIGN
 LDA RESULT
 ROL A
 RTS
;
MAKE3X83:
 ASL A ;DROP BIT FROM DATA
 JMP MAKE3X82
;
;
DOCARRET:
;PERFORM CARRIAGE RETURN
;
 INC BITROW
;
 LDA BITROW
 CMP #23 ;S/B 23
 BCC DOCARRET8
;
 DEC BITROW ;KEEP AT BOTTOM OF SCREEN
;
ENDBITMAP: EQU $FFFF-192-$100
; 
 JSR PUSH_EOT           ;SAVE AND RESTORE EOT
 LDA #<ENDBITMAP
 STA EOT
 LDA #>ENDBITMAP
 STA EOT+1 ;"END" ADDRESS FOR COPYDN
;
 LDA #<BITMAP
 STA MOVELO
 LDA #>BITMAP
 STA MOVELO+1 ;START OF COPYDN
;
BIT1STLINE: EQU BITMAP+320
;
 LDA #<BIT1STLINE
 STA MOVEHI
 LDA #>BIT1STLINE
 STA MOVEHI+1 ;END OF COPY RANGE
;
 JSR COPYDN
 JSR POP_EOT            ;RESTORE EOT
; 
DOCARRET8:
;
 JSR W_INTO_P1
 DW BITMAP
;
 LDA BITROW
 STA T1
;
DOCARRET1:
 LDA #<320
 LDX #>320
 JSR INC_P1_BY_AX
;
 DEC T1
 BNE DOCARRET1
;
 JSR P1_INTO_P2
;
DOCARRET9: 
 LDA #0
 STA BITCOLUMN
 JMP DRAWCHAR3 
;
;
DRAWCHAR:
;PLACE CHARACTER AT BITCURSOR
 STX XYTEMP
 STY XYTEMP+1
;
 CMP #$0D
 BEQ DOCARRET ;DO A CARRIAGE RETURN
 CMP #$0A
 BEQ DRAWCHAR3
 LDX BITCOLUMN
 CPX #80
 BCS DRAWCHAR3 ;EXIT IF BITCOLUMN > 80
;
DRAWCHAR0:
;
 JSR PETASC
;
; AND #$7F
;
 PHA ;CHARACTER TO DRAW (ASSUME SCREEN CODE FOR NOW)
;
 JSR SETSHIFT ;SET SHIFT BYTE FOR CHARACTER .A
;
 JSR W_INTO_PT
 DW $D800
 PLA
 LDX #8
 JSR MUL_AX_PT           ;Return POINTER = (.A*.X)+POINTER, DESTROY P1
 JSR PT_INTO_P1
;
 LDY #0 ;INDEX THRU CHARACTER
DRAWCHAR1:
;
 LDA #$F0
 STA MASK ;ASSUME LOW NYBBLE REPLACED
;
 LDA (POINTER1),Y ;READ CHARACTER VALUE
 JSR MAKE3X8 ;MAKE THIS CHARACTER 3X8
;
 TAX                        ;SAVE CHARACTER
 LDA ATTRIBUTES             ;TEST FOR UNDERLINING CHARACTER
 AND #1
;
 BNE ?TEST_UNDERLINE  ;UNDERLINING IS ON, DRAW UNDERSCORE?
 LDA ATTRIBUTES       ;ARE ANY OTHER ATTRIBUTES ON?
 AND #$FE
 PHP
 TXA
 PLP
 BEQ DRAWCHAR1C
 BNE DRAWCHAR1B
;
?TEST_UNDERLINE:
 TXA
 CPY #7            ;TEST UNDERLINING ROW?
 BNE DRAWCHAR1C    ;NO, NOT ON LAST COLUMN
 LDA #$0F          ;YES UNDERLINING
 BNE DRAWCHAR1C
;
DRAWCHAR1B: 
;REVERSE MODE IF NOT UNDERLINING
 EOR #$0F
;
DRAWCHAR1C:
;
 PHA               ;SAVE [LOWER 4] SIGNIFICANT
 LDA BITCOLUMN     ;MSN OR LSN?
 AND #1
 BNE DRAWCHAR2     ;LEAST SIG NYBBLE
 PLA
 ASL A
 ASL A
 ASL A
 ASL A             ;NOW SET AS HI NYBBLE    
 PHA
 LDA #$0F
 STA MASK
;
DRAWCHAR2:
 PLA
 STA T1
 LDA (BITCURSOR),Y ;GET CHARACTER FROM MEMORY 
 AND MASK          ;GET ONLY NEEDED STUFF
 ORA T1
 STA (BITCURSOR),Y
 INY 
 CPY #8
 BCC DRAWCHAR1
;
 INC BITCOLUMN
 LDA BITCOLUMN
 AND #1
 BNE DRAWCHAR3     ;ADVANCE ONLY IF BECOMES EVEN
; 
; CLC
; LDA #8
; ADC BITCURSOR
; STA BITCURSOR
; BCC DRAWCHAR3
; INC BITCURSOR+1
 LDA #8
 JSR INC_P2_BY_A         ;P2 += .A 
;
DRAWCHAR3:
 LDX XYTEMP
 LDY XYTEMP+1
 RTS      
;
;
SETSHIFT:
;SET SHIFTBYTE FROM .A (PRESERVE NOTHING)
 LDX #0
SETSHIFT1:
 CMP CSTABLE,X
 BCC SETSHIFT2
 INX
 INX
 BNE SETSHIFT1
;
SETSHIFT2:
 INX
 LDA CSTABLE,X
 STA HOLDSHIT
 RTS
;
HOLDSHIT:
 DB 0
;
;
CSTABLE:
;
 DB 'B'-64 ;IF LESS THAN 
 DB CMASK1
 DB 'C'-64 
 DB CMASK4
 DB 'F'-64
 DB CMASK2
 DB 'G'-64
 DB CMASK1
 DB 'I'-64
 DB CMASK2
 DB 'M'-64
 DB CMASK1
 DB 'N'-64
 DB CMASK7 ;*3
 DB 'U'-64
 DB CMASK4
 DB 'W'-64
 DB CMASK1
 DB 'X'-64
 DB CMASK6
 DB 'Y'-64
 DB CMASK1
 DB 'Z'-64
 DB CMASK2
 DB '['-64
 DB CMASK1
 DB '['+1-64
 DB CMASK5
 DB ']'-64
 DB CMASK2
 DB '%'
 DB CMASK1
 DB '&'
 DB CMASK2
 DB ')'
 DB CMASK1
 DB '*'
 DB CMASK5
 DB ','
 DB CMASK4
 DB '/'
 DB CMASK1
 DB '0'
 DB CMASK2
 DB '1'
 DB CMASK4
 DB '<' 
 DB CMASK1
 DB '>'
 DB CMASK2
 DB '?'
 DB CMASK4
 DB 'A'
 DB CMASK2
 DB 'B'
 DB CMASK1
 DB 'D'
 DB CMASK4
 DB 'G'
 DB CMASK2
 DB 'I'
 DB CMASK6
 DB 'J'
 DB CMASK1
 DB 'M'
 DB CMASK2
 DB 'N'
 DB CMASK4
 DB 'Q'       
 DB CMASK7
 DB 'U'
 DB CMASK2
 DB 'W'
 DB CMASK1
 DB 'X'
 DB CMASK4
 DB 'Z' 
 DB CMASK6
 DB 255
 DB CMASK1
;
CMASK1: EQU %00110100 ;5,4,2
CMASK2: EQU %01010100 ;6,4,2
CMASK3: EQU %10010100 ;7,4,2
CMASK4: EQU %01010010 ;6,4,1
CMASK5: EQU %00101100 ;5,3,2
CMASK6: EQU %00101010 ;5,3,1
CMASK7: EQU %01001010 ;6,3,1
CMASK8: EQU %10010100 ;???
;
;
 END
;
                   
