;
 TITLE Format Routine 6502 4/18/88
 PW 120
;
 INCLUDE WWSETUP.ASM
 INCLUDE VARIABLS.ASM
;
;THINGS TO REMEMBER:
;	BUILD IS P1
;
;
 PUBLIC FONT_ONE
;
 PUBLIC ATT_ON_TABLE
 PUBLIC BOTTOM_MARGIN
 PUBLIC CHECK_SET_FONT
 PUBLIC CURRENT_CHAR
 PUBLIC CURSOR_TEXTP
 PUBLIC CUR_LEFT_FLAG		;UPDT_ATT_CL FLAG IN CALC LL
 PUBLIC CUR_LEFT_FLAG_RESULT	;UPDT_ATTS_CL RESULT IN CALC LL
 PUBLIC CUR_LEFT_FLAG_RESULT1	;UPDT_ATTS_CL RESULT IN CALC LL
 PUBLIC FC_WRAP_LINE
 PUBLIC FIND_PREV_A
 PUBLIC FIND_PREV_FONT
 PUBLIC FIND_PREV_MARGIN
 PUBLIC FIND_PREV_STYLE
 PUBLIC FIRST_CHARACTER_FONT
 PUBLIC FONT_BYTES
 PUBLIC FONT_DEF_LEN
 PUBLIC FONT_LEADING
 PUBLIC FONT_TABLE
 PUBLIC INTER_WORD_GAPS
 PUBLIC INSTALL_FONTS
 PUBLIC IS_BOLD
 PUBLIC IS_FONT_CODE
 PUBLIC IS_FONT_OR_BOLD
 PUBLIC IS_STYLE_CODE
 PUBLIC LAST_CHARACTER_FONT
 PUBLIC LAST_LINE_CHAR
 PUBLIC LEFPRT
 PUBLIC PAGE_LENGTH
 PUBLIC PARAGRAPH_FORMAT    ;DO A WHOLE PARAGRAPH
 PUBLIC PART_LINE_LENGTH
 PUBLIC PLNLEN
 PUBLIC PL_JUSTIFICATION
 PUBLIC POINT_AXPT_UPDATE_FBASE
 PUBLIC PRINT_GRAPHICS
 PUBLIC PTS_AND_DESCEND
 PUBLIC P2_TO_TEXT_X_Y      ;MOVE .X.Y FROM P2 TO TEXT
 PUBLIC SET_FONT ;FORMAT
 PUBLIC SET_START_OF_TEXT_FONT
 PUBLIC SET_STYLE
 PUBLIC SET_STYLE_ON
 PUBLIC SET_FONT_STYLE
 PUBLIC TAB_LINE_LEN			;MINIMUM POS FOR TAB
 PUBLIC TOP_MARGIN
 PUBLIC UPDATE_ATTRIBUTES_CR
 PUBLIC UPDATE_ATTRIBUTES_CL
 PUBLIC WRAP_LINE
;
 EXTERN HEADEBUG
;
 EXTERN ACTUAL_COLUMN_OUT
 EXTERN ADDYTX
 EXTERN AX_INTO_PT
 EXTERN BLKSET
 EXTERN CALCULATE_LINE_LENGTH
 EXTERN CALCULATE_LINE_LENGTH1
 EXTERN CHANGE_JUSTIFICATION	;BPRINT, SET JUSTIFY_FORMAT
 EXTERN CLEAR_P1                ;MLIB
 EXTERN CLL_INTERRUPT_POINT
 EXTERN CURSORP_TO_TEXT
 EXTERN DISPLY			;DISPLAY
 EXTERN DISPLAYOFF		;DISPLAY
 EXTERN EDIT_BUFFER_TO_TEXT
 EXTERN EDIT_LINE
 EXTERN EMBEDDED_CODES
 EXTERN FC_CURSOR_UP
 EXTERN FC_CURSOR_DOWN
 EXTERN FC_CURSOR_RIGHT
 EXTERN FIND_TAB_GT_ACT_COL
 EXTERN FIND_TAB_GT_TLL		;SUPPORT.ASM FIND TAB > TAB_LINE_LEN
 EXTERN FONT_BASE_SM1          	;CURRENT FONT BASE
 EXTERN FONT_BASE_SM2
 EXTERN FONT_START
 EXTERN GO_LEFT_MARGIN
 EXTERN HEADAT        		;#DEBUG
 EXTERN HARD_RETURN
 EXTERN INCTE1
 EXTERN INC_PT_BY_Y
 EXTERN INC_P1_BY_1
; EXTERN IN_DATABASE_MODE	;OVERLAY
 EXTERN IS_LRCJ
 EXTERN JUSTIFY_FORMAT
 EXTERN KERN_WIDTH_INTO_P2
 EXTERN LL_PLUS_FONTB_A     	;ADD TO LINE LENGTH
 EXTERN LL_PLUS_FONTBX_A
 EXTERN MOVEUP
 EXTERN MOVE_UP_ONE
 EXTERN MOVE_UP_Y
 EXTERN MUL_AX_PT
 EXTERN NEW_LINE_SPACE
 EXTERN OLD_CHARS_IN_LINE
 EXTERN PUSH_TEXT
 EXTERN POP_TEXT
 EXTERN PROCESS_MARGINS
 EXTERN PT_INTO_AX
 EXTERN REMOVE_A_BYTES
 EXTERN SERPP0
 EXTERN SET_AX_LM_LL		;BPRINT
 EXTERN SET_BIG_AND_CURRENT
 EXTERN SET_MARGIN_ONLY
 EXTERN SET_UNSET_BOLD
 EXTERN STARTLINE
 EXTERN STARTRAM
 EXTERN START_LINE_ATTRIBUTES
 EXTERN START_LINE_FONT
 EXTERN START_OF_TEXT
 EXTERN SWAPXY
 EXTERN TAB_TABLE
 EXTERN TEXCFE
 EXTERN TEXCF0
 EXTERN TEXT_INTO_AX
 EXTERN TEXT_TO_CURSORP
 EXTERN TEXT_TO_EDIT_BUFFER
 EXTERN TEXT_TO_NEXTLINE
 EXTERN TEXT_TO_PREV_LINE
 EXTERN USER_DEFINED_LEAD
 EXTERN W_INTO_PT
;
.LIST ON
;
FONT_TABLE:
 DW FONT_ONE,FONT_TWO,FONT_THREE,FONT_FOUR
 DW FONT_FIVE,FONT_SIX,FONT_SEVEN,FONT_EIGHT
 DW FONT_NINE,FONT_TEN
;
INSTALL_FONTS:
;
 DB $FE      ;WW4 IDENTIFIER
;
FONT_ONE:
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d           
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d 
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d 
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d 
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d 
 DB $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d 
 DB $0d, $0d, $04, $0d, $03, $06
 DB 'RACINE    12'
;
FONT_TWO:
 DB $0e, $08, $08, $07, $08, $07, $07, $09, $0a, $07, $05, $08, $07, $0d            
 DB $0a, $08, $08, $08, $08, $07, $06, $0a, $09, $0d, $0a, $0a, $08, $05, $05, $05  
 DB $07, $08, $05, $04, $05, $09, $08, $0c, $0b, $03, $05, $05, $07, $09, $06, $05  
 DB $06, $05, $08, $08, $08, $08, $08, $08, $08, $08, $08, $08, $05, $05, $09, $08  
 DB $09, $07, $05, $0c, $0b, $0b, $0c, $0b, $0b, $0c, $0d, $07, $08, $0c, $0a, $11  
 DB $0d, $0b, $0b, $0b, $0c, $0a, $0b, $0e, $0d, $10, $0c, $0d, $0a, $07, $03, $07  
 DB $08, $00, $0b, $02, $06
 DB 'DEERFIELD 10'
;
FONT_THREE:
 DB $11, $0a, $09, $09, $0a, $09, $07, $09, $0b, $07, $05, $0b, $07, $0f, $0b 
 DB $09, $0a, $0a, $09, $09, $07, $0b, $0a, $0c, $09, $0a, $08, $05, $05, $05, $09 
 DB $09, $05, $05, $08, $09, $09, $0f, $0e, $05, $06, $06, $09, $09, $05, $07, $05 
 DB $05, $09, $09, $09, $09, $09, $09, $09, $09, $09, $09, $05, $05, $0b, $09, $0b 
 DB $08, $06, $0d, $0c, $0d, $0d, $0c, $0c, $0e, $0e, $07, $09, $0e, $0b, $12, $0e 
 DB $0d, $0c, $0d, $0d, $0b, $0d, $0f, $0e, $12, $0c, $0d, $0b, $07, $03, $07, $09 
 DB $00, $0c, $03, $06
 DB 'DEERFIELD 12'
;
FONT_FOUR:
 DB $0e, $08, $08, $08, $08, $08, $05, $08, $08, $05, $06, $08, $04, $0d, $08, $08 
 DB $08, $08, $07, $08, $06, $08, $09, $0e, $08, $08, $08, $07, $0a, $07, $07, $0a 
 DB $05, $03, $08, $0a, $0a, $0f, $0c, $05, $06, $06, $0c, $0a, $04, $0a, $03, $0a 
 DB $0a, $0a, $0a, $0a, $0a, $0a, $0a, $0a, $0a, $0a, $05, $04, $07, $0a, $07, $08 
 DB $06, $0a, $0a, $0a, $0a, $09, $09, $0a, $0a, $05, $09, $09, $08, $0d, $0a, $0a 
 DB $0a, $0a, $0a, $0a, $09, $0a, $0a, $0f, $0a, $0a, $0a, $07, $05, $07, $0b, $00 
 DB $0b, $02, $06
 DB 'DESPLAINES10'
;
FONT_FIVE:
 DB $0e  
 DB $0a, $0a, $0a, $0a, $0a, $07, $0a, $0a, $05, $06, $0a, $05, $10, $0a, $0a, $0a 
 DB $0a, $08, $0a, $07, $0a, $0b, $10, $0a, $0a, $0b, $05, $0c, $05, $07, $0c, $06 
 DB $05, $08, $0e, $0b, $0f, $0e, $05, $07, $07, $0c, $0b, $06, $0a, $05, $0c, $0b 
 DB $0b, $0b, $0b, $0b, $0b, $0b, $0b, $0b, $0b, $05, $06, $09, $0a, $09, $0c, $06 
 DB $0e, $0b, $0b, $0b, $0a, $0a, $0b, $0b, $04, $0a, $0b, $0a, $0d, $0c, $0c, $0b 
 DB $0c, $0b, $0b, $0c, $0b, $0d, $12, $0c, $0c, $0a, $08, $05, $08, $0c, $00, $0e 
 DB $03, $06
 DB 'DESPLAINES12'
;
FONT_SIX:
 DB $2a, $1c 
 DB $1c, $1b, $1c, $1c, $16, $1c, $1c, $0e, $12, $1b, $0e, $2b, $1c, $1b, $1c, $1b 
 DB $18, $1c, $16, $1c, $19, $29, $1a, $19, $19, $12, $1c, $12, $12, $22, $12, $0c 
 DB $15, $22, $20, $26, $26, $0c, $10, $10, $22, $22, $10, $1f, $10, $1c, $22, $22 
 DB $22, $22, $22, $22, $22, $22, $22, $22, $10, $10, $1a, $22, $1a, $22, $12, $1f 
 DB $1f, $1f, $20, $1b, $1b, $20, $20, $0a, $1c, $22, $1b, $25, $20, $22, $1d, $22 
 DB $1f, $1f, $20, $20, $1f, $31, $22, $1e, $1c, $11, $06, $11, $22, $00, $26, $08 
 DB $06
 DB 'DESPLAINES36'
;
FONT_SEVEN:
 DB $30, $1e, $1e  
 DB $18, $1f, $1a, $15, $1b, $20, $10, $0c, $1f, $10, $2e, $20, $1a, $1d, $1d, $19 
 DB $16, $13, $1f, $1c, $28, $1e, $1c, $1b, $12, $1e, $12, $18, $22, $12, $11, $18 
 DB $22, $22, $28, $2e, $0f, $18, $18, $18, $22, $12, $1e, $12, $1e, $22, $22, $22 
 DB $22, $22, $22, $22, $22, $22, $22, $12, $12, $18, $22, $18, $1e, $12, $26, $21 
 DB $20, $25, $21, $1f, $21, $26, $10, $18, $25, $20, $2e, $24, $24, $21, $23, $24 
 DB $1c, $22, $25, $27, $34, $25, $21, $1e, $18, $0c, $18, $18, $00, $24, $07, $06 
 DB 'WILMETTE  36'
;
FONT_EIGHT:
 DB $15, $0e, $0c, $0a 
 DB $0f, $0b, $0a, $0c, $0f, $09, $06, $0f, $08, $18, $10, $0c, $0d, $0c, $0a, $0a 
 DB $09, $0f, $0e, $13, $11, $0e, $0c, $09, $0e, $09, $0c, $0e, $08, $08, $0c, $0e 
 DB $0e, $12, $16, $08, $0b, $0b, $0e, $0e, $09, $0e, $09, $0e, $0e, $0e, $0e, $0e 
 DB $0e, $0e, $0e, $0e, $0e, $0e, $09, $09, $0b, $0e, $0b, $0e, $08, $17, $0f, $0c 
 DB $11, $10, $0f, $10, $15, $0c, $0a, $14, $0f, $1a, $14, $10, $10, $10, $14, $0d 
 DB $13, $11, $0f, $15, $16, $11, $10, $0b, $08, $0b, $0c, $00, $12, $04, $06
 DB 'RAVINIA   18'
;
FONT_NINE:
 DB $18, $0f, $0e, $0e, $0f 
 DB $0e, $0a, $0f, $11, $09, $07, $11, $0a, $19, $11, $0e, $10, $0f, $0f, $0e, $0b 
 DB $0f, $0f, $17, $11, $11, $0e, $0b, $12, $0b, $0c, $0f, $08, $09, $0f, $15, $0f 
 DB $18, $12, $09, $0c, $0c, $0e, $0f, $08, $0f, $08, $12, $0f, $0f, $0f, $0f, $0f 
 DB $0f, $0f, $0f, $0f, $0f, $08, $08, $0c, $12, $0c, $0f, $08, $12, $11, $0f, $11 
 DB $11, $11, $0f, $12, $09, $0b, $14, $11, $1b, $12, $0f, $11, $0f, $14, $0f, $12 
 DB $12, $13, $1d, $14, $13, $10, $0b, $09, $0b, $0f, $00, $13, $04, $06
 DB 'WESTWOOD  18'
;
FONT_TEN:
 DB $27, $15, $21, $27, $06, $18  
 DB $13, $20, $18, $33, $2e, $23, $12, $1e, $1c, $21, $35, $1e, $2d, $1a, $1a, $11 
 DB $15, $1b, $1a, $10, $0f, $30, $2a, $36, $26, $1d, $0e, $27, $1d, $22, $15, $14 
 DB $17, $18, $15, $2a, $19, $15, $15, $19, $17, $1f, $1e, $1f, $1c, $18, $1d, $15 
 DB $13, $1e, $1f, $12, $22, $14, $17, $24, $1b, $1d, $24, $17, $1a, $27, $18, $20 
 DB $32, $33, $30, $3e, $20, $1e, $1f, $1d, $1d, $38, $1e, $0f, $15, $15, $1d, $20 
 DB $0e, $14, $12, $26, $22, $18, $12, $12, $17, $14, $18, $04, $06
 DB 'DOODAD    24'
;
LAST_FONT:
 DB 0,0  ;FUDGE
;
FONT_BYTES: EQU FONT_TWO-FONT_ONE
FONT_DEF_LEN: EQU LAST_FONT-INSTALL_FONTS
; 
.LIST ON
;
PLNLEN: 
 DW 0 ;LINE LENGTH TO PRINT
LEFPRT:
 DW 0 ;CURRENT LEFT MARGIN
PRINT_GRAPHICS:
 DB 1     ;1 = GRAPHICS PRINTING/0 = TEXT
;
CURSOR_TEXTP:
 DW 0
FONT_TEMP:
 DB 0
PAGE_LENGTH:
 DW 0
LAST_LINE_CHAR:
 DB 0
TOP_MARGIN:
 DW 0
BOTTOM_MARGIN:
 DW 0
INTER_WORD_GAPS:
 DB 0
PL_JUSTIFICATION:
 DB 0
FONT_LEADING:
 DB 0
PARAGRAPH_FORMAT:
 DB 0 
FIRST_CHARACTER_FOUND:
 DB 0
FIRST_CHARACTER_FONT:
 DB 0
LAST_CHARACTER_FONT:
 DB 0 
;
;ATTRIBUTES:
;BLD,ITL,US1,US2,US3,SUP,SUB,UND
; 
;
RETURNS_ENCOUNTERED:
 DB 0
BREAKS_IN_LINE:
 DB 0
;# MAY PUT IN ZP?
INS_DEL_CHARS:
 DW 0
FIRST_WRAP_POINT:
 DB 0
COLUMN_POSITION:
 DB 0
SRET_IN_WORD:
 DW 0
TAB_LINE_LEN:
 DW 0
;TAB_POINT:
; DW 0
FORMAT_TEMP:
 DB 0
DATA_IN_LINE:
 DB 0 
CUR_LEFT_FLAG:
 DB 0
CUR_LEFT_FLAG_RESULT:
 DB $FF
CUR_LEFT_FLAG_RESULT1:
 DB $FF
;
ATT_ON_TABLE:
 DB $01,$80,$40,$04,$02,$20,$10,$08
;
ATT_OFF_TABLE:
 DB $FF-$01,$FF-$80,$FF-$40,$FF-$04
 DB $FF-$02,$FF-$20,$FF-$10,$FF-$08
; 
;
.LIST ON
;
ABORT:
 CLC         ;CLC NO DISPLAY NEEDED
 RTS
;
WRAP_LINE:
;
;
 LDA LINE_LENGTH+1
 CMP MARGIN+1
 BNE ?SKP
 LDA LINE_LENGTH
 CMP MARGIN
 BEQ ABORT
?SKP:
 BCC ABORT
;
FC_WRAP_LINE:
; 
 LDA EDIT_LINE           ;DO NOT PROCESS CHECKMARK LINES
 CMP #122
 BEQ ABORT
 LDA IN_DATABASE_MODE
 BNE ABORT 
;
 LDX EOT+1
 INX
;
 CPX #>(ENDRAM-$100)
 BCC ?MIN_MEM_OK
 JMP ?FORMAT_FAILURE     ;EXIT W/FF MESSAGE, TEXT UNDISTURBED 
; 
?MIN_MEM_OK:
 STX BUILD+1       
 STX POINTER2+1
 LDX EOT
 STX BUILD               ;SET BUILD-IMAGE POINTER EOT+$100
 STX POINTER2
;
 LDX #0                  ;CONTROL EDIT_LINE VS TEXT AND
 STX RETURNS_ENCOUNTERED ;STOP AFTER N LINES HERE
 DEX                     ;[FF]
 STX FIRST_WRAP_POINT    ;(NO WRAP) LOCATION OF 1ST WRAP
;
 LDA ATTRIBUTES
 PHA
 LDA CURRENT_FONT
 PHA                     ;SAVE OFF ATTRIBUTES AND FONT
;
;
;# PLACE START_LINE_ATTRIBUTE AND START_LINE_FONT HERE
 LDA START_LINE_ATTRIBUTES  ;SET 1ST CHAR ATTRIBUTES
 STA ATTRIBUTES
 LDA START_LINE_FONT
 STA CURRENT_FONT
 JSR POINT_AXPT_UPDATE_FBASE   ;UPDATE FONT AND CURRENT PTS
;
;
 JSR TEXT_TO_CURSORP     ;SAVE OFF TEXT POINTER
 LDA #<EDIT_LINE
 STA TEXT
 LDA #>EDIT_LINE
 STA TEXT+1              ;SET TEXT POINTER INTO EDIT_LINE
;
;
;PROCESS LINE
 LDA #0
 STA INS_DEL_CHARS+1     ;16 BIT SIGNED, USUALLY POSITIVE
 SEC
 LDA CHARS_IN_LINE       ;LENGTH OF CURRENT LINE
 SBC OLD_CHARS_IN_LINE   ;MIN LENGTH OF IN TEXT LINE
 STA INS_DEL_CHARS       ;PRIMES TEXT BUFFER MOVEMENT
 BCS ?POSITIVE
 DEC INS_DEL_CHARS+1     ;SET HB NEGATIVE 
?POSITIVE:
;
?NEW_LINE:
 LDY #0
 STY SRET_IN_WORD+1      ;ADDRESS/FLAG FOR SRET INSIDE WORD
 STY COLUMN_POSITION     ;ACTUAL COLUMN FOR CURSOR WRAP
 STY TOTAL_LINE_LENGTH   ;SUM OF WORD LENGTHS
 STY TOTAL_LINE_LENGTH+1
 STY BREAKS_IN_LINE      ;TRACKS ONLY 1 WORD ON LINE
;
?CLEAR_LL_LOOP:
 STY LINE_LENGTH
 STY LINE_LENGTH+1       ;SUMS THIS WORD LENGTH
;
?WORD_LOOP:
 LDA (TEXT),Y
 BMI ?HI_BIT_CHARACTER
 JMP ?NORMAL_CHARACTER
; 
;
?HI_BIT_CHARACTER: 
 CMP #SRETRN             ;SOFT RETURN FOUND "IN" LINE?
 BNE ?HRET_EOT_FONT      ;NO, GO TRY OTHERS...
;
 LDA TEXT+1
 STA SRET_IN_WORD+1      ;FLAG/ADDRESS FOR SRET INSIDE WORD
 LDA TEXT
 STA SRET_IN_WORD
;
 LDA RETURNS_ENCOUNTERED ;IF WE ARE IN EDIT_LINE, THIS IS ZERO
 BNE ?SKP01
 INC RETURNS_ENCOUNTERED
 STY POINTER
 JSR CURSORP_TO_TEXT 
 JSR TEXT_TO_NEXTLINE    ;SET TEXT AT START OF 2ND LINE
 SEC
 LDA TEXT
 SBC POINTER
 STA TEXT
 BCS ?SKP00
 DEC TEXT+1              ;MOVE BACK BY .Y INDEX   
?SKP00:
 LDY POINTER
 JMP ?SKP02
;
?SKP01:
 JSR INCTE1
?SKP02:
 LDA INS_DEL_CHARS
 BNE ?JST_LO
 DEC INS_DEL_CHARS+1
?JST_LO:
 DEC INS_DEL_CHARS
;
?J_WORD_LOOP:
 JMP ?WORD_LOOP
;
;
?HRET_EOT_FONT:
 CMP #ENDT               ;HRET OR EOT?
 BCC ?CHK_FONT
;
 JMP ?IMAGE_DONE
;
?CHK_FONT:
;
 STA (BUILD),Y           ;SET CHAR INTO BUILD, NORMALLY FITS
;
 CMP #'B'+$80            ;IS THIS BOLD ON?
 BNE ?BOLD_OFF
;
 LDA ATTRIBUTES
 ORA #$80
 BMI ?SET_ATT
;  
?BOLD_OFF:
 CMP #'B'-'@'+$80        ;IS THIS BOLD OFF?
 BNE ?TRY_FONT
;
 LDA ATTRIBUTES
 AND #$7F 
?SET_ATT:
 STA ATTRIBUTES 
;
; JSR ATTRIBUTES_TO_BOLD_ON
; 
 JMP ?NOT_FONT_YOK
;
?TRY_FONT:
 STY FORMAT_TEMP
 JSR CHECK_SET_FONT
; LDY FORMAT_TEMP
;
 CMP #TABCHAR
 BNE ?NOT_FONT
;
;TAB RULES:
;	IF TABCHAR && LEFT_JUSTIFY
;		FIND TAB LOCATION > CURRENT POSITION
;		IF NONE, IGNORE
;		IF > MARGIN
;			IF THERE WAS A PRECEEDING WORD
;				CAUSE IT TO WRAP
;			ELSE
;				????
;		IF < MARGIN
;			INDICATE A BREAKPOINT
;			UPDATE TOTAL_LINE_LENGTH
;			SET LL TO 0, MOVE TO NEXT CHAR
;
;
;
 LDY JUSTIFY_FORMAT
 BNE ?NF_RES_Y 		;IGNORE IF NOT FONT
;
 CLC
 LDA LINE_LENGTH
 ADC TOTAL_LINE_LENGTH
 STA TAB_LINE_LEN
 STA DATA_IN_LINE
 LDA LINE_LENGTH+1
 ADC TOTAL_LINE_LENGTH+1
 STA TAB_LINE_LEN+1	;TAB_LINE_LEN = LINE SIZE SO FAR
 ORA DATA_IN_LINE
 STA DATA_IN_LINE	;DATA_IN_LINE SET IF ANYTHING IMAGED 
;
;.Y == 0
 JSR FIND_TAB_GT_TLL	;FIND NEXT TAB > TAB_LINE_LEN
 BCC ?IGNORE_TAB	;CC = NO TAB FOUND
;?TABLOOP:
; STY ?SM1_INDEX		;SAVE INDEX
; LDA TAB_TABLE,Y	;GET NTH TAB POSITION
; CMP #$FF	 	;IF WE FIND $FF, NO TAB WORKED.
; BEQ ?IGNORE_TAB	;BIF SUITABLE TAB > CURRENT POS NOT FOUND
; LDX #0			;CLEAR HB FOR TEXT MODE
; JSR SET_AX_LM_LL	;GET "DOT POSITION" IN AX
;;
; CPX TAB_LINE_LEN+1	;IF OUR SIZE > LINE LEN?
; BEQ ?TST_LO
; BCS ?TAB_OVER_CURPOS
;;
;?TST_LO:
; CMP TAB_LINE_LEN	;TEST LO
; BCS ?TAB_OVER_CURPOS
;;
; DB $A0			;LDY #
;?SM1_INDEX:
; DB $00			
; INY
; BNE ?TABLOOP		;TRY NEXT TAB
;
?TAB_OVER_CURPOS:
;
;TAB IS > CURRENT POS, BUT IS IT > MARGIN?
 CPX MARGIN+1		;IS .A.X >= MARGIN
 BEQ ?SKP_L		
 BCC ?TAB_LT_MARGIN
 BCS ?TAB_GT_MARGIN
;
?SKP_L:
 CMP MARGIN
 BCC ?TAB_LT_MARGIN
;
?TAB_GT_MARGIN:
;
;TAB IS BEYOND OUR MARGIN, IS THERE A WORD ALREADY ON THIS LINE? 
 LDY DATA_IN_LINE
 BEQ ?IGNORE_TAB	;SO IGNORE TAB CHAR COMPLETELY
;
 LDA #$80		;*FORCE* THE WRAP BY MAKING *HUGE* LINE LEN
 STA LINE_LENGTH+1	;AND GO TO END OF WORD
 BNE ?END_OF_WORD_RES_Y ;THIS SHOULD FORCE PREV "WORD" TO WRAP
;
?TAB_LT_MARGIN:
 STA TOTAL_LINE_LENGTH
 STX TOTAL_LINE_LENGTH+1
 INC COLUMN_POSITION
 LDY FORMAT_TEMP
 INY 
 BNE ?WORD_FIT
;
?IGNORE_TAB:
;
?NF_RES_Y:
?NOT_FONT:
 LDY FORMAT_TEMP
;
?NOT_FONT_YOK:
 INC COLUMN_POSITION    ;ACTUAL COLUMN FOR CURSOR WRAP
 INY                    ;EMBEDDED CODES HAVE NO LENGTH
 JMP ?WORD_LOOP		;UNCHANGED TO JUMP	
;
;
;PROCESS NORMAL CHARACTERS
;
?NORMAL_CHARACTER:
 CMP #' '                ;END OF WORD?
 BEQ ?END_OF_WORD        ;BIF YES
;
 STA (BUILD),Y           ;SET CHAR INTO BUILD, NORMALLY FITS
; INC COLUMN_POSITION     ;ACTUAL COLUMN FOR CURSOR WRAP
 JSR LL_PLUS_FONTBX_A    ;LINE_LENGTH+ FONT_BASE (.Y UNHARMED)
 INC COLUMN_POSITION     ;ACTUAL COLUMN FOR CURSOR WRAP
 INY
 JMP ?WORD_LOOP		;NOW JUMP
;
;
;PROCESS WORD END
;
?END_OF_WORD_RES_Y:
 LDY FORMAT_TEMP
;
?END_OF_WORD
 CLC 
 LDA LINE_LENGTH
 ADC TOTAL_LINE_LENGTH
 STA TOTAL_LINE_LENGTH
 LDA LINE_LENGTH+1
 ADC TOTAL_LINE_LENGTH+1
 STA TOTAL_LINE_LENGTH+1 ;ADD WORD LENGTH TO TOTAL
;
 CMP MARGIN+1
 BCC ?WORD_FIT           ;TOT_LINE_LENGTH < MARGIN, NEXT CHAR
 BEQ ?SKP0
 JMP ?WORD_OVERFLOW      ;TOT_LINE_LENGTH > MARGIN, DONE
;
?SKP0:
 LDA TOTAL_LINE_LENGTH   ;HB'S ARE EQUAL
 CMP MARGIN              ;TEST LO BYTES
 BCC ?WORD_FIT           ;IT FITS, DO NEXT WORD
 JMP ?WORD_OVERFLOW
;
?WORD_FIT:
;
 INC BREAKS_IN_LINE      ;WE FIT AT LEAST ONE WORD WITH BREAKPOINT
; 
 LDA #0
 STA SRET_IN_WORD+1      ;FLAG/ADDRESS FOR SRET INSIDE WORD
 STA LINE_LENGTH 
 STA LINE_LENGTH+1       ;CLEAR LL, ADD LENGTH OF SPACES AFTER WORD
;
?SPACE_LOOP:
 LDA (TEXT),Y
 CMP #' '
 BNE ?CHECK_EOLN
 STA (BUILD),Y
 INC COLUMN_POSITION     ;ACTUAL COLUMN FOR CURSOR WRAP
 JSR LL_PLUS_FONTBX_A    ;LINE_LENGTH+ FONT_BASE (.Y UNHARMED)
 INY
 BNE ?SPACE_LOOP
;
;
?CHECK_EOLN:
 CMP #ENDT               ;NORMAL CHARACTER IS MOST COMMON
 BCS ?TRY_RETURN_EOT
;
; CLC
 TYA
 ADC BUILD
 STA BUILD
 BCC ?SKP3
 INC BUILD+1             ;BUMP UP BUILD BY WORD + SPACE LENGTH   
;
 LDA BUILD+1
 CMP #>ENDRAM 
 BCS ?FORMAT_FAILURE_S
; 
?SKP3:
;
 CLC
 TYA
 ADC TEXT
 STA TEXT
 BCC ?SKP4
 INC TEXT+1              ;MOVE TEXT UP BY WORD + SPACE LENGTH
?SKP4:
;
 LDY #0                  ;CLEAR .Y INDEX
 JMP ?WORD_LOOP
;
;
;ERROR-OUT
;
?FORMAT_FAILURE_S:
;
 PLA
 STA CURRENT_FONT
 JSR POINT_AXPT_AT_FONT
 PLA
 STA ATTRIBUTES
 JSR CURSORP_TO_TEXT
;
?FORMAT_FAILURE:
 LDX #23
 JMP SERPP0
;
;
;
?TRY_RETURN_EOT:
 CMP #SRETRN             ;FIND A SOFT RETURN IN POST-WORD SPACE?
 BEQ ?WAS_SOFT_RETURN
;# SAFE ASSUMPTION?      
?J_IMAGE_DONE: 
 JMP ?IMAGE_DONE         ;ASSUME RET/EOT
;
?WAS_SOFT_RETURN:
 CLC
 TYA
 ADC BUILD
 STA BUILD
 BCC ?SKP
 INC BUILD+1             ;BUMP UP BUILD BY WORD + SPACE LENGTH   
;
 LDA BUILD+1
 CMP #>ENDRAM 
 BCS ?FORMAT_FAILURE_S
;
?SKP:
 LDA RETURNS_ENCOUNTERED ;IF WE ARE IN EDIT_LINE, THIS IS ZERO
 BNE ?SKP1
 INC RETURNS_ENCOUNTERED
 JSR CURSORP_TO_TEXT 
 JSR TEXT_TO_NEXTLINE    ;SET TEXT AT START OF 2ND LINE
 JMP ?SKP2
;
?SKP1:
 INY   
 TYA
 CLC
 ADC TEXT
 STA TEXT
 BCC ?SKP2
 INC TEXT+1              ;BUMP UP TEXT BY WORD + SPACE + SRET
?SKP2:
;
 LDY #0                  ;INDEX TO ZERO
;
 CLC
 LDA LINE_LENGTH
 ADC TOTAL_LINE_LENGTH
 STA TOTAL_LINE_LENGTH
 LDA LINE_LENGTH+1
 ADC TOTAL_LINE_LENGTH+1
 STA TOTAL_LINE_LENGTH+1
;
 LDX PARAGRAPH_FORMAT
 BNE ?ZERO_CONT          ;FORMAT AN ENTIRE PARAGRAPH
;
 CMP MARGIN+1
 BCC ?ZERO_CONT          ;TOT_LINE_LENGTH < MARGIN, NEXT CHAR
 BNE ?J_IMAGE_DONE         ;TOT_LINE_LENGTH > MARGIN, DONE
;
?TST_LB:
 LDA TOTAL_LINE_LENGTH   ;HB'S ARE EQUAL
 CMP MARGIN              ;TEST LO BYTES
 BCS ?J_IMAGE_DONE         ;LL >= MARGIN, DONE
;
?ZERO_CONT:
 LDA INS_DEL_CHARS
 BNE ?JST_LO1
 DEC INS_DEL_CHARS+1
?JST_LO1:
 DEC INS_DEL_CHARS	;ONE CHARACTER REMOVED
 JMP ?CLEAR_LL_LOOP      ;CLEAR LL AND LOOP
;
;THIS WORD DID NOT FIT ON THE LINE
;
?WORD_OVERFLOW:
;
;WORD DID NOT FIT ON LINE, MUST PLACE SOFT RETURN NOW
 LDA BREAKS_IN_LINE
 BNE ?FOUND_BREAKS
;
?SP_LOOP: 
 LDA (TEXT),Y
 CMP #' '
 BNE ?SPACES_HANDLED
 STA (BUILD),Y
 INC COLUMN_POSITION     ;ACTUAL COLUMN FOR CURSOR WRAP
 INY
 BNE ?SP_LOOP
;
?SPACES_HANDLED
;
 CMP #ENDT 
 BCS ?IMAGE_DONE
;
 JSR ADDYTX
;
?ADJ_BLD:
 TYA                     ;BUILD + INDEC
 CLC
 ADC BUILD
 STA BUILD
 BCC ?SET_WRAP_POINT
 INC BUILD+1
;
 LDA BUILD+1
 CMP #>ENDRAM 
 BCS ?J_FORMAT_FAILURE_S
;
?SET_WRAP_POINT:
 LDA FIRST_WRAP_POINT
 CMP #$FF 
 BNE ?SKP4A 
; 
 LDA CURRENT_CHAR
 STA FIRST_WRAP_POINT 
 JMP ?SKP4A
;
?FOUND_BREAKS:
;
 LDA FIRST_WRAP_POINT    ;HAVE WE HAD OUR FIRST WRAP?
 CMP #$FF
 BNE ?SKP4A              ;SKIP IF YES
 STY LINE_LENGTH         ;# EXTRA CHARACTERS
 SEC
 LDA COLUMN_POSITION
 SBC LINE_LENGTH
 STA FIRST_WRAP_POINT    ;AND SET IT FOR CURSOR WRAP
;
?SKP4A: 
 LDA #SRETRN
 LDY #0
 STA (BUILD),Y
;
 INC BUILD		;REMEMBER BUILD IS P1
 BNE ?SKP4B
 INC BUILD+1		;BUMP AROUND SRET
;
 LDA BUILD+1
 CMP #>ENDRAM 
 BCC ?SKP4B
?J_FORMAT_FAILURE_S:
 JMP ?FORMAT_FAILURE_S    
; 
?SKP4B:
 INC INS_DEL_CHARS
 BNE ?JUSI_LO 
 INC INS_DEL_CHARS+1 
?JUSI_LO: 
;
 LDA SRET_IN_WORD+1      ;FLAG FOR SRET INSIDE WORD
 BEQ ?J_NEW_LINE
 STA TEXT+1 
 LDA SRET_IN_WORD
 STA TEXT
?J_NEW_LINE:
 JMP ?NEW_LINE
;
;
?IMAGE_DONE:
;
 STY LINE_LENGTH         ;.Y = INDEX TO STOP
 JSR CURSORP_TO_TEXT     ;RESTORE ORIGINAL TEXT POINTER
;
 LDY INS_DEL_CHARS+1     ;+/- 256 BYTE MAX MOVE
 BMI ?MOVE_DOWN
 LDY INS_DEL_CHARS
 BEQ ?NO_MOVE
; 
; BMI ?MOVE_DOWN
 JSR MOVE_UP_Y
 JMP ?NO_MOVE
;
?MOVE_DOWN: 
 LDA INS_DEL_CHARS
; TYA
 EOR #$FF
 CLC
 ADC #1
 JSR REMOVE_A_BYTES      ;KILL UNWANTED SPACE
; 
?NO_MOVE:
;
 LDA LINE_LENGTH
 CLC
 ADC BUILD
 TAY
 LDA #0
 ADC BUILD+1
 STA LINE_LENGTH
;
 SEC
 TYA            ;LB BUILD + .Y
 SBC POINTER2   ;LB INITIAL BUILD
 TAX            ;SAVE LB
 LDA LINE_LENGTH
 SBC POINTER2+1
 TAY
;
 CPX #0         ;TEST LO BYTE FOR PAGE FLIP   
 BNE ?SKP5      ;IF NOT 0-$FF, JUST LOW
 DEY            ;DEC HB BYTE
?SKP5:
 DEX
; 
 JSR P2_TO_TEXT_X_Y      ;MOVE .X.Y FROM P2 TO TEXT
 JSR CURSORP_TO_TEXT     ;RESTORE TEXT POINTER
;
 PLA
 STA CURRENT_FONT
 JSR POINT_AXPT_AT_FONT
 PLA 
 STA ATTRIBUTES 
 JSR TEXT_TO_EDIT_BUFFER
;
 LDA FIRST_WRAP_POINT
 CMP #$FF
 BEQ ?THIS_LINE 
; 
 CMP CURRENT_CHAR
 BCC ?SKP6
 BNE ?THIS_LINE
;
?SKP6:
 LDA CURRENT_CHAR        ;GET CURRENT CHARACTER
 PHA                     ;SAVE CURRENT CHAR ON STACK
;# MUST RESTORE ATTRIBUTES
; LDA #$60                ;RTS CODE
; STA DISPLY              ;FAST DISPLAY OFF
 JSR DISPLAYOFF
;
 JSR GO_LEFT_MARGIN
 JSR CALCULATE_LINE_LENGTH
;
 LDA #0                  ;PROHIBIT CURSOR DOWN
 STA EDIT_BUFFER_CHANGED ;FROM COPYING EDIT_LINE TO TEXT
;
 JSR FC_CURSOR_DOWN
;
; 
;TOO MANY PAGES LIKELY FOUND HERE, SEE NOT_ENOUGH_MEMORY IN SUPPORT
; 
;
 PLA
 SEC
 SBC FIRST_WRAP_POINT
 BEQ ?THIS_LINE
 STA COUNT_DOWN
;
?LOOP2:
 JSR FC_CURSOR_RIGHT
 DEC COUNT_DOWN
 BNE ?LOOP2
;
 SEC
 RTS
?THIS_LINE:
; 
 JSR CALCULATE_LINE_LENGTH
 SEC               ;DISPLAY NEEDED   
 RTS
;
;
?LONG_LINE_SRET:
;
;SOFT RETURN FOUND IN SPACE AFTER
;HUGE WORD WHICH WILL NOT FIT A LINE
;MUST DROP WORD.  PLACE TEXT POINTER
;AFTER SRET,BUILD IN SRET, AND BUMP
;BUILD, START NEW LINE.
;
; LDA FIRST_WRAP_POINT    ;HAVE WE HAD OUR FIRST WRAP?
; CMP #$FF
; BNE ?BREAK_PT           ;SKIP IF YES
; STY LINE_LENGTH         ;# EXTRA CHARACTERS
; SEC
; LDA COLUMN_POSITION
; SBC LINE_LENGTH
; STA FIRST_WRAP_POINT    ;AND SET IT FOR CURSOR WRAP
;
?BREAK_PT: 
 STA (BUILD),Y           ;PLACE SRET INTO BUILD
 INY                     ;BUMP AROUND
 TYA
 CLC
 ADC BUILD
 STA BUILD
 BCC ?INCB_HI
 INC BUILD+1
?INCB_HI:                ;PREPARE TO ALLOW WORD 
; 
 LDA RETURNS_ENCOUNTERED ;IF WE ARE IN EDIT_LINE, THIS IS ZERO
 BNE ?BUMP_TEXT_IN_TEXT
 INC RETURNS_ENCOUNTERED
 JSR CURSORP_TO_TEXT 
 JSR TEXT_TO_NEXTLINE    ;SET TEXT AT START OF 2ND LINE
; INC RETURNS_ENCOUNTERED
 JMP ?NEW_LINE
;
?BUMP_TEXT_IN_TEXT:
 TYA
 CLC
 ADC TEXT
 STA TEXT
 BCC ?INCT_HI
 INC TEXT+1
?INCT_HI: 
;
 JMP ?NEW_LINE
;
;
P2_TO_TEXT_X_Y:
;
 TXA
 PHA            ;SAVE ODD BYTES ON STACK
 TYA            ;# PAGES TO MOVE
 BEQ ?BYTES     ;IF NONE, GO TRY ODD BYTES
;
 TAX            ;.X = # PAGES
 LDY #$FF       ;DO ALL PAGE
 JSR ?MOVE_LOOP ;MOVE PAGES 
; 
?BYTES: 
 PLA            ;# ODD BYTES
 LDX #1
; BEQ ?DONE      ;NONE TO MOVE
;
 TAY            ;# BYTES TO MOVE .Y
 BEQ ?LAST_BYTE
;
?MOVE_LOOP:
 LDA (POINTER2),Y	;GET FROM SOURCE
	STA (TEXT),Y	   ;MOVE TO DESTINATION
	DEY	
	BNE ?MOVE_LOOP
;
?LAST_BYTE:
 LDA (POINTER2),Y 	;GET FROM SOURCE
	STA (TEXT),Y 	   ;MOVE TO DESTINATION
 INC POINTER2+1
 INC TEXT+1 
 DEX
 BNE ?MOVE_LOOP
?DONE:
 RTS 
; 
;------------------------------------------------------------- 
;
SET_FONT_STYLE:
UPDATE_ATTRIBUTES_CR:
;
;DO NOT HARM .Y !
 CMP #ENDREC
 BCS UP_ATT_ABT
;
 LDX EDIT_LINE           ;DO NOT HONOR ATTRIBUTE/STYLE CHANGE
 CPX #122                ;ON A CHECKMARK LINE
 BEQ UP_ATT_ABT
;
 CMP #TABCHAR		;IS THIS A TAB?
 BNE ?CHECK_STYLE	;BIF NOT TO CHECK STYLE
;
 LDX JUSTIFY_FORMAT
 BNE UP_ATT_ABT
 LDX CURRENT_FONT	;WE ONLY DO NEAT THINGS IN TEXT MODE
 BPL UP_ATT_ABT		;SO LEAVE UNHARMED IF IN FONT MODE
;
 JSR FIND_TAB_GT_ACT_COL
 BEQ ?NO_TAB			;BEQ NO_TAB, BCS TAB_FOUND
;
;
?TAB_FOUND:
 STA ACTUAL_COLUMN
;*DEBUG*
 JMP ?TEMP_LBL
;
;
?NO_TAB: 
 INC ACTUAL_COLUMN
?TEMP_LBL:
 LDA #TABCHAR			;RESTORE CHAR WE CAME IN WITH
 RTS
;
?CHECK_STYLE:
 JSR IS_STYLE_CODE
 BCS CHECK_SET_FONT
;
 JMP SET_STYLE
;
CHECK_SET_FONT:
 LDX CURRENT_FONT
 BMI UP_ATT_ABT
;
 JSR IS_FONT_CODE
 BCC UP_ATT_ABT          ;CC=NOT FONT CODE
;CS
CONV_AC_SET_FONT:
 SBC #'1'+$80
 BPL SET_FONT
 LDA #9 
;
SET_FONT:
 STA CURRENT_FONT
;
POINT_AXPT_UPDATE_FBASE:
 TAX                     ;SET FLAGS FOR TEXT MODE TEST
 BMI UP_ATT_ABT          ;
;
 JSR POINT_AXPT_AT_FONT
 STA FONT_BASE           ;THIS IS THE ONLY PLACE ALLOWED TO
 STX FONT_BASE+1         ;UPDATE CURRENT FONT ADDRESS
 STA FONT_BASE_SM1
 STX FONT_BASE_SM1+1     ;UPDATE FOR SPEED OF LINE LENGTH 
 STA FONT_BASE_SM2
 STX FONT_BASE_SM2+1 
; 
 LDY #FONT_TWO-FONT_ONE-2-13 ;POSITION OF POINTSIZE
 LDA (FONT_BASE),Y       ;GET POINSIZE
 STA CURRENT_POINTSIZE   ;MUST EXIT .A CURRENT PTS
;
UP_ATT_ABT:
 RTS
;
;
UPDATE_ATTRIBUTES_CL:
;
 CMP #ENDREC
 BCS UP_ATT_ABT
;
 LDX EDIT_LINE           ;DO NOT HONOR ATTRIBUTE/STYLE CHANGE
 CPX #122                ;ON A CHECKMARK LINE
 BEQ UP_ATT_ABT
;
 CMP #TABCHAR		;ARE WE ON A TAB?
 BNE ?CHECK_STYLE	;IF NOT, TRY A STYLE CHAR
;
 LDY JUSTIFY_FORMAT	;NEED LEFT JUSTIFICATION
 BNE UP_ATT_ABT
;
 LDY CURRENT_FONT	;WE ONLY DO NEAT THINGS IN TEXT MODE
 BPL UP_ATT_ABT		;SO LEAVE UNHARMED IF IN FONT MODE
;
 INY			;[0]
 STY CUR_LEFT_FLAG_RESULT1
;
 LDA CURRENT_CHAR	;POSITION OF THE TAB CHAR
 STA CLL_INTERRUPT_POINT;FOR LINE_LENGTH RESULT
;*NOTE* WHY?
 DEC CLL_INTERRUPT_POINT;THIS *IS* NEEDED HERE, BUT NOT IN SUPPORT EQULIV
;
 JSR CALCULATE_LINE_LENGTH1	;CALL CLL AND SET CLFR TO POS TO LEFT OF TAB
;
 LDY #$FF
 STY CLL_INTERRUPT_POINT
;
 LDY #0				;NO VALID RUN FOUND
;
 LDX CURRENT_CHAR
 BEQ ?TEST_RUN
;
 DEX				;LOOK FOR RUN OF HI-BIT SET WITHOUT
?HCTB_LOOP:
 LDA EDIT_LINE,X		;A TAB, AND WATCH OUT .X = 0
 BPL ?TEST_RUN
 CMP #TABCHAR
 BEQ ?TAB_FOUND
 LDY #1				;VALID RUN FOUND
 DEX				;NEXT CHAR
 BPL ?HCTB_LOOP
 TYA				;[1]
 BNE ?NORM_CHAR			;FORCE TO ONE AT SOL 
; 
?TAB_FOUND:
 LDY #0
?TEST_RUN:
 CLC
 TYA				;0 = NO OFFSET, 1 = OFFSET
 ADC CUR_LEFT_FLAG_RESULT1
?NORM_CHAR:
 STA ACTUAL_COLUMN
?NO_RESULT:
 JMP ACTUAL_COLUMN_OUT
;
?CHECK_STYLE:
 JSR IS_STYLE_CODE
 BCS ?CHECK_FONT
;
 JMP FIND_PREV_STYLE 
;
?CHECK_FONT:
;
 JSR IS_FONT_CODE
 BCC UP_ATT_ABT          ;CC=NOT FONT CODE
;CS
 SBC #'1'+$80
 BPL ?SKP
 LDA #9 
?SKP:
;
 JMP FIND_PREV_FONT
;
;
IS_STYLE_CODE:
 LDX #0
?LOOP:
 CMP EMBEDDED_CODES,X
 BEQ ?CODE_FOUND
 INX
 CPX #16
 BCC ?LOOP
 RTS                  ;CS-NOT CODE
;
?CODE_FOUND:
 CLC                  ;CC- FOUND .X = CODE
 RTS
;
SET_STYLE:
;ATTRIBUTE BYTE:
;BLD,ITL,US1,US2,US3,SUP,SUB,UND
;
 TXA            ;CHAR 0..15
 AND #1
 BNE STYLE_OFF
;
 TXA
 LSR A
SET_STYLE_ON:
 TAX
 LDA ATTRIBUTES
 ORA ATT_ON_TABLE,X
SET_STYLE_A:
 STA ATTRIBUTES
;
 LDX CURRENT_CHAR
 BNE ?NO_START_CHANGE 
;
 STA START_LINE_ATTRIBUTES  ;SET 1ST CHAR ATTRIBUTES
;
?NO_START_CHANGE:
;ATTRIBUTES_TO_BOLD_ON:
; ROL A                ;BOLD BIT IN CARRY
; LDA #0
; ROL A                ;BIT0 = 1 IF BOLD IS ON
; STA CHAR_WIDTH_ADJUST
; STA $404
;
 RTS
;
STYLE_OFF:
 TXA
 LSR A
 TAX
 LDA ATTRIBUTES
 AND ATT_OFF_TABLE,X
 JMP SET_STYLE_A
;
;
IS_FONT_OR_BOLD:
 JSR IS_FONT_CODE
 BCS IFOB_YES       
;
 CMP #TABCHAR
 BEQ IFOB_SET_YES 
;
IS_BOLD:
 CMP #'B'+$80
 BEQ IFOB_SET_YES
 CMP #'B'-'@'+$80 
 BEQ IFOB_SET_YES
 CLC                  ;CLC NO
 RTS
;
IFOB_SET_YES:
 SEC                  ;SEC YES
IFOB_YES:
 RTS
;
;
IS_FONT_CODE:
;CS=YES CC=NO
;
 CMP #'9'+$80+1
 BCS ?NOT_CODE
 CMP #'0'+$80
 RTS               ;[CS]
?NOT_CODE:
 CLC
?NOT_CODE1:
 RTS
;
PTS_AND_DESCEND:
 JSR POINT_AXPT_AT_FONT
SET_PTS_AND_DESCEND:
 LDY #FONT_TWO-FONT_ONE-1-13
IPTY_INTO_AX:
 LDA (POINTER),Y
 TAX
 DEY
 LDA (POINTER),Y
PTS_RTS:
 RTS
;
POINT_AXPT_AT_FONT:
;.A IS FONT 0,1,2,3  .Y DESTROYED
; TAY                        ;SET FLAGS FROM .A
; BMI PTS_RTS                ;NOT IN TEXT MODE
 ASL A                      ;.A *=2
 TAY
 LDX FONT_TABLE+1,Y
 LDA FONT_TABLE,Y
 JMP AX_INTO_PT
;
;
FIND_PREV_FONT:
;
 LDA CURRENT_FONT
 BMI PTS_RTS
;*NOTE* WHAT IS THIS ABOUT?
 LDA BLKSET
 BNE PTS_RTS
;
 JSR TEXT_INTO_AX
 JSR AX_INTO_PT
;
 LDY CURRENT_CHAR
 BEQ ?SEARCH_BACK
 DEY
?LOOP:
 LDA EDIT_LINE,Y
 BMI ?F_CODE
;
?JOIN:
 DEY 
 BPL ?LOOP
; 
?SEARCH_BACK:
;
?OUT_LOOP:
 DEC POINTER+1
 LDY #$FF
?LOOP1:
 LDA (POINTER),Y
 BPL ?SKP2
 CMP #ENDT
 BEQ ?BEG_OF_TEXT
 JSR IS_FONT_CODE
 BCS ?FOUND_FONT
?SKP2:
 DEY
 CPY #$FF
 BNE ?LOOP1
 BEQ ?OUT_LOOP
;
?F_CODE:
 JSR IS_FONT_CODE
 BCS ?FOUND_FONT
 BCC ?JOIN
;
?BEG_OF_TEXT:
;
 JMP SET_START_OF_TEXT_FONT
;
?FOUND_FONT:
;SEC
 SBC #'1'+$80
 BPL ?FNT10
 LDA #9 
?FNT10: 
 JSR TEST_FOR_CHECK
 BCS ?OUT_LOOP              ;NO! CM FOUND, TRY AGAIN
 JMP SET_FONT               ;SET FONT TO NEW PREVIOUS FONT    
;
TEST_FOR_CHECK:
 PHA
 JSR INC_PT_BY_Y
 DEC POINTER+1              ;LOOK BACK THRU UP TO 255 B
 LDY #0                     ;ACTUALLY STARTS $FF
?LOOP:
 DEY
 LDA (POINTER),Y
 BPL ?LOOP                  ;FASTEST POSSIBLE LOOK BACK
 CMP #ENDT
 BCC ?LOOP                  ;VALIDATE RETURN
 INY                        ;MOVE TO 1ST CHAR OF LINE
 BEQ ?NOT_CM_LINE           ;IF .Y = 0 ASSUME NO CHECK!     
; 
 LDA (POINTER),Y
 CMP #$7A                   ;CHECK MARK?
 BNE ?NOT_CM_LINE
 JSR INC_PT_BY_Y            ;POINT POINTER AT CM
 PLA
 SEC                        ;FLAG CM LINE FOUND
 RTS                       
;
?NOT_CM_LINE:
 PLA
 CLC
 RTS
;
FIND_PREV_STYLE:
;
 TXA
 AND #$FE                   ;KILL 0 BIT
 TAX                        ;BECOME INDEX TO EMBEDDED_CODES
;
 LDY CURRENT_CHAR
 BEQ ?SEARCH_BACK
 DEY
?LOOP:
 LDA EDIT_LINE,Y
 BPL ?SKP
;
 CMP EMBEDDED_CODES,X
 BEQ ?FOUND_STYLE
 CMP EMBEDDED_CODES+1,X
 BEQ ?FOUND_STYLE_1
?SKP:
 DEY
 CPY #$FF
 BNE ?LOOP                  ;HANDLES EMBEDDED CODES ON LINE WE'RE ON
?SEARCH_BACK:
 TXA
 TAY                        ;.X IS INDEX, SAVE IN.Y
;
 JSR TEXT_INTO_AX
 JSR AX_INTO_PT
 TYA
 TAX                        ;RESTORE .X
?OUT_LOOP:
 DEC POINTER+1
 LDY #$FF
?LOOP1:
 LDA (POINTER),Y
 BPL ?SKP1
 CMP #ENDT
 BEQ ?FOUND_STYLE_1
 CMP EMBEDDED_CODES,X
 BEQ ?FOUND_STYLE
 CMP EMBEDDED_CODES+1,X
 BEQ ?FOUND_STYLE_1
?SKP1:
 DEY
 CPY #$FF
 BNE ?LOOP1
 BEQ ?OUT_LOOP
;
?FOUND_STYLE_1:
 INX                  ;OFF STYLE FOUND
?FOUND_STYLE:
 JMP SET_STYLE
;
;
FIND_PREV_MARGIN:
;
 LDA EDIT_LINE+1
 AND #$3F
;
FIND_PREV_A:
 STA TEMP
 CMP #'M'-64
 BEQ ?SEARCH_NEW_CM	;THIS IS MARGINS
 CMP #'S'-64
 BEQ ?SEARCH_NEW_CM   	;THIS IS LEADING
 CMP #'E'-64
 BEQ ?SEARCH_NEW_CM	;THIS IS EXPANDED
 JSR IS_LRCJ
 BNE ?ABORT           	;NOT MARGIN, SPACING, OR LRCJ
 LDY #0			
 STY TEMP
;
?SEARCH_NEW_CM:
 JSR PUSH_TEXT
?MLOOP:
 JSR TEXT_TO_PREV_LINE
; LDY #0
; LDA (TEXT),Y
; CMP #ENDT
 JSR TEXCF0
 BEQ ?DEF_MARGINS     ;FOUND START OF TEXT...
;
 CMP #CMARK
 BNE ?MLOOP
 INY
;
 LDA (TEXT),Y
 AND #$3F
 CMP TEMP             ;IS THIS THE EFFECTED CODE?
 BEQ ?MSE_FOUND
;
 LDX TEMP		;IS THIS LOOKBACK FOR MARGINS?
 BNE ?MLOOP		;IF NOT, GO BACK
 JSR IS_LRCJ
 BNE ?MLOOP		;NOT A MARGIN!
;
?MARGIN:
 JSR CHANGE_JUSTIFICATION
 JMP ?MAR_SET
;
?MSE_FOUND: 
 JSR PROCESS_MARGINS
 JMP ?MAR_SET
;
?DEF_MARGINS:
 LDA #0               	;PREPARE TO "OFF"
 STA JUSTIFY_FORMAT 	;SET TO LEFT
;
 LDX TEMP             	;WHAT DIDN'T WE FIND LOOKING BACK
 CPX #'M'-64
 BEQ ?MAKE_M_DEFAULT
 CPX #'E'-64
 BEQ ?MAKE_E_DEFAULT
;
;MAKE_S_DEFAULT:
 STA USER_DEFINED_LEAD   ;DEFAULT LEADING
 STA FONT_LEADING        ;DEFAULT LEADING
 LDA CURRENT_FONT
 BPL ?MAR_SET 
 JSR SET_BIG_AND_CURRENT ;SET TO 1       
 STA NEW_LINE_SPACE
 BNE ?MAR_SET            ;BRA, INC OF 0 TO 1
;*NOTE* THIS CAN BE JUST POP_TEXT
;
?MAKE_E_DEFAULT: 
 STA EXPAND_ON 
 LDA USER_DEFINED_LEAD   ;& LEAD IS NOT EXPANDED
 STA FONT_LEADING 
 JMP ?MAR_SET            ;BRA
;*NOTE* THIS CAN BE JUST POP_TEXT
; 
?MAKE_M_DEFAULT 
 JSR SET_MARGIN_ONLY
;
?MAR_SET
 JMP POP_TEXT
;
?ABORT:
 RTS 
;
;
PART_LINE_LENGTH:
 LDA #0
 STA LINE_LENGTH
 STA LINE_LENGTH+1
 STA INTER_WORD_GAPS
 STA FIRST_CHARACTER_FOUND
;
?LOOP:
 LDA (TEXT),Y
 STY FONT_WORK
 BMI ?SKP2
;
 LDY FIRST_CHARACTER_FOUND
 BNE ?ALREADY_PAST_FIRST
 INC FIRST_CHARACTER_FOUND
 LDY CURRENT_FONT
 STY FIRST_CHARACTER_FONT 
;
?ALREADY_PAST_FIRST:
;
 LDY PL_JUSTIFICATION
 BEQ ?REG_CHAR
;
 CMP #' '          ;IS THIS A SPACE?
 BNE ?RESET_FLAG   ;INDICATE NOT SEARCHING THRU SPACES
;
 INC INTER_WORD_GAPS
;
?RESET_FLAG:       ;FOUND NS, MUST BE 
;
?REG_CHAR:
 JSR LL_PLUS_FONTB_A
;
?END_LINE:
 LDY FONT_WORK
 INY
 CPY LAST_LINE_CHAR
 BNE ?LOOP
;
 LDA CURRENT_FONT
 STA LAST_CHARACTER_FONT 
; 
 RTS
;
?SKP2:
;            
 JSR SET_UNSET_BOLD
 BEQ ?END_LINE           ;BEQ MEANS BOLD WAS HANDLED
;
 JSR CHECK_SET_FONT
 JMP ?END_LINE
;
;
SET_START_OF_TEXT_FONT:
;
 LDA STARTRAM		;IS THE FIRST VALID CHARACTER OF TEXT
 JSR IS_FONT_CODE	;A FONT CODE (THERE MAY BE A SYSTEM)
 BCS ?FCODE_FOUND	;MARK AT START OF TEXT, SO CHECK
 LDA STARTRAM+1		;TWO BYTES
 JSR IS_FONT_CODE
 BCC ?DEF_FONT
;
?FCODE_FOUND: 
 JMP CONV_AC_SET_FONT
; 
?DEF_FONT: 
 LDA #USE_DEFAULT_FONT
 JMP SET_FONT
;
;
 END                                             
;
