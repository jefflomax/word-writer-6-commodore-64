;  
 TITLE THESAURUS REX
 PW 91
;
.INCLUDE WWSETUP.ASM
;
;TIMEWORKS 6502 THESAURUS--COMMODORE SPECIFIC, USES DIRECT TRACK-
;	SECTOR ACCESS ON 1541 *ONLY*
;	(C)1987 TIMEWORKS -- JEFF LOMAX
;
;
;   GENERAL CALLING SEQUENCE:
;	BE SURE CLSNUM IS ZERO  
;	CALL ROUTINE (THESAURUS) WITH APPROPRIATE POINTER TO WORD
;		IF (CS) THEN THE WORD WAS NOT FOUND  
;		IF (CC) THEN  
;   			PROGRAM WILL RETURN WITH WORD IN WORD BUFFER
;			.X = CLUSTER NUMBER
;   
;			MAKE REPEATED CALLS UNTIL (CS) INDICATING 
;			LAST WORD XMITTED.       
;
;			WATCH .X CAREFULLY FOR CLUSTER NUMBER CHANGES 
;
;  		DURING CALLS, NEVER HARM:               
;      			MAXWOR   LINDEX   DEVICE   NUMLET 
;      			TEMPOR+1 LEN
;
;
 PUBLIC THESAURUS,NUMLET 
 PUBLIC THESAURUS_DRIVE
;
 EXTERN WORD   ;BUFFER WORD WORD     VARIABLS  
 EXTERN CHKOUT ;OUT CHANNEL          WINDOW
 EXTERN CHROUT ;OUT CHARACTER        WINDOW 
 EXTERN CHNL2I ;LDX #2, JSR CHKIN    PART2
 EXTERN CLR_CHNL2I ;		     PART2
 EXTERN CLALL  ;CLEAR ALL CHANNELS   WINDOW
 EXTERN CLOSE2 ;DATA
 EXTERN CLOSE15;DATA
 EXTERN CLOSE  ;CLOSE A CHANNEL      WINDOW  
 EXTERN CLRCHN ;RESET DEFAULT        WINDOW
 EXTERN CLSNUM ;                     VARIABLS 
 EXTERN CHRIN
 EXTERN GETIN  ;                     WINDOW  
 EXTERN INIDSK ;OPEN 15,?,15         DATA   
 EXTERN OPEN
 EXTERN SETNAM
 EXTERN SETLFS        
 EXTERN SPACE_OUT ;		     WINDOW
 EXTERN OPNDIC ;OPEN 2,8,2,          DATA   
; 
RETRNA:         EQU $4F ;$50
BIIT:           EQU $51 
BITBIN:         EQU $52 
BITROT:         EQU $53 
;
;
;NEEDS:
;* CHECK ERROR FLAG (CS) AFTER ALL INBITS/INLETT      
;* CHECK IF DISKETTE IS T-DISK, AFTER OPENS    
;* COMPRESS WORD LENGTH S/B 1 LESS
;* CHANGE ALL WORD REFERENCES TO ABSOLUTE    
;* PATCH IN WW'S WINDOW ROUTINES CHROUT, ETC  
;
; THESAURUS EQUATES/VARIABLES 
;
CSIZE  EQU 12 ;NUMBER OF BITS IN A CLUSTER NUMBER             
WPLEN  EQU 17 ;NUMBER OF BITS IN A POINTER TO CLUSTER        
BC     EQU 17 ;LARGEST POSSIBLE CLUSTER SIZE
;
;VARIABLES
;
P1     DS  $2
T1     DS  $1  ;TEMPOROARY USED FNDLT1,INBITS,
NUMLET DS  $1  ;LENGTH OF WORD, NUMBER OF CLUSTERS
LEN    DS  $1  ;
SO     DS  $2  ;{ SECTOR OFFSET
PO     DS  $1  ;} POSITION IN SECTOR  
TRACK  DS  $1  ;ACTUAL TRACK OF DRIVE
SECTOR DS  $1  ;ACTUAL SECTOR OF DRIVE
MAXWOR DS  $1  ;NUMBER OF WORDS/CLUSTER THIS REGION        
MP1    DS  $3  ;THREE BYTE VALUE FOR MATH #1 (2 SIG)
;
MP2    DS  $1  ;ONE BYTE POINTER FOR MATH #2   
;
LINDEX DS  $1  ;POINTS TO NEXT LETTER'S SO,PO IN LETTER
;
TEMPOR DS  $3  ;THREE BYTE TEMPORARY FOR MATH     
BIIIT  DS  $1  ;BIT OFFSET IN SECTOR    
T2     DS  $1  ;TEMPORARY USED INBITS,
RESULT DS  $3  ;MORE THREE BYTE MATH STUFF
WSO    DS  $2  ;{ SO OF CURRENT WORD POINTING TO
WPO    DS  $1  ;} PO OF CURRENT WORD POINTING TO                       
T3     DS  $1  ;TEMPORARY USED SENDASC,
T4     DS  $1  ;TEMPORARY USED SENDASC,  
T5     DS  $1  ;TEMPORARY USED SENDASC,
;
;
;SYSTEM EQUATES/VARIABLES       
;
STATUS EQU $90
;
;EXAMPLE CALL MODULE
;
; LDA #0
; STA WNDX ;CLEAR POINTER     
; STA CLSNUM
;
;
;
THESAURUS:
;
 JSR FLUSH ;CLEAR BITBIN
 STA WNDX ;[0]       
;
;GO OFF TO PRESENT WORD IF ALREADY IN LOOKUP MODE   
 LDA CLSNUM
 BEQ LOOKUP ;LOOK UP THE WORD OR     
 JMP PRESENT ;PRESENT WORDS   
;
;
LOOKUP:  
;ASSUME WORD IS AT WORD WITH NULL TERMINATOR      
;         
 JSR INIDSK 		;OPEN 15,?,15,"I0"  
;
 LDA #1
 LDX #<CHANNEL
 LDY #>CHANNEL
 JSR OPNDIC 		;OPEN2,?,2,"#"
;
;VERIFY THESARUS DISK PRESENT
 LDA #18
 STA TRACK
 LDA #0
 STA SECTOR
 LDA #144
 STA PO
 JSR RSECTOR
 JSR POSITON
 LDA #16
 JSR INBITS
 CMP #'H'
 BNE JMWNF
 LDA RETRNA+1
 CMP #'T'
 BNE JMWNF
;                                                     
;
 JSR FLUSH
; 
 JSR WSTARTT 	;SET START OF TRACK FOR WORD FILE
;
 LDY #0
 LDA WORD,Y 	;RETRIEVE FIRST CHARACTER 1..26 (ASSUME "PERFECT" WORD)       
 CMP #'Z'-$40
 BNE ?OK 
 CMP WORD+1,Y
 BEQ JMWNF
; 
?OK:
 SEC
 SBC #1 	;IF 1..26 -> 0..25              
 STA T1  
 ASL A 		;.A * 2
 ADC T1
;
 TAX 		;X CONTAINS INDEX TO LETTER TABLE (SO,PO)   
;
;LOOK UP EITHER BY 1ST LETTER IF ?..?N OR FROM ?O..?Z 
;
 INY 		;[1]
 LDA WORD,Y
 BNE SECNDOK
JMWNF:
 JMP WNF 	;IF SECOND LETTER IS END, WE QUIT!   
;
SECNDOK:
 CMP #'O'-64 
 BCC USEFRS 	;USE FIRST LETTER, ?A..?N          
;THIS IS ?O..?Z WE WILL USE LETTEO TABLE      
 LDA LETTEO,X 
 STA SO
 INX 
;
 LDA LETTEO,X
 STA SO+1
 INX 
;
 LDA LETTEO,X ;LOCATE SO, PO AT START OF LETTER       
 STA PO
 JMP USEDSEC
;
USEFRS:
;USE ?A..?N TO FIND WORD (LETTER)
 LDA LETTER,X 
 STA SO
 INX 
;
 LDA LETTER,X
 STA SO+1
 INX 
;
 LDA LETTER,X ;LOCATE SO, PO AT START OF LETTER       
 STA PO
;
USEDSEC:
 INX
 STX LINDEX
;
 JSR READSEC ;USE U1 TO READ SECTOR 
 JSR POSITON ;SET BUFFER POINTER FOR WORD
;          
SEARCHW:
 LDA SO
 STA WSO 
 LDA SO+1
 STA WSO+1
 LDA PO
 STA WPO 	;HOLD POSITION OF CURRENT WORD
;
 LDX LINDEX 	;GET LETTER INDEX
 LDA SO   
 CMP LETTER,X 
 BNE SEARCH1 	;OK, DO SEARCH  
 LDA SO+1
 CMP LETTER+1,X 
 BNE SEARCH1 	;SO'S DIFFERENT, DO SEARCH   
 LDA PO ;CHECK PO
 CMP LETTER+2,X ;DIFFERENT?
 BEQ WNF 	;NO! THE WORD IS NOT FOUND 
;
SEARCH1:
;
 LDA #4 	;SIZE OF [WORDLEN]
 JSR INBITS 	;READ 4 BITS FROM INPUT CHANNEL
 TAX
; .X = NUMBER OF CHARACTERS -1 IN WORD
; 0 = 1 CHAR, WITH 1ST LETTER OMITTED, TOTALS 2.   
; INX ;0=1 TO READ
; S/B COMPRESSED FOR 1 LESS ON LENGTH
;
 STX NUMLET 	;NUMBER OF LETTERS
 LDY #1 	;SET UP TO 2ND CHAR AND THRU WORD    
;
NXTCHR:
;
 JSR INLETT 	;READ 2ND LETTER
;
; HANDLE DOUBLETS/SPACE/QU    
;
 BNE NXTCHR1 	;IF THIS IS ZERO, SUBSTITUTE
;
 LDA #' ' 	;A SPACE AND CHECK
 CMP WORD,Y
 BEQ SAMECR
 BNE WLESS
;
NXTCHR1: 
 CMP #'Q'-64 	;IS THE Q (QU)?
 BNE NXTCHR2
;
 LDA #5 	;QU FLAG  
 BNE NXTCHR3 	;TREAT AS DOUBLET     
;
NXTCHR2:
 CMP #27 	;IS THIS 1..26
 BCC NXTCHR4 	;TREAT AS NORMAL LETTER
 SBC #27 	;MAKE # 0..4 FOR DOUBLETS  
NXTCHR3: 
 JMP TLETVER 	;VERIFY APPROPRIATE TWO LETTER 
;
NXTCHR4:
;
 CMP WORD,Y
 BEQ SAMECR
 BCC WLESS 	;TARGET WORD < DISK DATA  
;TARGET WORD > DISK DATA
;
; WORD NOT FOUND             
;                        
WNF: 
; LDA #2
; JMP TEXIT
;SHOULD BE JSR CLOSEAL
 JSR CLEARF     
 SEC ;EXIT WITH CARRY SET.
 RTS
;
SAMECR:
 DEC NUMLET
 LDA NUMLET
 BEQ DSKOUT ;THE DISK IS OUT OF CHARACTERS             
 INY        ;MOVE TO NEXT MEMORY CHAR
 LDA WORD,Y
; BEQ MEMOUT ;THE MEMORY IS OUT OF CHARACTERS
 BNE NXTCHR ;GO TRY THE NEXT CHARACTER
; RE-ORDER BRANCH    
MEMOUT:
; THE MEMORY IS OUT OF CHARACTERS, THE DISK IS NOT.
; THIS MEANS THE WORDS DO NOT MATCH HERE.  WE CAN ASK
; THE USER IF THIS WORD IS OK, OR WE CAN TRY SOME SUFFIX
; ANALYSIS/DELETION.
; 
; LDA #3
; JMP TEXIT 
 JMP WNF ;FOR NOW, WORD NOT FOUND 
;
DSKOUT:
; THE DISK DRIVE HAS RUN OUT OF CHARACTERS IN THIS WORD.
; IS THE MEMORY ALSO OUT?
 INY
 LDA WORD,Y
 BNE MEMCHR ;NO THE MEMORY STILL HAS CHARACTERS.
;
; THE DISK AND THE MEMORY ARE BOTH OUT OF CHARACTERS
; WE HAVE A WINNER!!!
;
 JMP EVALCL ;WORD IS FOUND!!!
;
MEMCHR:
; THE DRIVE IS OUT OF WORD AND THE MEMORY IS NOT
; GO TO NEXT WORD.
; JMP NXTWORD                
;
WLESS:
; THE TARGET WORD IS GREATER THAN THE DISK WORD
; GO TO THE NEXT WORD.
; JMP NXTWORD
;      
NXTWORD:
;
NXTWORD1:
;MAY EMPLOY FAST NEXT WORD ROUTINE TO ALLOW FOR BYTE
;READ (AFTER CURRENT BIT-BUFFER IS DEPLETED)            
;FOR NOW, SIMPLE INBITS.
;
 DEC NUMLET 
 LDA NUMLET
 BMI NXTW2 ;JUST BE SAFE, DO NOT PULL MILLIONS       
 BEQ NXTW2 ;THERE ARE NO MORE DISK LETTERS
;
NXTW1:  
;
 JSR INLETT ;READ ALL REMAINING LETTERS
 DEC NUMLET         
 BNE NXTW1    
;
NXTW2:
 LDA #4
 JSR INBITS
;
 STA NUMLET ;NUMBER OF CLUSTERS.
 INC NUMLET ;0..15 -> 1..16
NXTW3:
 LDA #CSIZE  
 JSR INBITS
 DEC NUMLET
 BNE NXTW3  
;        
 LDA BIIT ;THESE ARE EXACTLY THE        
 BEQ NXTW4         
;
;NUMBER OF BITS IN THE BUFFER.  
 JSR INBITS
NXTW4:
;
;IT WOULD BE FASTER HERE TO SIMPLY ZERO
;BIIT AND CALL THE APPROPRIATE ROUTINES TO 
;BUMP UP PO    
;   
 JMP SEARCHW ;GO LOOK AT THE NEXT WORD THEN
;
CPFIL1:
 LDA #4
 JMP TEXIT
;
EVALCL:
;WORD FOUND, FILL TABLE OF CLUSTER POINTERS                         
;
;EVALUATE THE CLUSTER INFORMATION  
;
 LDA #4
 JSR INBITS ;RETRIEVE # OF CLUSTERS
;
 TAX
 INX ;0..15 -> 1..16 (MIN 1 S/B 2..17)                       
 STX NUMLET ;NUMLET = NUMBER OF CLUSTERS
 STX LEN ;SAVE #CLUSTERS IN PO
;
 LDA #0 ;CLEAR TEMPOR FOR
 STA TEMPOR ;INDEX TO POINTER TABLE    
;
CPFILL:
 LDA #CSIZE ;SIZE IS 13 (S/B 12) BITS    
 JSR INBITS
 BCS CPFIL1 ;ERROR ON READ
;
 LDX TEMPOR           
 STA CDATA,X
 LDA RETRNA+1
 INX
 STA CDATA,X
 INX
 STX TEMPOR 
; 
 DEC LEN ;LEN = NUMLET DEC TO FILL TABLE
 BNE CPFILL ;FILL UP CDATA TABLE     
;
;
;BEGIN LOOP TO:
;1) CALCULATE POINTER POSITIONS      
;2) FILL POINTER TABLES AND
;3) PRESENT WORDS
;   (NUMLET COUNTS DOWN) 
;
 LDA #0 
 STA LEN ;SET INDEX TO START OF CDATA TABLE
;
MAINCL: 
;MAIN CLUSTER/WORD PRESENTATION LOOP
;
 LDX CLSNUM
 CPX NUMLET
;BEQ MAINCL1       
 BCC MAINCL1 ;NOT DONE
 JSR CLEARF ;END FILE 
;[CS] ON FINAL EXIT     
 SEC
 LDX #0
 RTS ;ALL DONE !!!!
;
;
MAINCL1:
 LDX LEN  
 LDA CDATA,X 
 STA P1    
 INX
 LDA CDATA,X
 STA P1+1
 INX
 STX LEN ;WHICH CLUSTER # TO LOOP ON             
;
 INC CLSNUM ;CLUSTER # [1..N] BEING PRESENTED                             
;
 JSR FINDLOC ;RETURN SEEK CLUSTER, MAXWOR = #CHARS
;
 LDX #0 
 STX TEMPOR ;BUMP UP BY TWO'S THRU SO TABLE
;
WPFILL:
;FILL UP SO,PO TABLES OF WORDS FOR THIS CLUSTER     
 LDA #9
 JSR INBITS ;.X IS SAFE THRU
 LDY TEMPOR  
 STA PSODATA,Y ;SO OF XTH WORD      
 INY
 LDA RETRNA+1
 STA PSODATA,Y ;SO (HI) OF XTH WORD
 INY
 STY TEMPOR ;SET TO NEXT POSITION
;
 LDA #8
 JSR INBITS
;
 STA PPODATA,X ;PO OF XTH WORD
 INX ;0..(MAXWOR-1)
 CPX MAXWOR
 BCC WPFILL ;FILL WORD POINTER TABLE
;
;SEND 1ST WORD TO WORD,Y
;
 LDY #0   
 STY TEMPOR ;INIT 1ST PASS   
;
PRESENT: 
;WORD-LOOP FROM JUMP
;
 LDA TEMPOR
 PHA
 TAX
 LDA PSODATA,X
 STA SO 
 INX                                          
 LDA PSODATA,X 
 STA SO+1
 INX
 STX TEMPOR
 PLA
 LSR A ;INDEX FOR OTHER TABLE  
 TAX
 LDA PPODATA,X
 STA PO ;GET WORD POSITION F/TABLE  
;
;
 CPX MAXWOR       
;BEQ WPFILE0
 BCC WPFILE0
;
 JMP MAINCL ;PRESENT THE REST OF THE CLUSTERS             
;
;
;SET SO, PO
WPFILE0:
;
 JSR FND1LT ;WHAT IS 1ST LETTER?
 BCS PRESENT ;SAME AS LAST CALL WORD, TRY NEXT
 JSR PUTCHAR ;PLACE CHAR IN WORD BUFFER
;        
 JSR FLUSH ;CLEAN OUT BITBIN FOR NEXT READ
;
 JSR WSTARTT ;SET TRACK, SECTOR ON START OF WORD FILE
;
 JSR READSEC ;READ SECTOR SO TO FIND WORD
;
 JSR POSITON ;POSITION AT WORD (LENGTH,FIELD...)
;
 LDA #4
 JSR INBITS
 STA TEMPOR+1 ;TEMPOR+1 IS LENGTH    
; 
WPFILE1:
 JSR INLETT ;GET A LETTER FROM DISK
 BNE WPFILE2 ;            
 LDA #' ' ;WE HAVE A SPACE! 
 BNE WPFILE4 ;DO NOT FALL THRU, WILL BE "DOUBLET"  
;
WPFILE2: 
 CMP #'Q'-64 ;IS THIS Q CODE?  
 BNE WPFILE3
 JSR PUTCHAR ;PUT OUT THE Q
 LDA #'U'-64
;
WPFILE3:
 CMP #27   
 BCC WPFILE4 ;NORMAL LETTER 
 SBC #27 
 ASL A ;MAKE INDEX TO DOUBLET TABLE
 TAX        
 LDA DOUBLETS,X
 JSR PUTCHAR 
 LDA DOUBLETS+1,X
;
WPFILE4: 
 JSR PUTCHAR
;
 DEC TEMPOR+1
 BNE WPFILE1
;
 LDA #0 
 JSR PUTCHAR 
 LDX CLSNUM
 CLC
 RTS
;
;
FINDLOC: 
;GIVEN CLUSTER NUMBER 0..8192 RETURN SO, PO, BIT           
; CREATE #POINTERS DISTANCE INTO FILE IN MP1
; MULTIPLY BY WPLEN FOR NUMBER OF BITS IN FILE 
; #BITS / 2048 = SECTOR OFFSET
; #BITS - (SO * 2048) = BITSINSECTOR
; BITSINSECTOR / 8 = POSITION
; BITSINSECTOR AND 111 = BIT OFFSET 
; MAXWOR = # WORDS IN CLUSTER   
;
;INDEX :     CTOTALS   CNUMPTRS  
; 16   :        0         00
; 15   :        X        16*NC
; 14   :       X+Y    16*NC+15*NC
; ...  :       ...        ...
;  1   :        N         
;
;ASSUME P1 = CLUSTER NUMBER
; 
 LDA #BC ;SILLY SPECIAL CASE FOR 1 17 ENTRY CLUSTER
 STA MAXWOR
;
 JSR CLRMP1 ;MP1 = 000
;
 LDA P1
 ORA P1+1
; CMP #0
 BEQ ABSSTR ;ABSOLUTE BEGINNING,         
;
 LDX #BC+2 ;MAXIMUM WORDS/CLUSTER (BC) S/B LARGER 3..N
 STX MAXWOR ;COUNT DOWN
 LDX #$FE ;-2
FLOOP: 
 INX
 INX ;0..2..4..6..
 DEC MAXWOR ;18..1 
;
 LDA P1+1
 CMP CTOTALS+1,X
 BEQ FLOO1 ;TEST LO BYTES
 BCS FLOOP ;P1 > #TOTALS ENTRY, NEXT REGION!
 BCC FIRSTR ;P1 < #TOTALS, THIS REGION!  
;
FLOO1:
 LDA P1
 CMP CTOTALS,X
 BEQ FLOFIR ;1ST CLUSTER IN REGION, FORCE ZERO                      
;THEN WE ARE DONE
 BCS FLOOP ;P1 > #TOTALS ENTRY, TRY NEXT REGION
 BCC FIRSTR ;IN PREVIOUS REGION
;
;IF THIS WERE 1ST ELEMENT OF 1ST REGION, PROCESS SEPERATELY                                                   
FLOFIR:
;ONLY FOR 1ST ELEMENT IN A REGION 
 DEC MAXWOR ;ONE MORE DOWN BECAUSE ON SAME REGION,NOT PAST
 JMP MP1ISF ;AND COMPUTE
;
FIRSTR:
;
;ADJUST .X (2..4..6..8) TO POINT TO PREVIOUS
;REGION.  NOTE THAT 0 IS NOT POSSIBLE DUE TO PREVIOUS
;CHECK FOR P1=0, AND ANY OTHER NUMBER IS OBVIOUSLY 
;GREATER.
 DEX
 DEX
;
;CALCULATE NUMBER OF POINTERS THIS REGION
;ACTUAL CLUSTER NUMBER(P1) - TOTAL ENTRIES TO HERE CTOTALS             
 SEC 
 LDA P1
 SBC CTOTALS,X 
 STA MP1
 LDA P1+1
 SBC CTOTALS+1,X
 STA MP1+1 ;MP1 = NUMBER OF ENTRIES FROM START OF REGION
;
; LDA MP1
; ORA MP1+1
; CMP #0
; BNE MP1ISF ;(DEBUG) MP1 IS NEVER TO BE ZERO!     
; LDA #$8  
; JMP TEXIT ;EXIT FLAGGING MP1=1    
;
MP1ISF:
;JSR DEC1MP1 ;MP1 = MP1-1 (COUNT TOTALS FROM 0) NO,CLUSTERS
;COUNT FROM 0..N
;
 LDA MAXWOR
 STA MP2
 JSR MP1XMP2 ;MP1 = MP1 * MP2 (16*8)-> (24)
;
;MP1 NOW HOLDS NUMBER OF POINTERS FROM START OF REGION
;
;NOW ADD NUMPTRS TOTAL FROM PREVIOUS REGIONS                
 CLC
 LDA CNUMPTRS,X
 ADC MP1
 STA MP1
 LDA CNUMPTRS+1,X    
 ADC MP1+1
 STA MP1+1
 LDA CNUMPTRS+2,X
 ADC MP1+2
 STA MP1+2
;
;NOW MP1 CONTAINS TOTAL NUMBER OF POINTERS FROM START OF FILE
;     
 LDA #WPLEN      
 STA MP2 ;MP2 = # BITS IN EACH POINTER
;
 JSR MP1XMP2 ;MP1 = MP1 * MP2
;MP1 NOW HOLDS TOTAL NUMBER OF BITS FROM START OF FILE      
;
ABSSTR:
;GOOD PLACE FOR ABSOLUTE START (1ST WORD) ENTRY
;
 JSR MP1TTMP ;MOVE MP1 TO TEMPOR      
;
 LDA #11
 JSR MP1ROL ; MP1 = MP1 / 2048 BY SHIFTING
 LDA MP1 ;S/B UNNECCESSARY  
 STA SO ;HERE IS THE BLOODY SECTOR OFFSET!
 LDA #0  
 STA SO+1 ;ASSUME POINTER FILE < 256 SECTORS 
;
 LDA #11  
 JSR MP1ASL ;MP1 = MP1 * 2048 BY SHIFTING   
; NOW MP1 CONTAINS NUMBER BITS IN ALL SECTORS UP TO ACTUAL
; SUBTRACT THIS FROM TEMPOR TO CREATE BITS IN SECTOR
 SEC
 LDA TEMPOR
 SBC MP1
 STA MP1
 AND #$7 ;CHECK THIS   
 STA BIIIT ;TO CREATE ACTUAL BIT POSITION
 LDA TEMPOR+1
 SBC MP1+1
 STA MP1+1
 LDA #0
 STA MP1+2 ;MP1 = BITS IN SECTOR
;
 LDA #3
 JSR MP1ROL ;MP1 = MP1 / 8 BY SHIFTING
 LDA MP1
 STA PO ;POSITION IN SECTOR
;
; CONVERT SO,PO,BIIT INTO TRACK,SECTOR,POS   
;
 JSR FLUSH ;CLEAR OUT BITBIN FOR FRESH DATA        
;
 JSR PSTARTT ;SET TRACK, SECTOR START FOR PFILE  
;
 JSR READSEC ;READ SECTOR WITH SO OF CLUSTER INFORMATION    
;
 JSR POSITON ;SET POINTER TO BYTE CONTAINING POINTER
;
 LDA BIIIT
 BEQ FIRST1 
;#11/20
 JMP INBITS ;STRIP AWAY THE "GARBAGE" BITS
;
FIRST1:
 RTS ;NOW POSITIONED AT POINTER
;   
;
TLETVER:
;VERIFY A TWO LETTER COMBINATION.
;.A IS NUMBER 1..N (WILL BE ZERO..N)
;
;
 ASL A ;A = A * 2          
 TAX 
;
 LDA WORD,Y  
;   
 LDA DOUBLETS,X
 CMP WORD,Y     
 BNE DOUBAD
;
 INY
 LDA WORD,Y 
 BNE TLETVE1
 JMP MEMOUT ;MEMORY IS OUT OF CHARACTERS...
;
TLETVE1:
 LDA WORD,Y  
;
 LDA DOUBLETS+1,X ;TEST AGAINST SECOND LETTER OF DOUBLET
 CMP WORD,Y
;  
 BEQ DSC ;THIS DOUBLET IS OK 
DOUBAD:     
 BCC DWLESS ;TARGET WORD < DISK DATA   
;# 11/20 DROPTHRU
; BCS DWNF   ;TARGET WORD > DISK DATA 
;
DWNF:
 JMP WNF
DSC:
 JMP SAMECR ;DOUBLET VERIFIED
DWLESS:
 JMP WLESS    
;
;
INTRKSEC:
; ADD 1 TO SECTOR, IF RANGE OVERFLOWED, THEN ADD 1 TO TRACK
; USES A,Y 
; UNHARMED .X     
 INC SECTOR 
 LDA SECTOR
 CMP #15 ;AT LEAST 15 SECTORS ON ANY TRACK    
 BCC SECOK
;
;SECTORS/TRACK = 20 + 2* (T>17) + (T>24) + (T>30)   
;                          -1       -1       -1
;
 LDA TRACK
 LDY #20  
 CMP #18 ; IF X > 17 THEN DEY,DEY        
 BCC TCHK1 ;T = 0..17
 DEY
 DEY
TCHK1:
 CMP #25
 BCC TCHK2 ;T = 0..24
 DEY
TCHK2:  
 CMP #31
 BCC TCHK3 ; T = 0..34 
 DEY
TCHK3:
 CPY SECTOR ;.Y = NUMBER SECTORS THIS REGION 0..N
 BEQ SECOK
 BCS SECOK
 INC TRACK
;
 LDA TRACK
 CMP #18 ;DOS STUFF?
 BNE TCHK4 ;NO, REGULAR START
 LDA #2      
 DB $2C
TCHK4:
 LDA #0
 STA SECTOR
SECOK:
 RTS
;
INCPOS:
;WATCH FOR END OF BUFFER, ADVANCE TO NEXT TRACK,
;SECTOR IF SO.  INCREMENT SO FOR FINAL WORD (TO
;AVOID) LOCATION.
 INC PO 
 BNE INCPOS1 ;WE ARE NOT OUT OF BYTES YET
;
 JSR INTRKSEC ;BUMP UP NEXT TRACK/SECTOR
 LDA #0 ;CLEAR NEW PO
 STA PO
 JSR INCWSO ;SO = SO + 1
;
 JMP RSECTOR ;READ SECTOR FROM EXISTING TRACK, SECTOR
INCPOS1:
 RTS
;
READSEC:
;BE SURE TRACK AND SECTOR ARE SET TO ABSOLUTE
;"START OF FILE" BEFORE CALLING
 LDA SO 
 STA P1 
 LDA SO+1
 STA P1+1 ;MOVE SO(SECTOR OFFSET) TO P1
;
READS1:
 LDA P1+1
 ORA P1
; CMP #0
 BEQ RSECTOR ;IF AT START, THEN SKIP BUMP ROUTINE
;
BUMPFD:   
 JSR INTRKSEC ;INCREMENT SECTOR AND TRACK BY 1
 JSR DECWP1
 JMP READS1 
;
;
;READ FROM EXISTING TRACK, SECTOR    
;
RSECTOR:
;UNHARMED .X
 TXA      
 PHA
 JSR CLRCHN
 LDX #$F
 JSR CHKOUT
;
 LDX #UMSGE-UMSG-1
SENDU1:
 LDA UMSG,X
 JSR CHROUT
 DEX 
 BPL SENDU1 ;'U1:2 0 '
;         
 LDA TRACK
 JSR SENDASC 
;
; LDA #' '
; JSR CHROUT
 JSR SPACE_OUT
;
 LDA SECTOR
 JSR SENDASC
;
;JSR CLRCHN
;LDX #$2
;JSR CHKIN ;CHANNEL 2 IS INPUT  
 JSR CHNL2I  
 JSR CLR_CHNL2I
 PLA
 TAX
HRTS:
 RTS
;
POSITON: 
;
 LDA PO ;DON'T BOTHER TO SEND IF ZERO 
 BEQ HRTS 
;
 JSR CLRCHN ;CLEAR CHANNEL 2 
 LDX #$0F
 JSR CHKOUT
;
 LDX #PMSGE-PMSG-1
POSITO1:
 LDA PMSG,X ;'B-P:2,'
 JSR CHROUT
 DEX
 BPL POSITO1
;
 LDA PO
 JSR SENDASC
;
 JSR CLRCHN ;CLOSE CHANNEL 15
;LDX #$2
;JMP CHKIN
 JMP CHNL2I
;   
INCWSO:
 INC SO
 BNE INCWSO1
 INC SO+1
INCWSO1:
 RTS
; 
CLRMP1:
 LDA #0
 STA MP1
 STA MP1+1
 STA MP1+2
 RTS
;
SENDASC:
;SEND .AC IN ASCII (0..255) TO CHROUT
; UNHARMED .X 
; WILL SEND MINIMUM (0, NOT 000) TO DISK   
 STX T4 ;SAVE .X    
;
 LDX #'0' 
 LDY #'0'
SEHUND:
 CMP #100
 BCC SETENS 
 SBC #100
 INX ;ONE HUNDRED
 BNE SEHUND ;ANOTHER HUNDRED?                 
SETENS:
 CMP #10
 BCC ONES
 SBC #10
 INY
 BNE SETENS
ONES:
 ADC #'0'
 STA T3
 CPX #'0' ;IS HUNDREDS PLACE 0? 
 BEQ LODID ;IF SO, DO NOT SEND, CHECK 10'S
;
 TXA ;.A = HUNDREDS PLACE  
 STY T5 ;IN CASE CHROUT SHOULD HARM .Y
 JSR CHROUT ;HUNDREDS PLACE
 LDA T5 ;A = Y (ALWAYS SEND TENS HERE)
 BNE LODID1 ;BRA
;
LODID:
 CPY #'0' ;IS TENS PLACE 0?
 BEQ LODID2 ;IF SO, SKIP & SEND ONES   
;
 TYA ;TENS IS NOT ZERO, SEND   
LODID1:
 JSR CHROUT ;TENS PLACE 
LODID2:
 LDA T3
 JSR CHROUT ;ONES PLACE
 LDX T4 ;RESTORE X 
 RTS
;                    
MP1XMP2:
;16 * 8 MULTIPLY WITH 24 BIT RESULT
;USES AC,RESULT,MP1,MP2
;UNHARMED .X,.Y
;
 TXA
 PHA ;SAVE .X
 LDX #8 ;NUMBER OF BITS TO SHIFT THRU
 LDA #0
 STA RESULT
 STA RESULT+1
;
MSHIFT:
 ASL RESULT
 ROL RESULT+1
 ROL RESULT+2 ;PRODUCT = 2 * PRODUCT
;
 ASL MP2 ;BYTE-MULTIPLIER * 2
 BCC MNOADD
;
 CLC
 LDA RESULT
 ADC MP1 ;MULTIPLICAND-WORD
 STA RESULT
 LDA RESULT+1
 ADC MP1+1
 STA RESULT+1
 LDA RESULT+2
 ADC #0
 STA RESULT+2
;
MNOADD:
 DEX
 BNE MSHIFT
;       
 LDA RESULT+2
 STA MP1+2
 LDA RESULT+1
 STA MP1+1
;
 PLA
 TAX ;RESTORE .X
;
 LDA RESULT
 STA MP1           
 RTS
;
MP1TTMP:
 LDA MP1
 STA TEMPOR
 LDA MP1+1
 STA TEMPOR+1
 LDA MP1+2
 STA TEMPOR+2   
 RTS ;MOVE MP1 TO TEMPORARY      
;
;
FND1LT:
;FIND FIRST LETTER OF WORD 
;SO, PO OF WORD ONLY INPUT
; USES X,A,T1
; UNHARMED Y 
;
 LDX #2
FND1L1:
 LDA SO,X
 CMP WSO,X    
 BNE FND1L2 ;NOT DUPLICATE OF CALLING WORD
 DEX 
 BPL FND1L1
;
 SEC
 RTS ;CS = THIS IS SAME AS CALLED WORD      
;REMOVE FOR NOW TO ALLOW ALL WORDS
;
FND1L2:
;
 LDX #0 
 STX T1 ;LETTER A..Z 
 BEQ FND1L4
;      
FND1L3:
 INX
 INX
 INX
FND1L4: 
 INC T1 ;LETTER A..Z   
;
 LDA LETTER+1,X 
 CMP SO+1
 BEQ FND1L5
 BCS FND1L7 ;LETTER > SO, LAST LETTER IS LETTER
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN. 
;
FND1L5:  
 LDA LETTER,X  
 CMP SO
 BEQ FND1L6 
 BCS FND1L7 
 BCC FND1L3 ;LETTER < SO, BUMP UP TABLE AND TRY AGAIN. 
;
FND1L6:
 LDA LETTER+2,X ;POSITION   
 CMP PO
 BEQ FND1L8 ;ON EXACT BOUNDRY,NO DEC 
 BCC FND1L3 ;LETTER < PO, BUMP UP TABLE, TRY AGAIN.  
; 
FND1L7:
 DEC T1
FND1L8:
 LDA T1
 CLC
 RTS
;
WSTARTT:
 LDA #2 
 DB $2C
PSTARTT:         
 LDA #23
 STA TRACK
 LDA #0
 STA SECTOR
 RTS
;
MP1ROL:
 STA BITROT ;# OF BITS TO SHIFT    
MP1RL1:
 LSR MP1+2
 ROR MP1+1 
 ROR MP1   
 DEC BITROT
 BNE MP1RL1 
 RTS
;
MP1ASL:
 STA BITROT ;# OF BITS TO SHIFT    
MP1AS1:
 ASL MP1
 ROL MP1+1
 ROL MP1+2
 DEC BITROT
 BNE MP1AS1
 RTS    
;
DECWP1:
 LDA P1
 BNE DECWP11
 DEC P1+1
DECWP11:
 DEC P1
 RTS
;
DEC1MP1:
 LDA MP1 ;MP1 = MP1-1 (16 BIT ONLY!!!)
 BNE DECMP11
 DEC MP1+1
DECMP11:
 DEC MP1
 RTS
;
INLETT:
;SET FOR LETTER READ AND FALL IN INBITS      
 LDA #5
;
INBITS:   
; PEEL .A BYTES FROM INPUT CHANNEL
;
; USES .A,.X,.Y,T1,T2,SO,PO,BIIT,BITBIN,BITROT  
; RETURNS .A, RETRNA  
;
STRIP:
 STA BITROT  ;NUMBER OF BITS
 LDA #0
 STA RETRNA
 STA RETRNA+1 ;CLEAR OUT RETURNED VALUE 
STRIP0:
 LDA BIIT
 BEQ STRIP2 ;NO BITS LEFT IN BIN
STRIP3:
 ASL BITBIN
 ROL RETRNA
 ROL RETRNA+1 ;SLIDE NEW BIT INTO RETURN WORD         
 DEC BIIT
 DEC BITROT
 BNE STRIP0
 LDA RETRNA
 CLC
 RTS
;
STRIP2:
 STY T1   
 STX T2
;
 JSR CHRIN
;
 BCS BEXIT
;
;HANDLE TRACK/SECTOR BUFFERING
 PHA 
; LDA PO
 JSR INCPOS ;BUMP UP POSITION AND STREAM FILE IF NEEDED
 PLA
;
POSOK:
 STA BITBIN
 LDY T1
 LDX STATUS
 BNE BEXIT ;GET OUT
 LDX T2
 LDA #8
 STA BIIT
 BNE STRIP3 ;BRA   
;
FLUSH: 
;CLEAR OUT BITBIN FOR NEW STRIP
 LDA #0
 STA BIIT
 RTS
;
BEXIT: 
;DEBUG 
 LDA #$DE ;DISK ERROR!
 JMP TEXIT
;
 SEC    
 RTS   
;
WNDX:  
 DB 0 
 DB 0
PUTCHAR:
;PUT A CHAR FROM WORD INTO BUFF
 STY WNDX+1 ;SAVE .Y
 LDY WNDX
 STA WORD,Y
 INC WNDX
 LDY WNDX+1 ;RESTORE .Y 
 RTS
;      
;DISK DRIVE # SPECIFICATION
UMSG:
 DB ' 0 2:1U'
UMSGE:     
;
THESAURUS_DRIVE: EQU UMSG+1
;   
PMSG:
 DB ' 2:P-B'
PMSGE:  
;
CHANNEL:
 DB '#'
;
CTOTALS:
; TOTALS (BY SECTION) FOR THESAURUS 
 DW 0000,0001,0075,0132,0235,0378,0567,0787,1083,1359
 DW 1641,1934,2274,2745,3184,3342,0000     
;*NEVER* CHANGE THIS TABLE W/O REFLECTING IN CNUMPTRS!!!        
;
;
CNUMPTRS:
; TABLE OF WORDS OF TOTALS FOR NUMBER OF POINTERS/REGION (CUMULATIVE)
; *NEVER* CHANGE THIS TABLE W/O REFLECTING IN CTOTALS!!!  
V1  EQU BC*0001
V1X EQU BC*0074-01*0074 
V2  VAR V1+V1X
V2X EQU BC*0057-02*0057
V3  VAR V2+V2X
V3X EQU BC*0103-03*0103
V4  VAR V3+V3X
V4X EQU BC*0143-04*0143
V5  VAR V4+V4X
V5X EQU BC*0189-05*0189
V6  VAR V5+V5X
V6X EQU BC*0220-06*0220
V7  VAR V6+V6X
V7X EQU BC*0296-07*0296
V8  VAR V7+V7X
V8X EQU BC*0276-08*0276
V9  VAR V8+V8X
V9X EQU BC*0282-09*0282   
V10 VAR V9+V9X
V10X EQU BC*0293-10*0293
V11 VAR V10+V10X
V11X EQU BC*0340-11*0340
V12 VAR V11+V11X
V12X EQU BC*0471-12*0471
V13 VAR V12+V12X 
V13X EQU BC*0439-13*0439
V14 VAR V13+V13X
V14X EQU BC*0158-14*0158
V15 VAR V14+V14X
;
;
 DW 0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15 
;
LETTER:
;TABLE OF STARTING SO,PO FOR EACH LETTER A..Z
.IFFALSE ENABLE_THESAURUS
;A
 DW 0
 DB 0
;B
 DW 29
 DB 098
;C
 DW 48
 DB 027
;D
 DW 84
 DB 222
;E
 DW 114
 DB 155
;F
 DW 136
 DB 002
;G
 DW 157
 DB 172
;H
 DW 169
 DB 112
;I
 DW 180
 DB 229
;J
 DW 205
 DB 241
;K
 DW 208
 DB 204
;L
 DW 210
 DB 079
;M
 DW 224
 DB 006
;N
 DW 242
 DB 141
;O
 DW 248
 DB 072
;P
 DW 258
 DB 086
;Q
 DW 294
 DB 005
;R
 DW 295
 DB 179
;S
 DW 321
 DB 035
;T
 DW 365
 DB 000
;U
 DW 384
 DB 071
;V
 DW 397
 DB 249
;W
 DW 406
 DB 038
;X
 DW 416
 DB 064
;Y           
 DW 416
 DB 077
;Z
 DW 417
 DB 047
;END OF ALL (FOR USE BY SO,PO COMPARITOR)    
 DW 418
 DB 0
.ENDIF
;
LETTEO:
;TABLE OF STARTING SO,PO FOR EACH WORD AO..ZO
.IFFALSE ENABLE_THESAURUS
;AO
 DW 18
 DB 187
;BO
 DW 40
 DB 120
;CO
 DW 60
 DB 130
;DO
 DW 109
 DB 182
;EO
 DW 125
 DB 021
;FO
 DW 148
 DB 216
;GO
 DW 163
 DB 026
;HO
 DW 176
 DB 107
;IO
 DW 204
 DB 177
;JO
 DW 206
 DB 228
;KO
 DW 210
 DB 074
;LO
 DW 219
 DB 209
;MO
 DW 236
 DB 253
;NO
 DW 245
 DB 207
;OO
 DW 252
 DB 124
;PO
 DW 273
 DB 095
;QO WATCH OUT HERE, S/B SAME AS ORIG
 DW 294
 DB 005
;RO
 DW 317
 DB 224
;SO
 DW 341
 DB 078
;TO
 DW 374
 DB 138
;UO
 DW 396
 DB 082
;VO
 DW 404
 DB 198
;WO
 DW 413
 DB 160
;XO AGAIN SAME
 DW 416
 DB 064
;YO          
 DW 416
 DB 239
;ZO
 DW 417
 DB 047
;*NOTE* TEST
 DW 418
 DB 0
.ENDIF
;
; DOUBLET TABLES
;
DOUBLETS:
.IFFALSE ENABLE_THESAURUS
 DB 'E'-64,'R'-64 ;ER 0
 DB 'O'-64,'N'-64 ;ON 1
 DB 'T'-64,'I'-64 ;TI 2
 DB 'A'-64,'T'-64 ;AT 3
 DB 'T'-64,'E'-64 ;TE 4
;
 DB 'Q'-64,'U'-64 ;QU 5 (SPECIAL CASE, REPLACE Q CODE)               
.ENDIF
;
PSODATA:
;STORAGE FOR EACH CLUSTER'S ENTRIES
;SO POSITIONS 
 DW 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20   
PPODATA: 
;PO POSITIONS        
 DB 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;
CDATA:
;ACTUAL CLUSTER #'S PICKED UP TO REFERENCE    
.IFFALSE ENABLE_THESAURUS
 DW 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17     
.ENDIF
;
;SOME VARIABLES FOR STRIP (S/B ZP)
;
;RETRNA  DW 0 ;RETURN VALUE FOR STRIP (WORD)
;BIIT    DB 0
;BITBIN  DB 0
;BITROT  DB 0
;
;       
TEXIT:
 STA $FF ;WHERE DID WE COME FROM? (DEBUG)   
;
CLEARF:
 JSR CLRCHN 
 LDA #$F
 JSR CLOSE
; LDA #$2
; JSR CLOSE
; JMP CLALL
 JMP CLOSE2
; JMP CLALL
;
IODRIVE:
 DB 'U;' 
;
OVERLAY_MARK_BEGIN:
;
 END
; 

